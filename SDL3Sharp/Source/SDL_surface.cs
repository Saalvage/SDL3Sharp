// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required
#pragma warning disable CS9084 // Struct member returns 'this' or other instance members by reference

namespace SDL3Sharp
{
    /// <summary>The scaling mode</summary>
    public enum ScaleMode
    {
        /// <summary>nearest pixel sampling</summary>
        Nearest = 0,
        /// <summary>linear filtering</summary>
        Linear = 1,
        /// <summary>anisotropic filtering</summary>
        Best = 2
    }

    /// <summary>The flip mode</summary>
    public enum FlipMode
    {
        /// <summary>Do not flip</summary>
        None = 0,
        /// <summary>flip horizontally</summary>
        Horizontal = 1,
        /// <summary>flip vertically</summary>
        Vertical = 2
    }

    /// <summary>The scaling mode</summary>
    /// <summary>The flip mode</summary>
    /// <summary>A collection of pixels used in software blitting.</summary>
    /// <remarks>
    /// <para>Pixels are arranged in memory in rows, with the top row first.</para>
    /// <para>Each row occupies an amount of memory given by the pitch (sometimes</para>
    /// <para>known as the row stride in non-SDL APIs).</para>
    /// <para>Within each row, pixels are arranged from left to right until the</para>
    /// <para>width is reached.</para>
    /// <para>Each pixel occupies a number of bits appropriate for its format, with</para>
    /// <para>most formats representing each pixel as one or more whole bytes</para>
    /// <para>(in some indexed formats, instead multiple pixels are packed into</para>
    /// <para>each byte), and a byte order given by the format.</para>
    /// <para>After encoding all pixels, any remaining bytes to reach the pitch are</para>
    /// <para>used as padding to reach a desired alignment, and have undefined contents.</para>
    /// <para>This structure should be treated as read-only, except forwhich, if not NULL, contains the raw pixel data for the surface.</para>
    /// <para>SDL_CreateSurfaceFrom</para>
    /// </remarks>
    /// <summary>The type of function used for surface blitting functions.</summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate int Blit(__IntPtr src, __IntPtr srcrect, __IntPtr dst, __IntPtr dstrect);

    public unsafe partial class BlitMap
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.BlitMap> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.BlitMap>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.BlitMap managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.BlitMap managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static BlitMap __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new BlitMap(native.ToPointer(), skipVTables);
        }

        internal static BlitMap __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (BlitMap)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static BlitMap __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BlitMap(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BlitMap(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected BlitMap(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    /// <summary>A collection of pixels used in software blitting.</summary>
    /// <remarks>
    /// <para>Pixels are arranged in memory in rows, with the top row first.</para>
    /// <para>Each row occupies an amount of memory given by the pitch (sometimes</para>
    /// <para>known as the row stride in non-SDL APIs).</para>
    /// <para>Within each row, pixels are arranged from left to right until the</para>
    /// <para>width is reached.</para>
    /// <para>Each pixel occupies a number of bits appropriate for its format, with</para>
    /// <para>most formats representing each pixel as one or more whole bytes</para>
    /// <para>(in some indexed formats, instead multiple pixels are packed into</para>
    /// <para>each byte), and a byte order given by the format.</para>
    /// <para>After encoding all pixels, any remaining bytes to reach the pitch are</para>
    /// <para>used as padding to reach a desired alignment, and have undefined contents.</para>
    /// <para>This structure should be treated as read-only, except forwhich, if not NULL, contains the raw pixel data for the surface.</para>
    /// <para>SDL_CreateSurfaceFrom</para>
    /// </remarks>
    public unsafe partial class Surface : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 96, Pack = 8)]
        public partial struct __Internal
        {
            internal uint flags;
            internal __IntPtr format;
            internal int w;
            internal int h;
            internal int pitch;
            internal __IntPtr pixels;
            internal __IntPtr reserved;
            internal int locked;
            internal __IntPtr list_blitmap;
            internal global::SDL3Sharp.Rect.__Internal clip_rect;
            internal __IntPtr map;
            internal int refcount;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_Surface@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.Surface> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.Surface>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.Surface managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.Surface managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Surface __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Surface(native.ToPointer(), skipVTables);
        }

        internal static Surface __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Surface)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Surface __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Surface(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Surface(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Surface(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public Surface()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.Surface.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public Surface(global::SDL3Sharp.Surface _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.Surface.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.Surface.__Internal*) __Instance) = *((global::SDL3Sharp.Surface.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Read-only</summary>
        public uint Flags
        {
            get
            {
                return ((__Internal*)__Instance)->flags;
            }

            set
            {
                ((__Internal*)__Instance)->flags = value;
            }
        }

        /// <summary>Read-only</summary>
        public global::SDL3Sharp.PixelFormat Format
        {
            get
            {
                var __result0 = global::SDL3Sharp.PixelFormat.__GetOrCreateInstance(((__Internal*)__Instance)->format, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->format = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>Read-only</summary>
        public int W
        {
            get
            {
                return ((__Internal*)__Instance)->w;
            }

            set
            {
                ((__Internal*)__Instance)->w = value;
            }
        }

        /// <summary>Read-only</summary>
        public int H
        {
            get
            {
                return ((__Internal*)__Instance)->h;
            }

            set
            {
                ((__Internal*)__Instance)->h = value;
            }
        }

        /// <summary>Read-only</summary>
        public int Pitch
        {
            get
            {
                return ((__Internal*)__Instance)->pitch;
            }

            set
            {
                ((__Internal*)__Instance)->pitch = value;
            }
        }

        /// <summary>Read-write</summary>
        public __IntPtr Pixels
        {
            get
            {
                return ((__Internal*)__Instance)->pixels;
            }

            set
            {
                ((__Internal*)__Instance)->pixels = (__IntPtr) value;
            }
        }

        /// <summary>Private</summary>
        public __IntPtr Reserved
        {
            get
            {
                return ((__Internal*)__Instance)->reserved;
            }

            set
            {
                ((__Internal*)__Instance)->reserved = (__IntPtr) value;
            }
        }

        /// <summary>Read-only</summary>
        public int Locked
        {
            get
            {
                return ((__Internal*)__Instance)->locked;
            }

            set
            {
                ((__Internal*)__Instance)->locked = value;
            }
        }

        /// <summary>Private</summary>
        public __IntPtr ListBlitmap
        {
            get
            {
                return ((__Internal*)__Instance)->list_blitmap;
            }

            set
            {
                ((__Internal*)__Instance)->list_blitmap = (__IntPtr) value;
            }
        }

        /// <summary>Read-only</summary>
        public global::SDL3Sharp.Rect ClipRect
        {
            get
            {
                return global::SDL3Sharp.Rect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->clip_rect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->clip_rect = *(global::SDL3Sharp.Rect.__Internal*) value.__Instance;
            }
        }

        /// <summary>Private</summary>
        public global::SDL3Sharp.BlitMap Map
        {
            get
            {
                var __result0 = global::SDL3Sharp.BlitMap.__GetOrCreateInstance(((__Internal*)__Instance)->map, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->map = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>Read-mostly</summary>
        public int Refcount
        {
            get
            {
                return ((__Internal*)__Instance)->refcount;
            }

            set
            {
                ((__Internal*)__Instance)->refcount = value;
            }
        }
    }

    public unsafe partial class SDL
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_CreateSurface", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CreateSurface(int width, int height, global::SDL3Sharp.PixelFormatEnum format);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_CreateSurfaceFrom", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CreateSurfaceFrom(__IntPtr pixels, int width, int height, int pitch, global::SDL3Sharp.PixelFormatEnum format);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_DestroySurface", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void DestroySurface(__IntPtr surface);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetSurfaceProperties", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint GetSurfaceProperties(__IntPtr surface);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetSurfaceColorspace", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetSurfaceColorspace(__IntPtr surface, global::SDL3Sharp.Colorspace colorspace);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetSurfaceColorspace", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetSurfaceColorspace(__IntPtr surface, global::SDL3Sharp.Colorspace* colorspace);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetSurfacePalette", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetSurfacePalette(__IntPtr surface, __IntPtr palette);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_LockSurface", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LockSurface(__IntPtr surface);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_UnlockSurface", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UnlockSurface(__IntPtr surface);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_LoadBMP_RW", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LoadBMP_RW(__IntPtr src, bool freesrc);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_LoadBMP", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LoadBMP([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string file);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SaveBMP_RW", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SaveBMP_RW(__IntPtr surface, __IntPtr dst, bool freedst);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SaveBMP", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SaveBMP(__IntPtr surface, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string file);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetSurfaceRLE", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetSurfaceRLE(__IntPtr surface, int flag);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SurfaceHasRLE", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool SurfaceHasRLE(__IntPtr surface);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetSurfaceColorKey", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetSurfaceColorKey(__IntPtr surface, int flag, uint key);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SurfaceHasColorKey", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool SurfaceHasColorKey(__IntPtr surface);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetSurfaceColorKey", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetSurfaceColorKey(__IntPtr surface, uint* key);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetSurfaceColorMod", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetSurfaceColorMod(__IntPtr surface, byte r, byte g, byte b);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetSurfaceColorMod", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetSurfaceColorMod(__IntPtr surface, byte* r, byte* g, byte* b);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetSurfaceAlphaMod", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetSurfaceAlphaMod(__IntPtr surface, byte alpha);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetSurfaceAlphaMod", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetSurfaceAlphaMod(__IntPtr surface, byte* alpha);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetSurfaceBlendMode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetSurfaceBlendMode(__IntPtr surface, global::SDL3Sharp.BlendMode blendMode);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetSurfaceBlendMode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetSurfaceBlendMode(__IntPtr surface, global::SDL3Sharp.BlendMode* blendMode);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetSurfaceClipRect", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool SetSurfaceClipRect(__IntPtr surface, __IntPtr rect);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetSurfaceClipRect", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetSurfaceClipRect(__IntPtr surface, __IntPtr rect);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_FlipSurface", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FlipSurface(__IntPtr surface, global::SDL3Sharp.FlipMode flip);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_DuplicateSurface", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr DuplicateSurface(__IntPtr surface);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_ConvertSurface", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ConvertSurface(__IntPtr surface, __IntPtr format);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_ConvertSurfaceFormat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ConvertSurfaceFormat(__IntPtr surface, global::SDL3Sharp.PixelFormatEnum pixel_format);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_ConvertSurfaceFormatAndColorspace", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ConvertSurfaceFormatAndColorspace(__IntPtr surface, global::SDL3Sharp.PixelFormatEnum pixel_format, global::SDL3Sharp.Colorspace colorspace, uint props);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_ConvertPixels", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int ConvertPixels(int width, int height, global::SDL3Sharp.PixelFormatEnum src_format, __IntPtr src, int src_pitch, global::SDL3Sharp.PixelFormatEnum dst_format, __IntPtr dst, int dst_pitch);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_ConvertPixelsAndColorspace", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int ConvertPixelsAndColorspace(int width, int height, global::SDL3Sharp.PixelFormatEnum src_format, global::SDL3Sharp.Colorspace src_colorspace, uint src_properties, __IntPtr src, int src_pitch, global::SDL3Sharp.PixelFormatEnum dst_format, global::SDL3Sharp.Colorspace dst_colorspace, uint dst_properties, __IntPtr dst, int dst_pitch);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_PremultiplyAlpha", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int PremultiplyAlpha(int width, int height, global::SDL3Sharp.PixelFormatEnum src_format, __IntPtr src, int src_pitch, global::SDL3Sharp.PixelFormatEnum dst_format, __IntPtr dst, int dst_pitch);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_FillSurfaceRect", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FillSurfaceRect(__IntPtr dst, __IntPtr rect, uint color);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_FillSurfaceRects", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FillSurfaceRects(__IntPtr dst, __IntPtr rects, int count, uint color);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_BlitSurface", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BlitSurface(__IntPtr src, __IntPtr srcrect, __IntPtr dst, __IntPtr dstrect);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_BlitSurfaceUnchecked", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BlitSurfaceUnchecked(__IntPtr src, __IntPtr srcrect, __IntPtr dst, __IntPtr dstrect);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SoftStretch", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SoftStretch(__IntPtr src, __IntPtr srcrect, __IntPtr dst, __IntPtr dstrect, global::SDL3Sharp.ScaleMode scaleMode);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_BlitSurfaceScaled", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BlitSurfaceScaled(__IntPtr src, __IntPtr srcrect, __IntPtr dst, __IntPtr dstrect, global::SDL3Sharp.ScaleMode scaleMode);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_BlitSurfaceUncheckedScaled", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BlitSurfaceUncheckedScaled(__IntPtr src, __IntPtr srcrect, __IntPtr dst, __IntPtr dstrect, global::SDL3Sharp.ScaleMode scaleMode);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_ReadSurfacePixel", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int ReadSurfacePixel(__IntPtr surface, int x, int y, byte* r, byte* g, byte* b, byte* a);
        }

        /// <summary>Allocate a new RGB surface with a specific pixel format.</summary>
        /// <param name="width">the width of the surface</param>
        /// <param name="height">the height of the surface</param>
        /// <param name="format">the SDL_PixelFormatEnum for the new surface's pixel format.</param>
        /// <remarks>
        /// <para>the new SDL_Surface structure that is created or NULL if it fails;</para>
        /// <para>call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateSurfaceFrom</para>
        /// <para>SDL_DestroySurface</para>
        /// </remarks>
        public static global::SDL3Sharp.Surface CreateSurface(int width, int height, global::SDL3Sharp.PixelFormatEnum format)
        {
            var ___ret = __Internal.CreateSurface(width, height, format);
            var __result0 = global::SDL3Sharp.Surface.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Allocate a new RGB surface with a specific pixel format and existing pixel</para>
        /// <para>data.</para>
        /// </summary>
        /// <param name="pixels">a pointer to existing pixel data</param>
        /// <param name="width">the width of the surface</param>
        /// <param name="height">the height of the surface</param>
        /// <param name="pitch">the pitch of the surface in bytes</param>
        /// <param name="format">the SDL_PixelFormatEnum for the new surface's pixel format.</param>
        /// <remarks>
        /// <para>No copy is made of the pixel data. Pixel data is not managed automatically;</para>
        /// <para>you must free the surface before you free the pixel data.</para>
        /// <para>Pitch is the offset in bytes from one row of pixels to the next, e.g.</para>
        /// <para>`width*4` for `SDL_PIXELFORMAT_RGBA8888`.</para>
        /// <para>You may pass NULL for pixels and 0 for pitch to create a surface that you</para>
        /// <para>will fill in with valid values later.</para>
        /// <para>the new SDL_Surface structure that is created or NULL if it fails;</para>
        /// <para>call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateSurface</para>
        /// <para>SDL_DestroySurface</para>
        /// </remarks>
        public static global::SDL3Sharp.Surface CreateSurfaceFrom(__IntPtr pixels, int width, int height, int pitch, global::SDL3Sharp.PixelFormatEnum format)
        {
            var ___ret = __Internal.CreateSurfaceFrom(pixels, width, height, pitch, format);
            var __result0 = global::SDL3Sharp.Surface.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Free an RGB surface.</summary>
        /// <param name="surface">the SDL_Surface to free.</param>
        /// <remarks>
        /// <para>It is safe to pass NULL to this function.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateSurface</para>
        /// <para>SDL_CreateSurfaceFrom</para>
        /// <para>SDL_LoadBMP</para>
        /// <para>SDL_LoadBMP_RW</para>
        /// </remarks>
        public static void DestroySurface(global::SDL3Sharp.Surface surface)
        {
            var __arg0 = surface is null ? __IntPtr.Zero : surface.__Instance;
            __Internal.DestroySurface(__arg0);
        }

        /// <summary>Get the properties associated with a surface.</summary>
        /// <param name="surface">the SDL_Surface structure to query</param>
        /// <remarks>
        /// <para>The following properties are understood by SDL:</para>
        /// <para>- `SDL_PROP_SURFACE_COLORSPACE_NUMBER`: an SDL_ColorSpace value describing</para>
        /// <para>the surface colorspace, defaults to SDL_COLORSPACE_SRGB_LINEAR for</para>
        /// <para>floating point formats, SDL_COLORSPACE_HDR10 for 10-bit formats,</para>
        /// <para>SDL_COLORSPACE_SRGB for other RGB surfaces and SDL_COLORSPACE_BT709_FULL</para>
        /// <para>for YUV surfaces.</para>
        /// <para>- `SDL_PROP_SURFACE_SDR_WHITE_POINT_FLOAT`: for HDR10 and floating point</para>
        /// <para>surfaces, this defines the value of 100% diffuse white, with higher</para>
        /// <para>values being displayed in the High Dynamic Range headroom. This defaults</para>
        /// <para>to 203 for HDR10 surfaces and 1.0 for floating point surfaces.</para>
        /// <para>- `SDL_PROP_SURFACE_HDR_HEADROOM_FLOAT`: for HDR10 and floating point</para>
        /// <para>surfaces, this defines the maximum dynamic range used by the content, in</para>
        /// <para>terms of the SDR white point. This defaults to 0.0, which disables tone</para>
        /// <para>mapping.</para>
        /// <para>- `SDL_PROP_SURFACE_TONEMAP_OPERATOR_STRING`: the tone mapping operator</para>
        /// <para>used when compressing from a surface with high dynamic range to another</para>
        /// <para>with lower dynamic range. Currently this supports &quot;chrome&quot;, which uses</para>
        /// <para>the same tone mapping that Chrome uses for HDR content, the form &quot;*=N&quot;,</para>
        /// <para>where N is a floating point scale factor applied in linear space, and</para>
        /// <para>&quot;none&quot;, which disables tone mapping. This defaults to &quot;chrome&quot;.</para>
        /// <para>a valid property ID on success or 0 on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetProperty</para>
        /// <para>SDL_SetProperty</para>
        /// </remarks>
        public static uint GetSurfaceProperties(global::SDL3Sharp.Surface surface)
        {
            var __arg0 = surface is null ? __IntPtr.Zero : surface.__Instance;
            var ___ret = __Internal.GetSurfaceProperties(__arg0);
            return ___ret;
        }

        /// <summary>Set the colorspace used by a surface.</summary>
        /// <param name="surface">the SDL_Surface structure to update</param>
        /// <param name="colorspace">an SDL_ColorSpace value describing the surface colorspace</param>
        /// <remarks>
        /// <para>Setting the colorspace doesn't change the pixels, only how they are</para>
        /// <para>interpreted in color operations.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int SetSurfaceColorspace(global::SDL3Sharp.Surface surface, global::SDL3Sharp.Colorspace colorspace)
        {
            var __arg0 = surface is null ? __IntPtr.Zero : surface.__Instance;
            var ___ret = __Internal.SetSurfaceColorspace(__arg0, colorspace);
            return ___ret;
        }

        /// <summary>Get the colorspace used by a surface.</summary>
        /// <param name="surface">the SDL_Surface structure to query</param>
        /// <param name="colorspace">
        /// <para>a pointer filled in with an SDL_ColorSpace value</para>
        /// <para>describing the surface colorspace</para>
        /// </param>
        /// <remarks>
        /// <para>The colorspace defaults to SDL_COLORSPACE_SRGB_LINEAR for floating point</para>
        /// <para>formats, SDL_COLORSPACE_HDR10 for 10-bit formats, SDL_COLORSPACE_SRGB for</para>
        /// <para>other RGB surfaces and SDL_COLORSPACE_BT709_FULL for YUV textures.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int GetSurfaceColorspace(global::SDL3Sharp.Surface surface, ref global::SDL3Sharp.Colorspace colorspace)
        {
            var __arg0 = surface is null ? __IntPtr.Zero : surface.__Instance;
            fixed (global::SDL3Sharp.Colorspace* __colorspace1 = &colorspace)
            {
                var __arg1 = __colorspace1;
                var ___ret = __Internal.GetSurfaceColorspace(__arg0, __arg1);
                return ___ret;
            }
        }

        /// <summary>Set the palette used by a surface.</summary>
        /// <param name="surface">the SDL_Surface structure to update</param>
        /// <param name="palette">the SDL_Palette structure to use</param>
        /// <remarks>
        /// <para>A single palette can be shared with many surfaces.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int SetSurfacePalette(global::SDL3Sharp.Surface surface, global::SDL3Sharp.Palette palette)
        {
            var __arg0 = surface is null ? __IntPtr.Zero : surface.__Instance;
            var __arg1 = palette is null ? __IntPtr.Zero : palette.__Instance;
            var ___ret = __Internal.SetSurfacePalette(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Set up a surface for directly accessing the pixels.</summary>
        /// <param name="surface">the SDL_Surface structure to be locked</param>
        /// <remarks>
        /// <para>Between calls to SDL_LockSurface() / SDL_UnlockSurface(), you can write to</para>
        /// <para>and read from `surface-&gt;pixels`, using the pixel format stored in</para>
        /// <para>`surface-&gt;format`. Once you are done accessing the surface, you should use</para>
        /// <para>SDL_UnlockSurface() to release it.</para>
        /// <para>Not all surfaces require locking. If `SDL_MUSTLOCK(surface)` evaluates to</para>
        /// <para>0, then you can read and write to the surface at any time, and the pixel</para>
        /// <para>format of the surface will not change.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_MUSTLOCK</para>
        /// <para>SDL_UnlockSurface</para>
        /// </remarks>
        public static int LockSurface(global::SDL3Sharp.Surface surface)
        {
            var __arg0 = surface is null ? __IntPtr.Zero : surface.__Instance;
            var ___ret = __Internal.LockSurface(__arg0);
            return ___ret;
        }

        /// <summary>Release a surface after directly accessing the pixels.</summary>
        /// <param name="surface">the SDL_Surface structure to be unlocked</param>
        /// <remarks>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_LockSurface</para>
        /// </remarks>
        public static void UnlockSurface(global::SDL3Sharp.Surface surface)
        {
            var __arg0 = surface is null ? __IntPtr.Zero : surface.__Instance;
            __Internal.UnlockSurface(__arg0);
        }

        /// <summary>Load a BMP image from a seekable SDL data stream.</summary>
        /// <param name="src">the data stream for the surface</param>
        /// <param name="freesrc">
        /// <para>if SDL_TRUE, calls SDL_RWclose() on `src` before returning,</para>
        /// <para>even in the case of an error</para>
        /// </param>
        /// <remarks>
        /// <para>The new surface should be freed with SDL_DestroySurface(). Not doing so</para>
        /// <para>will result in a memory leak.</para>
        /// <para>a pointer to a new SDL_Surface structure or NULL if there was an</para>
        /// <para>error; call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_DestroySurface</para>
        /// <para>SDL_LoadBMP</para>
        /// <para>SDL_SaveBMP_RW</para>
        /// </remarks>
        public static global::SDL3Sharp.Surface LoadBMP_RW(global::SDL3Sharp.RWops src, bool freesrc)
        {
            var __arg0 = src is null ? __IntPtr.Zero : src.__Instance;
            var ___ret = __Internal.LoadBMP_RW(__arg0, freesrc);
            var __result0 = global::SDL3Sharp.Surface.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Load a BMP image from a file.</summary>
        /// <param name="file">the BMP file to load</param>
        /// <remarks>
        /// <para>The new surface should be freed with SDL_DestroySurface(). Not doing so</para>
        /// <para>will result in a memory leak.</para>
        /// <para>a pointer to a new SDL_Surface structure or NULL if there was an</para>
        /// <para>error; call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_DestroySurface</para>
        /// <para>SDL_LoadBMP_RW</para>
        /// <para>SDL_SaveBMP</para>
        /// </remarks>
        public static global::SDL3Sharp.Surface LoadBMP(string file)
        {
            var ___ret = __Internal.LoadBMP(file);
            var __result0 = global::SDL3Sharp.Surface.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Save a surface to a seekable SDL data stream in BMP format.</summary>
        /// <param name="surface">the SDL_Surface structure containing the image to be saved</param>
        /// <param name="dst">a data stream to save to</param>
        /// <param name="freedst">
        /// <para>if SDL_TRUE, calls SDL_RWclose() on `dst` before returning,</para>
        /// <para>even in the case of an error</para>
        /// </param>
        /// <remarks>
        /// <para>Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the</para>
        /// <para>BMP directly. Other RGB formats with 8-bit or higher get converted to a</para>
        /// <para>24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit</para>
        /// <para>surface before they are saved. YUV and paletted 1-bit and 4-bit formats are</para>
        /// <para>not supported.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_LoadBMP_RW</para>
        /// <para>SDL_SaveBMP</para>
        /// </remarks>
        public static int SaveBMP_RW(global::SDL3Sharp.Surface surface, global::SDL3Sharp.RWops dst, bool freedst)
        {
            var __arg0 = surface is null ? __IntPtr.Zero : surface.__Instance;
            var __arg1 = dst is null ? __IntPtr.Zero : dst.__Instance;
            var ___ret = __Internal.SaveBMP_RW(__arg0, __arg1, freedst);
            return ___ret;
        }

        /// <summary>Save a surface to a file.</summary>
        /// <param name="surface">the SDL_Surface structure containing the image to be saved</param>
        /// <param name="file">a file to save to</param>
        /// <remarks>
        /// <para>Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the</para>
        /// <para>BMP directly. Other RGB formats with 8-bit or higher get converted to a</para>
        /// <para>24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit</para>
        /// <para>surface before they are saved. YUV and paletted 1-bit and 4-bit formats are</para>
        /// <para>not supported.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_LoadBMP</para>
        /// <para>SDL_SaveBMP_RW</para>
        /// </remarks>
        public static int SaveBMP(global::SDL3Sharp.Surface surface, string file)
        {
            var __arg0 = surface is null ? __IntPtr.Zero : surface.__Instance;
            var ___ret = __Internal.SaveBMP(__arg0, file);
            return ___ret;
        }

        /// <summary>Set the RLE acceleration hint for a surface.</summary>
        /// <param name="surface">the SDL_Surface structure to optimize</param>
        /// <param name="flag">0 to disable, non-zero to enable RLE acceleration</param>
        /// <remarks>
        /// <para>If RLE is enabled, color key and alpha blending blits are much faster, but</para>
        /// <para>the surface must be locked before directly accessing the pixels.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_BlitSurface</para>
        /// <para>SDL_LockSurface</para>
        /// <para>SDL_UnlockSurface</para>
        /// </remarks>
        public static int SetSurfaceRLE(global::SDL3Sharp.Surface surface, int flag)
        {
            var __arg0 = surface is null ? __IntPtr.Zero : surface.__Instance;
            var ___ret = __Internal.SetSurfaceRLE(__arg0, flag);
            return ___ret;
        }

        /// <summary>Returns whether the surface is RLE enabled</summary>
        /// <param name="surface">the SDL_Surface structure to query</param>
        /// <remarks>
        /// <para>It is safe to pass a NULL `surface` here; it will return SDL_FALSE.</para>
        /// <para>SDL_TRUE if the surface is RLE enabled, SDL_FALSE otherwise.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_SetSurfaceRLE</para>
        /// </remarks>
        public static bool SurfaceHasRLE(global::SDL3Sharp.Surface surface)
        {
            var __arg0 = surface is null ? __IntPtr.Zero : surface.__Instance;
            var ___ret = __Internal.SurfaceHasRLE(__arg0);
            return ___ret;
        }

        /// <summary>Set the color key (transparent pixel) in a surface.</summary>
        /// <param name="surface">the SDL_Surface structure to update</param>
        /// <param name="flag">SDL_TRUE to enable color key, SDL_FALSE to disable color key</param>
        /// <param name="key">the transparent pixel</param>
        /// <remarks>
        /// <para>The color key defines a pixel value that will be treated as transparent in</para>
        /// <para>a blit. For example, one can use this to specify that cyan pixels should be</para>
        /// <para>considered transparent, and therefore not rendered.</para>
        /// <para>It is a pixel of the format used by the surface, as generated by</para>
        /// <para>SDL_MapRGB().</para>
        /// <para>RLE acceleration can substantially speed up blitting of images with large</para>
        /// <para>horizontal runs of transparent pixels. See SDL_SetSurfaceRLE() for details.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_BlitSurface</para>
        /// <para>SDL_GetSurfaceColorKey</para>
        /// </remarks>
        public static int SetSurfaceColorKey(global::SDL3Sharp.Surface surface, int flag, uint key)
        {
            var __arg0 = surface is null ? __IntPtr.Zero : surface.__Instance;
            var ___ret = __Internal.SetSurfaceColorKey(__arg0, flag, key);
            return ___ret;
        }

        /// <summary>Returns whether the surface has a color key</summary>
        /// <param name="surface">the SDL_Surface structure to query</param>
        /// <remarks>
        /// <para>It is safe to pass a NULL `surface` here; it will return SDL_FALSE.</para>
        /// <para>SDL_TRUE if the surface has a color key, SDL_FALSE otherwise.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_SetSurfaceColorKey</para>
        /// <para>SDL_GetSurfaceColorKey</para>
        /// </remarks>
        public static bool SurfaceHasColorKey(global::SDL3Sharp.Surface surface)
        {
            var __arg0 = surface is null ? __IntPtr.Zero : surface.__Instance;
            var ___ret = __Internal.SurfaceHasColorKey(__arg0);
            return ___ret;
        }

        /// <summary>Get the color key (transparent pixel) for a surface.</summary>
        /// <param name="surface">the SDL_Surface structure to query</param>
        /// <param name="key">a pointer filled in with the transparent pixel</param>
        /// <remarks>
        /// <para>The color key is a pixel of the format used by the surface, as generated by</para>
        /// <para>SDL_MapRGB().</para>
        /// <para>If the surface doesn't have color key enabled this function returns -1.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_BlitSurface</para>
        /// <para>SDL_SetSurfaceColorKey</para>
        /// </remarks>
        public static int GetSurfaceColorKey(global::SDL3Sharp.Surface surface, ref uint key)
        {
            var __arg0 = surface is null ? __IntPtr.Zero : surface.__Instance;
            fixed (uint* __key1 = &key)
            {
                var __arg1 = __key1;
                var ___ret = __Internal.GetSurfaceColorKey(__arg0, __arg1);
                return ___ret;
            }
        }

        /// <summary>Set an additional color value multiplied into blit operations.</summary>
        /// <param name="surface">the SDL_Surface structure to update</param>
        /// <param name="r">the red color value multiplied into blit operations</param>
        /// <param name="g">the green color value multiplied into blit operations</param>
        /// <param name="b">the blue color value multiplied into blit operations</param>
        /// <remarks>
        /// <para>When this surface is blitted, during the blit operation each source color</para>
        /// <para>channel is modulated by the appropriate color value according to the</para>
        /// <para>following formula:</para>
        /// <para>`srcC = srcC * (color / 255)`</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetSurfaceColorMod</para>
        /// <para>SDL_SetSurfaceAlphaMod</para>
        /// </remarks>
        public static int SetSurfaceColorMod(global::SDL3Sharp.Surface surface, byte r, byte g, byte b)
        {
            var __arg0 = surface is null ? __IntPtr.Zero : surface.__Instance;
            var ___ret = __Internal.SetSurfaceColorMod(__arg0, r, g, b);
            return ___ret;
        }

        /// <summary>Get the additional color value multiplied into blit operations.</summary>
        /// <param name="surface">the SDL_Surface structure to query</param>
        /// <param name="r">a pointer filled in with the current red color value</param>
        /// <param name="g">a pointer filled in with the current green color value</param>
        /// <param name="b">a pointer filled in with the current blue color value</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetSurfaceAlphaMod</para>
        /// <para>SDL_SetSurfaceColorMod</para>
        /// </remarks>
        public static int GetSurfaceColorMod(global::SDL3Sharp.Surface surface, byte* r, byte* g, byte* b)
        {
            var __arg0 = surface is null ? __IntPtr.Zero : surface.__Instance;
            var ___ret = __Internal.GetSurfaceColorMod(__arg0, r, g, b);
            return ___ret;
        }

        /// <summary>Set an additional alpha value used in blit operations.</summary>
        /// <param name="surface">the SDL_Surface structure to update</param>
        /// <param name="alpha">the alpha value multiplied into blit operations</param>
        /// <remarks>
        /// <para>When this surface is blitted, during the blit operation the source alpha</para>
        /// <para>value is modulated by this alpha value according to the following formula:</para>
        /// <para>`srcA = srcA * (alpha / 255)`</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetSurfaceAlphaMod</para>
        /// <para>SDL_SetSurfaceColorMod</para>
        /// </remarks>
        public static int SetSurfaceAlphaMod(global::SDL3Sharp.Surface surface, byte alpha)
        {
            var __arg0 = surface is null ? __IntPtr.Zero : surface.__Instance;
            var ___ret = __Internal.SetSurfaceAlphaMod(__arg0, alpha);
            return ___ret;
        }

        /// <summary>Get the additional alpha value used in blit operations.</summary>
        /// <param name="surface">the SDL_Surface structure to query</param>
        /// <param name="alpha">a pointer filled in with the current alpha value</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetSurfaceColorMod</para>
        /// <para>SDL_SetSurfaceAlphaMod</para>
        /// </remarks>
        public static int GetSurfaceAlphaMod(global::SDL3Sharp.Surface surface, byte* alpha)
        {
            var __arg0 = surface is null ? __IntPtr.Zero : surface.__Instance;
            var ___ret = __Internal.GetSurfaceAlphaMod(__arg0, alpha);
            return ___ret;
        }

        /// <summary>Set the blend mode used for blit operations.</summary>
        /// <param name="surface">the SDL_Surface structure to update</param>
        /// <param name="blendMode">the SDL_BlendMode to use for blit blending</param>
        /// <remarks>
        /// <para>To copy a surface to another surface (or texture) without blending with the</para>
        /// <para>existing data, the blendmode of the SOURCE surface should be set to</para>
        /// <para>`SDL_BLENDMODE_NONE`.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetSurfaceBlendMode</para>
        /// </remarks>
        public static int SetSurfaceBlendMode(global::SDL3Sharp.Surface surface, global::SDL3Sharp.BlendMode blendMode)
        {
            var __arg0 = surface is null ? __IntPtr.Zero : surface.__Instance;
            var ___ret = __Internal.SetSurfaceBlendMode(__arg0, blendMode);
            return ___ret;
        }

        /// <summary>Get the blend mode used for blit operations.</summary>
        /// <param name="surface">the SDL_Surface structure to query</param>
        /// <param name="blendMode">a pointer filled in with the current SDL_BlendMode</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_SetSurfaceBlendMode</para>
        /// </remarks>
        public static int GetSurfaceBlendMode(global::SDL3Sharp.Surface surface, ref global::SDL3Sharp.BlendMode blendMode)
        {
            var __arg0 = surface is null ? __IntPtr.Zero : surface.__Instance;
            fixed (global::SDL3Sharp.BlendMode* __blendMode1 = &blendMode)
            {
                var __arg1 = __blendMode1;
                var ___ret = __Internal.GetSurfaceBlendMode(__arg0, __arg1);
                return ___ret;
            }
        }

        /// <summary>Set the clipping rectangle for a surface.</summary>
        /// <param name="surface">the SDL_Surface structure to be clipped</param>
        /// <param name="rect">
        /// <para>the SDL_Rect structure representing the clipping rectangle, or</para>
        /// <para>NULL to disable clipping</para>
        /// </param>
        /// <remarks>
        /// <para>When `surface` is the destination of a blit, only the area within the clip</para>
        /// <para>rectangle is drawn into.</para>
        /// <para>Note that blits are automatically clipped to the edges of the source and</para>
        /// <para>destination surfaces.</para>
        /// <para>SDL_TRUE if the rectangle intersects the surface, otherwise</para>
        /// <para>SDL_FALSE and blits will be completely clipped.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_BlitSurface</para>
        /// <para>SDL_GetSurfaceClipRect</para>
        /// </remarks>
        public static bool SetSurfaceClipRect(global::SDL3Sharp.Surface surface, global::SDL3Sharp.Rect rect)
        {
            var __arg0 = surface is null ? __IntPtr.Zero : surface.__Instance;
            var __arg1 = rect is null ? __IntPtr.Zero : rect.__Instance;
            var ___ret = __Internal.SetSurfaceClipRect(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Get the clipping rectangle for a surface.</summary>
        /// <param name="surface">
        /// <para>the SDL_Surface structure representing the surface to be</para>
        /// <para>clipped</para>
        /// </param>
        /// <param name="rect">
        /// <para>an SDL_Rect structure filled in with the clipping rectangle for</para>
        /// <para>the surface</para>
        /// </param>
        /// <remarks>
        /// <para>When `surface` is the destination of a blit, only the area within the clip</para>
        /// <para>rectangle is drawn into.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_BlitSurface</para>
        /// <para>SDL_SetSurfaceClipRect</para>
        /// </remarks>
        public static int GetSurfaceClipRect(global::SDL3Sharp.Surface surface, global::SDL3Sharp.Rect rect)
        {
            var __arg0 = surface is null ? __IntPtr.Zero : surface.__Instance;
            var __arg1 = rect is null ? __IntPtr.Zero : rect.__Instance;
            var ___ret = __Internal.GetSurfaceClipRect(__arg0, __arg1);
            return ___ret;
        }

        public static int FlipSurface(global::SDL3Sharp.Surface surface, global::SDL3Sharp.FlipMode flip)
        {
            var __arg0 = surface is null ? __IntPtr.Zero : surface.__Instance;
            var ___ret = __Internal.FlipSurface(__arg0, flip);
            return ___ret;
        }

        public static global::SDL3Sharp.Surface DuplicateSurface(global::SDL3Sharp.Surface surface)
        {
            var __arg0 = surface is null ? __IntPtr.Zero : surface.__Instance;
            var ___ret = __Internal.DuplicateSurface(__arg0);
            var __result0 = global::SDL3Sharp.Surface.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Copy an existing surface to a new surface of the specified format.</summary>
        /// <param name="surface">the existing SDL_Surface structure to convert</param>
        /// <param name="format">
        /// <para>the SDL_PixelFormat structure that the new surface is</para>
        /// <para>optimized for</para>
        /// </param>
        /// <remarks>
        /// <para>This function is used to optimize images for faster *repeat* blitting. This</para>
        /// <para>is accomplished by converting the original and storing the result as a new</para>
        /// <para>surface. The new, optimized surface can then be used as the source for</para>
        /// <para>future blits, making them faster.</para>
        /// <para>the new SDL_Surface structure that is created or NULL if it fails;</para>
        /// <para>call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreatePixelFormat</para>
        /// <para>SDL_ConvertSurfaceFormat</para>
        /// <para>SDL_CreateSurface</para>
        /// </remarks>
        public static global::SDL3Sharp.Surface ConvertSurface(global::SDL3Sharp.Surface surface, global::SDL3Sharp.PixelFormat format)
        {
            var __arg0 = surface is null ? __IntPtr.Zero : surface.__Instance;
            var __arg1 = format is null ? __IntPtr.Zero : format.__Instance;
            var ___ret = __Internal.ConvertSurface(__arg0, __arg1);
            var __result0 = global::SDL3Sharp.Surface.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Copy an existing surface to a new surface of the specified format.</summary>
        /// <param name="surface">the existing SDL_Surface structure to convert</param>
        /// <param name="pixel_format">the new pixel format</param>
        /// <remarks>
        /// <para>This function operates just like SDL_ConvertSurface(), but accepts an</para>
        /// <para>SDL_PixelFormatEnum value instead of an SDL_PixelFormat structure. As such,</para>
        /// <para>it might be easier to call but it doesn't have access to palette</para>
        /// <para>information for the destination surface, in case that would be important.</para>
        /// <para>the new SDL_Surface structure that is created or NULL if it fails;</para>
        /// <para>call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreatePixelFormat</para>
        /// <para>SDL_ConvertSurface</para>
        /// <para>SDL_CreateSurface</para>
        /// </remarks>
        public static global::SDL3Sharp.Surface ConvertSurfaceFormat(global::SDL3Sharp.Surface surface, global::SDL3Sharp.PixelFormatEnum pixel_format)
        {
            var __arg0 = surface is null ? __IntPtr.Zero : surface.__Instance;
            var ___ret = __Internal.ConvertSurfaceFormat(__arg0, pixel_format);
            var __result0 = global::SDL3Sharp.Surface.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Copy an existing surface to a new surface of the specified format and</para>
        /// <para>colorspace.</para>
        /// </summary>
        /// <param name="surface">the existing SDL_Surface structure to convert</param>
        /// <param name="pixel_format">the new pixel format</param>
        /// <param name="colorspace">the new colorspace</param>
        /// <param name="props">an SDL_PropertiesID with additional color properties, or 0</param>
        /// <remarks>
        /// <para>This function converts an existing surface to a new format and colorspace</para>
        /// <para>and returns the new surface. This will perform any pixel format and</para>
        /// <para>colorspace conversion needed.</para>
        /// <para>the new SDL_Surface structure that is created or NULL if it fails;</para>
        /// <para>call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreatePixelFormat</para>
        /// <para>SDL_ConvertSurface</para>
        /// <para>SDL_CreateSurface</para>
        /// </remarks>
        public static global::SDL3Sharp.Surface ConvertSurfaceFormatAndColorspace(global::SDL3Sharp.Surface surface, global::SDL3Sharp.PixelFormatEnum pixel_format, global::SDL3Sharp.Colorspace colorspace, uint props)
        {
            var __arg0 = surface is null ? __IntPtr.Zero : surface.__Instance;
            var ___ret = __Internal.ConvertSurfaceFormatAndColorspace(__arg0, pixel_format, colorspace, props);
            var __result0 = global::SDL3Sharp.Surface.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Copy a block of pixels of one format to another format.</summary>
        /// <param name="width">the width of the block to copy, in pixels</param>
        /// <param name="height">the height of the block to copy, in pixels</param>
        /// <param name="src_format">an SDL_PixelFormatEnum value of the `src` pixels format</param>
        /// <param name="src">a pointer to the source pixels</param>
        /// <param name="src_pitch">the pitch of the source pixels, in bytes</param>
        /// <param name="dst_format">an SDL_PixelFormatEnum value of the `dst` pixels format</param>
        /// <param name="dst">a pointer to be filled in with new pixel data</param>
        /// <param name="dst_pitch">the pitch of the destination pixels, in bytes</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int ConvertPixels(int width, int height, global::SDL3Sharp.PixelFormatEnum src_format, __IntPtr src, int src_pitch, global::SDL3Sharp.PixelFormatEnum dst_format, __IntPtr dst, int dst_pitch)
        {
            var ___ret = __Internal.ConvertPixels(width, height, src_format, src, src_pitch, dst_format, dst, dst_pitch);
            return ___ret;
        }

        /// <summary>
        /// <para>Copy a block of pixels of one format and colorspace to another format and</para>
        /// <para>colorspace.</para>
        /// </summary>
        /// <param name="width">the width of the block to copy, in pixels</param>
        /// <param name="height">the height of the block to copy, in pixels</param>
        /// <param name="src_format">an SDL_PixelFormatEnum value of the `src` pixels format</param>
        /// <param name="src_colorspace">
        /// <para>an SDL_ColorSpace value describing the colorspace of</para>
        /// <para>the `src` pixels</para>
        /// </param>
        /// <param name="src_properties">
        /// <para>an SDL_PropertiesID with additional source color</para>
        /// <para>properties, or 0</para>
        /// </param>
        /// <param name="src">a pointer to the source pixels</param>
        /// <param name="src_pitch">the pitch of the source pixels, in bytes</param>
        /// <param name="dst_format">an SDL_PixelFormatEnum value of the `dst` pixels format</param>
        /// <param name="dst_colorspace">
        /// <para>an SDL_ColorSpace value describing the colorspace of</para>
        /// <para>the `dst` pixels</para>
        /// </param>
        /// <param name="dst_properties">
        /// <para>an SDL_PropertiesID with additional destination color</para>
        /// <para>properties, or 0</para>
        /// </param>
        /// <param name="dst">a pointer to be filled in with new pixel data</param>
        /// <param name="dst_pitch">the pitch of the destination pixels, in bytes</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int ConvertPixelsAndColorspace(int width, int height, global::SDL3Sharp.PixelFormatEnum src_format, global::SDL3Sharp.Colorspace src_colorspace, uint src_properties, __IntPtr src, int src_pitch, global::SDL3Sharp.PixelFormatEnum dst_format, global::SDL3Sharp.Colorspace dst_colorspace, uint dst_properties, __IntPtr dst, int dst_pitch)
        {
            var ___ret = __Internal.ConvertPixelsAndColorspace(width, height, src_format, src_colorspace, src_properties, src, src_pitch, dst_format, dst_colorspace, dst_properties, dst, dst_pitch);
            return ___ret;
        }

        /// <summary>Premultiply the alpha on a block of pixels.</summary>
        /// <param name="width">the width of the block to convert, in pixels</param>
        /// <param name="height">the height of the block to convert, in pixels</param>
        /// <param name="src_format">an SDL_PixelFormatEnum value of the `src` pixels format</param>
        /// <param name="src">a pointer to the source pixels</param>
        /// <param name="src_pitch">the pitch of the source pixels, in bytes</param>
        /// <param name="dst_format">an SDL_PixelFormatEnum value of the `dst` pixels format</param>
        /// <param name="dst">a pointer to be filled in with premultiplied pixel data</param>
        /// <param name="dst_pitch">the pitch of the destination pixels, in bytes</param>
        /// <remarks>
        /// <para>This is safe to use with src == dst, but not for other overlapping areas.</para>
        /// <para>This function is currently only implemented for SDL_PIXELFORMAT_ARGB8888.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int PremultiplyAlpha(int width, int height, global::SDL3Sharp.PixelFormatEnum src_format, __IntPtr src, int src_pitch, global::SDL3Sharp.PixelFormatEnum dst_format, __IntPtr dst, int dst_pitch)
        {
            var ___ret = __Internal.PremultiplyAlpha(width, height, src_format, src, src_pitch, dst_format, dst, dst_pitch);
            return ___ret;
        }

        /// <summary>Perform a fast fill of a rectangle with a specific color.</summary>
        /// <param name="dst">the SDL_Surface structure that is the drawing target</param>
        /// <param name="rect">
        /// <para>the SDL_Rect structure representing the rectangle to fill, or</para>
        /// <para>NULL to fill the entire surface</para>
        /// </param>
        /// <param name="color">the color to fill with</param>
        /// <remarks>
        /// <para>`color` should be a pixel of the format used by the surface, and can be</para>
        /// <para>generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an</para>
        /// <para>alpha component then the destination is simply filled with that alpha</para>
        /// <para>information, no blending takes place.</para>
        /// <para>If there is a clip rectangle set on the destination (set via</para>
        /// <para>SDL_SetSurfaceClipRect()), then this function will fill based on the</para>
        /// <para>intersection of the clip rectangle and `rect`.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_FillSurfaceRects</para>
        /// </remarks>
        public static int FillSurfaceRect(global::SDL3Sharp.Surface dst, global::SDL3Sharp.Rect rect, uint color)
        {
            var __arg0 = dst is null ? __IntPtr.Zero : dst.__Instance;
            var __arg1 = rect is null ? __IntPtr.Zero : rect.__Instance;
            var ___ret = __Internal.FillSurfaceRect(__arg0, __arg1, color);
            return ___ret;
        }

        /// <summary>Perform a fast fill of a set of rectangles with a specific color.</summary>
        /// <param name="dst">the SDL_Surface structure that is the drawing target</param>
        /// <param name="rects">an array of SDL_Rects representing the rectangles to fill.</param>
        /// <param name="count">the number of rectangles in the array</param>
        /// <param name="color">the color to fill with</param>
        /// <remarks>
        /// <para>`color` should be a pixel of the format used by the surface, and can be</para>
        /// <para>generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an</para>
        /// <para>alpha component then the destination is simply filled with that alpha</para>
        /// <para>information, no blending takes place.</para>
        /// <para>If there is a clip rectangle set on the destination (set via</para>
        /// <para>SDL_SetSurfaceClipRect()), then this function will fill based on the</para>
        /// <para>intersection of the clip rectangle and `rect`.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_FillSurfaceRect</para>
        /// </remarks>
        public static int FillSurfaceRects(global::SDL3Sharp.Surface dst, global::SDL3Sharp.Rect rects, int count, uint color)
        {
            var __arg0 = dst is null ? __IntPtr.Zero : dst.__Instance;
            var __arg1 = rects is null ? __IntPtr.Zero : rects.__Instance;
            var ___ret = __Internal.FillSurfaceRects(__arg0, __arg1, count, color);
            return ___ret;
        }

        /// <summary>Performs a fast blit from the source surface to the destination surface.</summary>
        /// <param name="src">the SDL_Surface structure to be copied from</param>
        /// <param name="srcrect">
        /// <para>the SDL_Rect structure representing the rectangle to be</para>
        /// <para>copied, or NULL to copy the entire surface</para>
        /// </param>
        /// <param name="dst">the SDL_Surface structure that is the blit target</param>
        /// <param name="dstrect">
        /// <para>the SDL_Rect structure representing the x and y position in</para>
        /// <para>the destination surface. On input the width and height are</para>
        /// <para>ignored (taken from srcrect), and on output this is filled</para>
        /// <para>in with the actual rectangle used after clipping.</para>
        /// </param>
        /// <remarks>
        /// <para>This assumes that the source and destination rectangles are the same size.</para>
        /// <para>If either `srcrect` or `dstrect` are NULL, the entire surface (`src` or</para>
        /// <para>`dst`) is copied. The final blit rectangles are saved in `srcrect` and</para>
        /// <para>`dstrect` after all clipping is performed.</para>
        /// <para>The blit function should not be called on a locked surface.</para>
        /// <para>The blit semantics for surfaces with and without blending and colorkey are</para>
        /// <para>defined as follows:</para>
        /// <para>```c</para>
        /// <para>RGBA-&gt;RGB:</para>
        /// <para>Source surface blend mode set to SDL_BLENDMODE_BLEND:</para>
        /// <para>alpha-blend (using the source alpha-channel and per-surface alpha)</para>
        /// <para>SDL_SRCCOLORKEY ignored.</para>
        /// <para>Source surface blend mode set to SDL_BLENDMODE_NONE:</para>
        /// <para>copy RGB.</para>
        /// <para>if SDL_SRCCOLORKEY set, only copy the pixels matching the</para>
        /// <para>RGB values of the source color key, ignoring alpha in the</para>
        /// <para>comparison.</para>
        /// <para>RGB-&gt;RGBA:</para>
        /// <para>Source surface blend mode set to SDL_BLENDMODE_BLEND:</para>
        /// <para>alpha-blend (using the source per-surface alpha)</para>
        /// <para>Source surface blend mode set to SDL_BLENDMODE_NONE:</para>
        /// <para>copy RGB, set destination alpha to source per-surface alpha value.</para>
        /// <para>both:</para>
        /// <para>if SDL_SRCCOLORKEY set, only copy the pixels matching the</para>
        /// <para>source color key.</para>
        /// <para>RGBA-&gt;RGBA:</para>
        /// <para>Source surface blend mode set to SDL_BLENDMODE_BLEND:</para>
        /// <para>alpha-blend (using the source alpha-channel and per-surface alpha)</para>
        /// <para>SDL_SRCCOLORKEY ignored.</para>
        /// <para>Source surface blend mode set to SDL_BLENDMODE_NONE:</para>
        /// <para>copy all of RGBA to the destination.</para>
        /// <para>if SDL_SRCCOLORKEY set, only copy the pixels matching the</para>
        /// <para>RGB values of the source color key, ignoring alpha in the</para>
        /// <para>comparison.</para>
        /// <para>RGB-&gt;RGB:</para>
        /// <para>Source surface blend mode set to SDL_BLENDMODE_BLEND:</para>
        /// <para>alpha-blend (using the source per-surface alpha)</para>
        /// <para>Source surface blend mode set to SDL_BLENDMODE_NONE:</para>
        /// <para>copy RGB.</para>
        /// <para>both:</para>
        /// <para>if SDL_SRCCOLORKEY set, only copy the pixels matching the</para>
        /// <para>source color key.</para>
        /// <para>```</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_BlitSurfaceScaled</para>
        /// </remarks>
        public static int BlitSurface(global::SDL3Sharp.Surface src, global::SDL3Sharp.Rect srcrect, global::SDL3Sharp.Surface dst, global::SDL3Sharp.Rect dstrect)
        {
            var __arg0 = src is null ? __IntPtr.Zero : src.__Instance;
            var __arg1 = srcrect is null ? __IntPtr.Zero : srcrect.__Instance;
            var __arg2 = dst is null ? __IntPtr.Zero : dst.__Instance;
            var __arg3 = dstrect is null ? __IntPtr.Zero : dstrect.__Instance;
            var ___ret = __Internal.BlitSurface(__arg0, __arg1, __arg2, __arg3);
            return ___ret;
        }

        /// <summary>Perform low-level surface blitting only.</summary>
        /// <param name="src">the SDL_Surface structure to be copied from</param>
        /// <param name="srcrect">
        /// <para>the SDL_Rect structure representing the rectangle to be</para>
        /// <para>copied, or NULL to copy the entire surface</para>
        /// </param>
        /// <param name="dst">the SDL_Surface structure that is the blit target</param>
        /// <param name="dstrect">
        /// <para>the SDL_Rect structure representing the target rectangle in</para>
        /// <para>the destination surface</para>
        /// </param>
        /// <remarks>
        /// <para>This is a semi-private blit function and it performs low-level surface</para>
        /// <para>blitting, assuming the input rectangles have already been clipped.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_BlitSurface</para>
        /// </remarks>
        public static int BlitSurfaceUnchecked(global::SDL3Sharp.Surface src, global::SDL3Sharp.Rect srcrect, global::SDL3Sharp.Surface dst, global::SDL3Sharp.Rect dstrect)
        {
            var __arg0 = src is null ? __IntPtr.Zero : src.__Instance;
            var __arg1 = srcrect is null ? __IntPtr.Zero : srcrect.__Instance;
            var __arg2 = dst is null ? __IntPtr.Zero : dst.__Instance;
            var __arg3 = dstrect is null ? __IntPtr.Zero : dstrect.__Instance;
            var ___ret = __Internal.BlitSurfaceUnchecked(__arg0, __arg1, __arg2, __arg3);
            return ___ret;
        }

        /// <summary>Perform stretch blit between two surfaces of the same format.</summary>
        /// <param name="src">the SDL_Surface structure to be copied from</param>
        /// <param name="srcrect">
        /// <para>the SDL_Rect structure representing the rectangle to be</para>
        /// <para>copied</para>
        /// </param>
        /// <param name="dst">the SDL_Surface structure that is the blit target</param>
        /// <param name="dstrect">
        /// <para>the SDL_Rect structure representing the target rectangle in</para>
        /// <para>the destination surface</para>
        /// </param>
        /// <param name="scaleMode">scale algorithm to be used</param>
        /// <remarks>
        /// <para>Using SDL_SCALEMODE_NEAREST: fast, low quality. Using SDL_SCALEMODE_LINEAR:</para>
        /// <para>bilinear scaling, slower, better quality, only 32BPP.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_BlitSurfaceScaled</para>
        /// </remarks>
        public static int SoftStretch(global::SDL3Sharp.Surface src, global::SDL3Sharp.Rect srcrect, global::SDL3Sharp.Surface dst, global::SDL3Sharp.Rect dstrect, global::SDL3Sharp.ScaleMode scaleMode)
        {
            var __arg0 = src is null ? __IntPtr.Zero : src.__Instance;
            var __arg1 = srcrect is null ? __IntPtr.Zero : srcrect.__Instance;
            var __arg2 = dst is null ? __IntPtr.Zero : dst.__Instance;
            var __arg3 = dstrect is null ? __IntPtr.Zero : dstrect.__Instance;
            var ___ret = __Internal.SoftStretch(__arg0, __arg1, __arg2, __arg3, scaleMode);
            return ___ret;
        }

        /// <summary>Perform a scaled surface copy to a destination surface.</summary>
        /// <param name="src">the SDL_Surface structure to be copied from</param>
        /// <param name="srcrect">
        /// <para>the SDL_Rect structure representing the rectangle to be</para>
        /// <para>copied</para>
        /// </param>
        /// <param name="dst">the SDL_Surface structure that is the blit target</param>
        /// <param name="dstrect">
        /// <para>the SDL_Rect structure representing the target rectangle in</para>
        /// <para>the destination surface, filled with the actual rectangle</para>
        /// <para>used after clipping</para>
        /// </param>
        /// <param name="scaleMode">scale algorithm to be used</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_BlitSurface</para>
        /// </remarks>
        public static int BlitSurfaceScaled(global::SDL3Sharp.Surface src, global::SDL3Sharp.Rect srcrect, global::SDL3Sharp.Surface dst, global::SDL3Sharp.Rect dstrect, global::SDL3Sharp.ScaleMode scaleMode)
        {
            var __arg0 = src is null ? __IntPtr.Zero : src.__Instance;
            var __arg1 = srcrect is null ? __IntPtr.Zero : srcrect.__Instance;
            var __arg2 = dst is null ? __IntPtr.Zero : dst.__Instance;
            var __arg3 = dstrect is null ? __IntPtr.Zero : dstrect.__Instance;
            var ___ret = __Internal.BlitSurfaceScaled(__arg0, __arg1, __arg2, __arg3, scaleMode);
            return ___ret;
        }

        /// <summary>Perform low-level surface scaled blitting only.</summary>
        /// <param name="src">the SDL_Surface structure to be copied from</param>
        /// <param name="srcrect">
        /// <para>the SDL_Rect structure representing the rectangle to be</para>
        /// <para>copied</para>
        /// </param>
        /// <param name="dst">the SDL_Surface structure that is the blit target</param>
        /// <param name="dstrect">
        /// <para>the SDL_Rect structure representing the target rectangle in</para>
        /// <para>the destination surface</para>
        /// </param>
        /// <param name="scaleMode">scale algorithm to be used</param>
        /// <remarks>
        /// <para>This is a semi-private function and it performs low-level surface blitting,</para>
        /// <para>assuming the input rectangles have already been clipped.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_BlitSurfaceScaled</para>
        /// </remarks>
        public static int BlitSurfaceUncheckedScaled(global::SDL3Sharp.Surface src, global::SDL3Sharp.Rect srcrect, global::SDL3Sharp.Surface dst, global::SDL3Sharp.Rect dstrect, global::SDL3Sharp.ScaleMode scaleMode)
        {
            var __arg0 = src is null ? __IntPtr.Zero : src.__Instance;
            var __arg1 = srcrect is null ? __IntPtr.Zero : srcrect.__Instance;
            var __arg2 = dst is null ? __IntPtr.Zero : dst.__Instance;
            var __arg3 = dstrect is null ? __IntPtr.Zero : dstrect.__Instance;
            var ___ret = __Internal.BlitSurfaceUncheckedScaled(__arg0, __arg1, __arg2, __arg3, scaleMode);
            return ___ret;
        }

        /// <summary>Retrieves a single pixel from a surface.</summary>
        /// <param name="surface">the surface to read</param>
        /// <param name="x">the horizontal coordinate, 0&lt;= x&lt;width</param>
        /// <param name="y">the vertical coordinate, 0&lt;= y&lt;height</param>
        /// <param name="r">
        /// <para>a pointer filled in with the red channel, 0-255, or NULL to ignore</para>
        /// <para>this channel</para>
        /// </param>
        /// <param name="g">
        /// <para>a pointer filled in with the green channel, 0-255, or NULL to</para>
        /// <para>ignore this channel</para>
        /// </param>
        /// <param name="b">
        /// <para>a pointer filled in with the blue channel, 0-255, or NULL to</para>
        /// <para>ignore this channel</para>
        /// </param>
        /// <param name="a">
        /// <para>a pointer filled in with the alpha channel, 0-255, or NULL to</para>
        /// <para>ignore this channel</para>
        /// </param>
        /// <remarks>
        /// <para>This function prioritizes correctness over speed: it is suitable for unit</para>
        /// <para>tests, but is not intended for use in a game engine.</para>
        /// <para>Like SDL_GetRGBA, this uses the entire 0..255 range when converting color</para>
        /// <para>components from pixel formats with less than 8 bits per RGB component.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int ReadSurfacePixel(global::SDL3Sharp.Surface surface, int x, int y, byte* r, byte* g, byte* b, byte* a)
        {
            var __arg0 = surface is null ? __IntPtr.Zero : surface.__Instance;
            var ___ret = __Internal.ReadSurfacePixel(__arg0, x, y, r, g, b, a);
            return ___ret;
        }
    }
}
