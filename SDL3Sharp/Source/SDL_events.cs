// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required
#pragma warning disable CS9084 // Struct member returns 'this' or other instance members by reference

namespace SDL3Sharp
{
    /// <summary>The types of events that can be delivered.</summary>
    public enum EventType
    {
        /// <summary>Unused (do not remove)</summary>
        First = 0,
        /// <summary>User-requested quit</summary>
        Quit = 256,
        /// <summary>
        /// <para>The application is being terminated by the OS</para>
        /// <para>Called on iOS in applicationWillTerminate()</para>
        /// <para>Called on Android in onDestroy()</para>
        /// </summary>
        Terminating = 257,
        /// <summary>
        /// <para>The application is low on memory, free memory if possible.</para>
        /// <para>Called on iOS in applicationDidReceiveMemoryWarning()</para>
        /// <para>Called on Android in onLowMemory()</para>
        /// </summary>
        LowMemory = 258,
        /// <summary>
        /// <para>The application is about to enter the background</para>
        /// <para>Called on iOS in applicationWillResignActive()</para>
        /// <para>Called on Android in onPause()</para>
        /// </summary>
        WillEnterBackground = 259,
        /// <summary>
        /// <para>The application did enter the background and may not get CPU for some time</para>
        /// <para>Called on iOS in applicationDidEnterBackground()</para>
        /// <para>Called on Android in onPause()</para>
        /// </summary>
        DidEnterBackground = 260,
        /// <summary>
        /// <para>The application is about to enter the foreground</para>
        /// <para>Called on iOS in applicationWillEnterForeground()</para>
        /// <para>Called on Android in onResume()</para>
        /// </summary>
        WillEnterForeground = 261,
        /// <summary>
        /// <para>The application is now interactive</para>
        /// <para>Called on iOS in applicationDidBecomeActive()</para>
        /// <para>Called on Android in onResume()</para>
        /// </summary>
        DidEnterForeground = 262,
        /// <summary>The user's locale preferences have changed.</summary>
        LocaleChanged = 263,
        /// <summary>The system theme changed</summary>
        SystemThemeChanged = 264,
        /// <summary>Display orientation has changed to data1</summary>
        DisplayOrientation = 337,
        /// <summary>Display has been added to the system</summary>
        DisplayAdded = 338,
        /// <summary>Display has been removed from the system</summary>
        DisplayRemoved = 339,
        /// <summary>Display has changed position</summary>
        DisplayMoved = 340,
        /// <summary>Display has changed content scale</summary>
        DisplayContentScaleChanged = 341,
        /// <summary>Display HDR properties have changed</summary>
        DisplayHdrStateChanged = 342,
        DisplayFirst = 337,
        DisplayLast = 342,
        /// <summary>Window has been shown</summary>
        WindowShown = 514,
        /// <summary>Window has been hidden</summary>
        WindowHidden = 515,
        /// <summary>Window has been exposed and should be redrawn</summary>
        WindowExposed = 516,
        /// <summary>Window has been moved to data1, data2</summary>
        WindowMoved = 517,
        /// <summary>Window has been resized to data1xdata2</summary>
        WindowResized = 518,
        /// <summary>The pixel size of the window has changed to data1xdata2</summary>
        WindowPixelSizeChanged = 519,
        /// <summary>Window has been minimized</summary>
        WindowMinimized = 520,
        /// <summary>Window has been maximized</summary>
        WindowMaximized = 521,
        /// <summary>Window has been restored to normal size and position</summary>
        WindowRestored = 522,
        /// <summary>Window has gained mouse focus</summary>
        WindowMouseEnter = 523,
        /// <summary>Window has lost mouse focus</summary>
        WindowMouseLeave = 524,
        /// <summary>Window has gained keyboard focus</summary>
        WindowFocusGained = 525,
        /// <summary>Window has lost keyboard focus</summary>
        WindowFocusLost = 526,
        /// <summary>The window manager requests that the window be closed</summary>
        WindowCloseRequested = 527,
        /// <summary>Window is being offered a focus (should SetWindowInputFocus() on itself or a subwindow, or ignore)</summary>
        WindowTakeFocus = 528,
        /// <summary>Window had a hit test that wasn't SDL_HITTEST_NORMAL</summary>
        WindowHitTest = 529,
        /// <summary>The ICC profile of the window's display has changed</summary>
        WindowIccprofChanged = 530,
        /// <summary>Window has been moved to display data1</summary>
        WindowDisplayChanged = 531,
        /// <summary>Window display scale has been changed</summary>
        WindowDisplayScaleChanged = 532,
        /// <summary>The window has been occluded</summary>
        WindowOccluded = 533,
        /// <summary>The window has entered fullscreen mode</summary>
        WindowEnterFullscreen = 534,
        /// <summary>The window has left fullscreen mode</summary>
        WindowLeaveFullscreen = 535,
        /// <summary>
        /// <para>The window with the associated ID is being or has been destroyed. If this message is being handled</para>
        /// <para>in an event watcher, the window handle is still valid and can still be used to retrieve any userdata</para>
        /// <para>associated with the window. Otherwise, the handle has already been destroyed and all resources</para>
        /// <para>associated with it are invalid</para>
        /// </summary>
        WindowDestroyed = 536,
        /// <summary>Window has gained focus of the pressure-sensitive pen with ID &quot;data1&quot;</summary>
        WindowPenEnter = 537,
        /// <summary>Window has lost focus of the pressure-sensitive pen with ID &quot;data1&quot;</summary>
        WindowPenLeave = 538,
        WindowFirst = 514,
        WindowLast = 538,
        /// <summary>Key pressed</summary>
        KeyDown = 768,
        /// <summary>Key released</summary>
        KeyUp = 769,
        /// <summary>Keyboard text editing (composition)</summary>
        TextEditing = 770,
        /// <summary>Keyboard text input</summary>
        TextInput = 771,
        /// <summary>
        /// <para>Keymap changed due to a system event such as an</para>
        /// <para>input language or keyboard layout change.</para>
        /// </summary>
        KeymapChanged = 772,
        /// <summary>Mouse moved</summary>
        MouseMotion = 1024,
        /// <summary>Mouse button pressed</summary>
        MouseButtonDown = 1025,
        /// <summary>Mouse button released</summary>
        MouseButtonUp = 1026,
        /// <summary>Mouse wheel motion</summary>
        MouseWheel = 1027,
        /// <summary>Joystick axis motion</summary>
        JoystickAxisMotion = 1536,
        /// <summary>Joystick trackball motion</summary>
        JoystickBallMotion = 1537,
        /// <summary>Joystick hat position change</summary>
        JoystickHatMotion = 1538,
        /// <summary>Joystick button pressed</summary>
        JoystickButtonDown = 1539,
        /// <summary>Joystick button released</summary>
        JoystickButtonUp = 1540,
        /// <summary>A new joystick has been inserted into the system</summary>
        JoystickAdded = 1541,
        /// <summary>An opened joystick has been removed</summary>
        JoystickRemoved = 1542,
        /// <summary>Joystick battery level change</summary>
        JoystickBatteryUpdated = 1543,
        /// <summary>Joystick update is complete</summary>
        JoystickUpdateComplete = 1544,
        /// <summary>Gamepad axis motion</summary>
        GamepadAxisMotion = 1616,
        /// <summary>Gamepad button pressed</summary>
        GamepadButtonDown = 1617,
        /// <summary>Gamepad button released</summary>
        GamepadButtonUp = 1618,
        /// <summary>A new gamepad has been inserted into the system</summary>
        GamepadAdded = 1619,
        /// <summary>An opened gamepad has been removed</summary>
        GamepadRemoved = 1620,
        /// <summary>The gamepad mapping was updated</summary>
        GamepadRemapped = 1621,
        /// <summary>Gamepad touchpad was touched</summary>
        GamepadTouchpadDown = 1622,
        /// <summary>Gamepad touchpad finger was moved</summary>
        GamepadTouchpadMotion = 1623,
        /// <summary>Gamepad touchpad finger was lifted</summary>
        GamepadTouchpadUp = 1624,
        /// <summary>Gamepad sensor was updated</summary>
        GamepadSensorUpdate = 1625,
        /// <summary>Gamepad update is complete</summary>
        GamepadUpdateComplete = 1626,
        /// <summary>Gamepad Steam handle has changed</summary>
        GamepadSteamHandleUpdated = 1627,
        FingerDown = 1792,
        FingerUp = 1793,
        FingerMotion = 1794,
        /// <summary>The clipboard or primary selection changed</summary>
        ClipboardUpdate = 2304,
        /// <summary>The system requests a file open</summary>
        DropFile = 4096,
        /// <summary>text/plain drag-and-drop event</summary>
        DropText = 4097,
        /// <summary>A new set of drops is beginning (NULL filename)</summary>
        DropBegin = 4098,
        /// <summary>Current set of drops is now complete (NULL filename)</summary>
        DropComplete = 4099,
        /// <summary>Position while moving over the window</summary>
        DropPosition = 4100,
        /// <summary>A new audio device is available</summary>
        AudioDeviceAdded = 4352,
        /// <summary>An audio device has been removed.</summary>
        AudioDeviceRemoved = 4353,
        /// <summary>An audio device's format has been changed by the system.</summary>
        AudioDeviceFormatChanged = 4354,
        /// <summary>A sensor was updated</summary>
        SensorUpdate = 4608,
        /// <summary>Pressure-sensitive pen touched drawing surface</summary>
        PenDown = 4864,
        /// <summary>Pressure-sensitive pen stopped touching drawing surface</summary>
        PenUp = 4865,
        /// <summary>Pressure-sensitive pen moved, or angle/pressure changed</summary>
        PenMotion = 4866,
        /// <summary>Pressure-sensitive pen button pressed</summary>
        PenButtonDown = 4867,
        /// <summary>Pressure-sensitive pen button released</summary>
        PenButtonUp = 4868,
        /// <summary>A new camera device is available</summary>
        CameraDeviceAdded = 5120,
        /// <summary>A camera device has been removed.</summary>
        CameraDeviceRemoved = 5121,
        /// <summary>A camera device has been approved for use by the user.</summary>
        CameraDeviceApproved = 5122,
        /// <summary>A camera device has been denied for use by the user.</summary>
        CameraDeviceDenied = 5123,
        /// <summary>The render targets have been reset and their contents need to be updated</summary>
        RenderTargetsReset = 8192,
        /// <summary>The device has been reset and all textures need to be recreated</summary>
        RenderDeviceReset = 8193,
        /// <summary>Signals the end of an event poll cycle</summary>
        PollSentinel = 32512,
        /// <summary>
        /// <para>Events ::SDL_EVENT_USER through ::SDL_EVENT_LAST are for your use,</para>
        /// <para>and should be allocated with SDL_RegisterEvents()</para>
        /// </summary>
        User = 32768,
        /// <summary>This last event is only for bounding internal arrays</summary>
        Last = 65535,
        /// <summary>This last event is only for bounding internal arrays</summary>
        EnumPadding = 2147483647
    }

    public enum Eventaction
    {
        Addevent = 0,
        Peekevent = 1,
        Getevent = 2
    }

    /// <summary>The types of events that can be delivered.</summary>
    /// <summary>Fields shared by every event</summary>
    /// <summary>Display state change event data (event.display.*)</summary>
    /// <summary>Window state change event data (event.window.*)</summary>
    /// <summary>Keyboard button event structure (event.key.*)</summary>
    /// <summary>Keyboard text editing event structure (event.edit.*)</summary>
    /// <remarks>
    /// <para>The `text` is owned by SDL and should be copied if the application</para>
    /// <para>wants to hold onto it beyond the scope of handling this event.</para>
    /// </remarks>
    /// <summary>Keyboard text input event structure (event.text.*)</summary>
    /// <remarks>
    /// <para>The `text` is owned by SDL and should be copied if the application</para>
    /// <para>wants to hold onto it beyond the scope of handling this event.</para>
    /// </remarks>
    /// <summary>Mouse motion event structure (event.motion.*)</summary>
    /// <summary>Joystick trackball motion event structure (event.jball.*)</summary>
    /// <summary>Mouse button event structure (event.button.*)</summary>
    /// <summary>Mouse wheel event structure (event.wheel.*)</summary>
    /// <summary>Joystick axis motion event structure (event.jaxis.*)</summary>
    /// <summary>Joystick hat position change event structure (event.jhat.*)</summary>
    /// <summary>Joystick button event structure (event.jbutton.*)</summary>
    /// <summary>Joystick device event structure (event.jdevice.*)</summary>
    /// <summary>Joysick battery level change event structure (event.jbattery.*)</summary>
    /// <summary>Gamepad axis motion event structure (event.gaxis.*)</summary>
    /// <summary>Gamepad button event structure (event.gbutton.*)</summary>
    /// <summary>Gamepad device event structure (event.gdevice.*)</summary>
    /// <summary>Gamepad touchpad event structure (event.gtouchpad.*)</summary>
    /// <summary>Gamepad sensor event structure (event.gsensor.*)</summary>
    /// <summary>Audio device event structure (event.adevice.*)</summary>
    /// <summary>Camera device event structure (event.cdevice.*)</summary>
    /// <summary>Touch finger event structure (event.tfinger.*)</summary>
    /// <summary>Pressure-sensitive pen touched or stopped touching surface (event.ptip.*)</summary>
    /// <summary>Pressure-sensitive pen motion / pressure / angle event structure (event.pmotion.*)</summary>
    /// <summary>Pressure-sensitive pen button event structure (event.pbutton.*)</summary>
    /// <summary>An event used to drop text or request a file open by the system (event.drop.*)</summary>
    /// <remarks>
    /// <para>The `data` is owned by SDL and should be copied if the application</para>
    /// <para>wants to hold onto it beyond the scope of handling this event.</para>
    /// </remarks>
    /// <summary>An event triggered when the clipboard contents have changed (event.clipboard.*)</summary>
    /// <summary>Sensor event structure (event.sensor.*)</summary>
    /// <summary>The &quot;quit requested&quot; event</summary>
    /// <summary>A user-defined event type (event.user.*)</summary>
    /// <summary>General event structure</summary>
    /// <summary>A function pointer used for callbacks that watch the event queue.</summary>
    /// <param name="userdata">
    /// <para>what was passed as `userdata` to SDL_SetEventFilter()</para>
    /// <para>or SDL_AddEventWatch, etc</para>
    /// </param>
    /// <param name="event">the event that triggered the callback</param>
    /// <remarks>
    /// <para>1 to permit event to be added to the queue, and 0 to disallow</para>
    /// <para>it. When used with SDL_AddEventWatch, the return value is ignored.</para>
    /// <para>SDL_SetEventFilter</para>
    /// <para>SDL_AddEventWatch</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate int EventFilter(__IntPtr userdata, __IntPtr @event);

    /// <summary>Fields shared by every event</summary>
    public unsafe partial class CommonEvent : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public partial struct __Internal
        {
            internal uint type;
            internal uint reserved;
            internal ulong timestamp;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_CommonEvent@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.CommonEvent> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.CommonEvent>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.CommonEvent managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.CommonEvent managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CommonEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CommonEvent(native.ToPointer(), skipVTables);
        }

        internal static CommonEvent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CommonEvent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CommonEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CommonEvent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CommonEvent(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CommonEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public CommonEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.CommonEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public CommonEvent(global::SDL3Sharp.CommonEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.CommonEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.CommonEvent.__Internal*) __Instance) = *((global::SDL3Sharp.CommonEvent.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint Reserved
        {
            get
            {
                return ((__Internal*)__Instance)->reserved;
            }

            set
            {
                ((__Internal*)__Instance)->reserved = value;
            }
        }

        /// <summary>In nanoseconds, populated using SDL_GetTicksNS()</summary>
        public ulong Timestamp
        {
            get
            {
                return ((__Internal*)__Instance)->timestamp;
            }

            set
            {
                ((__Internal*)__Instance)->timestamp = value;
            }
        }
    }

    /// <summary>Display state change event data (event.display.*)</summary>
    public unsafe partial class DisplayEvent : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public partial struct __Internal
        {
            internal global::SDL3Sharp.EventType type;
            internal uint reserved;
            internal ulong timestamp;
            internal uint displayID;
            internal int data1;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_DisplayEvent@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.DisplayEvent> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.DisplayEvent>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.DisplayEvent managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.DisplayEvent managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static DisplayEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new DisplayEvent(native.ToPointer(), skipVTables);
        }

        internal static DisplayEvent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (DisplayEvent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static DisplayEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DisplayEvent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DisplayEvent(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected DisplayEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public DisplayEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.DisplayEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public DisplayEvent(global::SDL3Sharp.DisplayEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.DisplayEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.DisplayEvent.__Internal*) __Instance) = *((global::SDL3Sharp.DisplayEvent.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>::SDL_DISPLAYEVENT_*</summary>
        public global::SDL3Sharp.EventType Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint Reserved
        {
            get
            {
                return ((__Internal*)__Instance)->reserved;
            }

            set
            {
                ((__Internal*)__Instance)->reserved = value;
            }
        }

        /// <summary>In nanoseconds, populated using SDL_GetTicksNS()</summary>
        public ulong Timestamp
        {
            get
            {
                return ((__Internal*)__Instance)->timestamp;
            }

            set
            {
                ((__Internal*)__Instance)->timestamp = value;
            }
        }

        /// <summary>The associated display</summary>
        public uint DisplayID
        {
            get
            {
                return ((__Internal*)__Instance)->displayID;
            }

            set
            {
                ((__Internal*)__Instance)->displayID = value;
            }
        }

        /// <summary>event dependent data</summary>
        public int Data1
        {
            get
            {
                return ((__Internal*)__Instance)->data1;
            }

            set
            {
                ((__Internal*)__Instance)->data1 = value;
            }
        }
    }

    /// <summary>Window state change event data (event.window.*)</summary>
    public unsafe partial class WindowEvent : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32, Pack = 8)]
        public partial struct __Internal
        {
            internal global::SDL3Sharp.EventType type;
            internal uint reserved;
            internal ulong timestamp;
            internal uint windowID;
            internal int data1;
            internal int data2;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_WindowEvent@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.WindowEvent> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.WindowEvent>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.WindowEvent managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.WindowEvent managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static WindowEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new WindowEvent(native.ToPointer(), skipVTables);
        }

        internal static WindowEvent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (WindowEvent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static WindowEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new WindowEvent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private WindowEvent(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected WindowEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public WindowEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.WindowEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public WindowEvent(global::SDL3Sharp.WindowEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.WindowEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.WindowEvent.__Internal*) __Instance) = *((global::SDL3Sharp.WindowEvent.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>::SDL_WINDOWEVENT_*</summary>
        public global::SDL3Sharp.EventType Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint Reserved
        {
            get
            {
                return ((__Internal*)__Instance)->reserved;
            }

            set
            {
                ((__Internal*)__Instance)->reserved = value;
            }
        }

        /// <summary>In nanoseconds, populated using SDL_GetTicksNS()</summary>
        public ulong Timestamp
        {
            get
            {
                return ((__Internal*)__Instance)->timestamp;
            }

            set
            {
                ((__Internal*)__Instance)->timestamp = value;
            }
        }

        /// <summary>The associated window</summary>
        public uint WindowID
        {
            get
            {
                return ((__Internal*)__Instance)->windowID;
            }

            set
            {
                ((__Internal*)__Instance)->windowID = value;
            }
        }

        /// <summary>event dependent data</summary>
        public int Data1
        {
            get
            {
                return ((__Internal*)__Instance)->data1;
            }

            set
            {
                ((__Internal*)__Instance)->data1 = value;
            }
        }

        /// <summary>event dependent data</summary>
        public int Data2
        {
            get
            {
                return ((__Internal*)__Instance)->data2;
            }

            set
            {
                ((__Internal*)__Instance)->data2 = value;
            }
        }
    }

    /// <summary>Keyboard button event structure (event.key.*)</summary>
    public unsafe partial class KeyboardEvent : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 40, Pack = 8)]
        public partial struct __Internal
        {
            internal global::SDL3Sharp.EventType type;
            internal uint reserved;
            internal ulong timestamp;
            internal uint windowID;
            internal byte state;
            internal byte repeat;
            internal byte padding2;
            internal byte padding3;
            internal global::SDL3Sharp.Keysym.__Internal keysym;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_KeyboardEvent@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.KeyboardEvent> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.KeyboardEvent>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.KeyboardEvent managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.KeyboardEvent managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static KeyboardEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new KeyboardEvent(native.ToPointer(), skipVTables);
        }

        internal static KeyboardEvent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (KeyboardEvent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static KeyboardEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new KeyboardEvent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private KeyboardEvent(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected KeyboardEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public KeyboardEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.KeyboardEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public KeyboardEvent(global::SDL3Sharp.KeyboardEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.KeyboardEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.KeyboardEvent.__Internal*) __Instance) = *((global::SDL3Sharp.KeyboardEvent.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>::SDL_EVENT_KEY_DOWN or ::SDL_EVENT_KEY_UP</summary>
        public global::SDL3Sharp.EventType Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint Reserved
        {
            get
            {
                return ((__Internal*)__Instance)->reserved;
            }

            set
            {
                ((__Internal*)__Instance)->reserved = value;
            }
        }

        /// <summary>In nanoseconds, populated using SDL_GetTicksNS()</summary>
        public ulong Timestamp
        {
            get
            {
                return ((__Internal*)__Instance)->timestamp;
            }

            set
            {
                ((__Internal*)__Instance)->timestamp = value;
            }
        }

        /// <summary>The window with keyboard focus, if any</summary>
        public uint WindowID
        {
            get
            {
                return ((__Internal*)__Instance)->windowID;
            }

            set
            {
                ((__Internal*)__Instance)->windowID = value;
            }
        }

        /// <summary>::SDL_PRESSED or ::SDL_RELEASED</summary>
        public byte State
        {
            get
            {
                return ((__Internal*)__Instance)->state;
            }

            set
            {
                ((__Internal*)__Instance)->state = value;
            }
        }

        /// <summary>Non-zero if this is a key repeat</summary>
        public byte Repeat
        {
            get
            {
                return ((__Internal*)__Instance)->repeat;
            }

            set
            {
                ((__Internal*)__Instance)->repeat = value;
            }
        }

        public byte Padding2
        {
            get
            {
                return ((__Internal*)__Instance)->padding2;
            }

            set
            {
                ((__Internal*)__Instance)->padding2 = value;
            }
        }

        public byte Padding3
        {
            get
            {
                return ((__Internal*)__Instance)->padding3;
            }

            set
            {
                ((__Internal*)__Instance)->padding3 = value;
            }
        }

        /// <summary>The key that was pressed or released</summary>
        public global::SDL3Sharp.Keysym Keysym
        {
            get
            {
                return global::SDL3Sharp.Keysym.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->keysym));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->keysym = *(global::SDL3Sharp.Keysym.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>Keyboard text editing event structure (event.edit.*)</summary>
    /// <remarks>
    /// <para>The `text` is owned by SDL and should be copied if the application</para>
    /// <para>wants to hold onto it beyond the scope of handling this event.</para>
    /// </remarks>
    public unsafe partial class TextEditingEvent : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 40, Pack = 8)]
        public partial struct __Internal
        {
            internal global::SDL3Sharp.EventType type;
            internal uint reserved;
            internal ulong timestamp;
            internal uint windowID;
            internal __IntPtr text;
            internal int start;
            internal int length;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_TextEditingEvent@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.TextEditingEvent> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.TextEditingEvent>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.TextEditingEvent managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.TextEditingEvent managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static TextEditingEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new TextEditingEvent(native.ToPointer(), skipVTables);
        }

        internal static TextEditingEvent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (TextEditingEvent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static TextEditingEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new TextEditingEvent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TextEditingEvent(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected TextEditingEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public TextEditingEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.TextEditingEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public TextEditingEvent(global::SDL3Sharp.TextEditingEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.TextEditingEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.TextEditingEvent.__Internal*) __Instance) = *((global::SDL3Sharp.TextEditingEvent.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>::SDL_EVENT_TEXT_EDITING</summary>
        public global::SDL3Sharp.EventType Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint Reserved
        {
            get
            {
                return ((__Internal*)__Instance)->reserved;
            }

            set
            {
                ((__Internal*)__Instance)->reserved = value;
            }
        }

        /// <summary>In nanoseconds, populated using SDL_GetTicksNS()</summary>
        public ulong Timestamp
        {
            get
            {
                return ((__Internal*)__Instance)->timestamp;
            }

            set
            {
                ((__Internal*)__Instance)->timestamp = value;
            }
        }

        /// <summary>The window with keyboard focus, if any</summary>
        public uint WindowID
        {
            get
            {
                return ((__Internal*)__Instance)->windowID;
            }

            set
            {
                ((__Internal*)__Instance)->windowID = value;
            }
        }

        /// <summary>The editing text</summary>
        public sbyte* Text
        {
            get
            {
                return (sbyte*) ((__Internal*)__Instance)->text;
            }

            set
            {
                ((__Internal*)__Instance)->text = (__IntPtr) value;
            }
        }

        /// <summary>The start cursor of selected editing text</summary>
        public int Start
        {
            get
            {
                return ((__Internal*)__Instance)->start;
            }

            set
            {
                ((__Internal*)__Instance)->start = value;
            }
        }

        /// <summary>The length of selected editing text</summary>
        public int Length
        {
            get
            {
                return ((__Internal*)__Instance)->length;
            }

            set
            {
                ((__Internal*)__Instance)->length = value;
            }
        }
    }

    /// <summary>Keyboard text input event structure (event.text.*)</summary>
    /// <remarks>
    /// <para>The `text` is owned by SDL and should be copied if the application</para>
    /// <para>wants to hold onto it beyond the scope of handling this event.</para>
    /// </remarks>
    public unsafe partial class TextInputEvent : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32, Pack = 8)]
        public partial struct __Internal
        {
            internal global::SDL3Sharp.EventType type;
            internal uint reserved;
            internal ulong timestamp;
            internal uint windowID;
            internal __IntPtr text;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_TextInputEvent@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.TextInputEvent> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.TextInputEvent>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.TextInputEvent managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.TextInputEvent managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static TextInputEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new TextInputEvent(native.ToPointer(), skipVTables);
        }

        internal static TextInputEvent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (TextInputEvent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static TextInputEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new TextInputEvent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TextInputEvent(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected TextInputEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public TextInputEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.TextInputEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public TextInputEvent(global::SDL3Sharp.TextInputEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.TextInputEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.TextInputEvent.__Internal*) __Instance) = *((global::SDL3Sharp.TextInputEvent.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>::SDL_EVENT_TEXT_INPUT</summary>
        public global::SDL3Sharp.EventType Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint Reserved
        {
            get
            {
                return ((__Internal*)__Instance)->reserved;
            }

            set
            {
                ((__Internal*)__Instance)->reserved = value;
            }
        }

        /// <summary>In nanoseconds, populated using SDL_GetTicksNS()</summary>
        public ulong Timestamp
        {
            get
            {
                return ((__Internal*)__Instance)->timestamp;
            }

            set
            {
                ((__Internal*)__Instance)->timestamp = value;
            }
        }

        /// <summary>The window with keyboard focus, if any</summary>
        public uint WindowID
        {
            get
            {
                return ((__Internal*)__Instance)->windowID;
            }

            set
            {
                ((__Internal*)__Instance)->windowID = value;
            }
        }

        /// <summary>The input text</summary>
        public sbyte* Text
        {
            get
            {
                return (sbyte*) ((__Internal*)__Instance)->text;
            }

            set
            {
                ((__Internal*)__Instance)->text = (__IntPtr) value;
            }
        }
    }

    /// <summary>Mouse motion event structure (event.motion.*)</summary>
    public unsafe partial class MouseMotionEvent : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 48, Pack = 8)]
        public partial struct __Internal
        {
            internal global::SDL3Sharp.EventType type;
            internal uint reserved;
            internal ulong timestamp;
            internal uint windowID;
            internal uint which;
            internal uint state;
            internal float x;
            internal float y;
            internal float xrel;
            internal float yrel;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_MouseMotionEvent@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.MouseMotionEvent> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.MouseMotionEvent>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.MouseMotionEvent managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.MouseMotionEvent managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static MouseMotionEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new MouseMotionEvent(native.ToPointer(), skipVTables);
        }

        internal static MouseMotionEvent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (MouseMotionEvent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static MouseMotionEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new MouseMotionEvent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MouseMotionEvent(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected MouseMotionEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public MouseMotionEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.MouseMotionEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public MouseMotionEvent(global::SDL3Sharp.MouseMotionEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.MouseMotionEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.MouseMotionEvent.__Internal*) __Instance) = *((global::SDL3Sharp.MouseMotionEvent.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>::SDL_EVENT_MOUSE_MOTION</summary>
        public global::SDL3Sharp.EventType Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint Reserved
        {
            get
            {
                return ((__Internal*)__Instance)->reserved;
            }

            set
            {
                ((__Internal*)__Instance)->reserved = value;
            }
        }

        /// <summary>In nanoseconds, populated using SDL_GetTicksNS()</summary>
        public ulong Timestamp
        {
            get
            {
                return ((__Internal*)__Instance)->timestamp;
            }

            set
            {
                ((__Internal*)__Instance)->timestamp = value;
            }
        }

        /// <summary>The window with mouse focus, if any</summary>
        public uint WindowID
        {
            get
            {
                return ((__Internal*)__Instance)->windowID;
            }

            set
            {
                ((__Internal*)__Instance)->windowID = value;
            }
        }

        /// <summary>The mouse instance id, SDL_TOUCH_MOUSEID, or SDL_PEN_MOUSEID</summary>
        public uint Which
        {
            get
            {
                return ((__Internal*)__Instance)->which;
            }

            set
            {
                ((__Internal*)__Instance)->which = value;
            }
        }

        /// <summary>The current button state</summary>
        public uint State
        {
            get
            {
                return ((__Internal*)__Instance)->state;
            }

            set
            {
                ((__Internal*)__Instance)->state = value;
            }
        }

        /// <summary>X coordinate, relative to window</summary>
        public float X
        {
            get
            {
                return ((__Internal*)__Instance)->x;
            }

            set
            {
                ((__Internal*)__Instance)->x = value;
            }
        }

        /// <summary>Y coordinate, relative to window</summary>
        public float Y
        {
            get
            {
                return ((__Internal*)__Instance)->y;
            }

            set
            {
                ((__Internal*)__Instance)->y = value;
            }
        }

        /// <summary>The relative motion in the X direction</summary>
        public float Xrel
        {
            get
            {
                return ((__Internal*)__Instance)->xrel;
            }

            set
            {
                ((__Internal*)__Instance)->xrel = value;
            }
        }

        /// <summary>The relative motion in the Y direction</summary>
        public float Yrel
        {
            get
            {
                return ((__Internal*)__Instance)->yrel;
            }

            set
            {
                ((__Internal*)__Instance)->yrel = value;
            }
        }
    }

    /// <summary>Joystick trackball motion event structure (event.jball.*)</summary>
    public unsafe partial class JoyBallEvent : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32, Pack = 8)]
        public partial struct __Internal
        {
            internal uint type;
            internal ulong timestamp;
            internal uint which;
            internal byte ball;
            internal byte padding1;
            internal byte padding2;
            internal byte padding3;
            internal short xrel;
            internal short yrel;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_JoyBallEvent@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.JoyBallEvent> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.JoyBallEvent>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.JoyBallEvent managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.JoyBallEvent managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static JoyBallEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new JoyBallEvent(native.ToPointer(), skipVTables);
        }

        internal static JoyBallEvent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (JoyBallEvent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static JoyBallEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new JoyBallEvent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private JoyBallEvent(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected JoyBallEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public JoyBallEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.JoyBallEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public JoyBallEvent(global::SDL3Sharp.JoyBallEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.JoyBallEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.JoyBallEvent.__Internal*) __Instance) = *((global::SDL3Sharp.JoyBallEvent.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>::SDL_JOYBALLMOTION</summary>
        public uint Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        /// <summary>In nanoseconds, populated using SDL_GetTicksNS()</summary>
        public ulong Timestamp
        {
            get
            {
                return ((__Internal*)__Instance)->timestamp;
            }

            set
            {
                ((__Internal*)__Instance)->timestamp = value;
            }
        }

        /// <summary>The joystick instance id</summary>
        public uint Which
        {
            get
            {
                return ((__Internal*)__Instance)->which;
            }

            set
            {
                ((__Internal*)__Instance)->which = value;
            }
        }

        /// <summary>The joystick trackball index</summary>
        public byte Ball
        {
            get
            {
                return ((__Internal*)__Instance)->ball;
            }

            set
            {
                ((__Internal*)__Instance)->ball = value;
            }
        }

        public byte Padding1
        {
            get
            {
                return ((__Internal*)__Instance)->padding1;
            }

            set
            {
                ((__Internal*)__Instance)->padding1 = value;
            }
        }

        public byte Padding2
        {
            get
            {
                return ((__Internal*)__Instance)->padding2;
            }

            set
            {
                ((__Internal*)__Instance)->padding2 = value;
            }
        }

        public byte Padding3
        {
            get
            {
                return ((__Internal*)__Instance)->padding3;
            }

            set
            {
                ((__Internal*)__Instance)->padding3 = value;
            }
        }

        /// <summary>The relative motion in the X direction</summary>
        public short Xrel
        {
            get
            {
                return ((__Internal*)__Instance)->xrel;
            }

            set
            {
                ((__Internal*)__Instance)->xrel = value;
            }
        }

        /// <summary>The relative motion in the Y direction</summary>
        public short Yrel
        {
            get
            {
                return ((__Internal*)__Instance)->yrel;
            }

            set
            {
                ((__Internal*)__Instance)->yrel = value;
            }
        }
    }

    /// <summary>Mouse button event structure (event.button.*)</summary>
    public unsafe partial class MouseButtonEvent : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 40, Pack = 8)]
        public partial struct __Internal
        {
            internal global::SDL3Sharp.EventType type;
            internal uint reserved;
            internal ulong timestamp;
            internal uint windowID;
            internal uint which;
            internal byte button;
            internal byte state;
            internal byte clicks;
            internal byte padding;
            internal float x;
            internal float y;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_MouseButtonEvent@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.MouseButtonEvent> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.MouseButtonEvent>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.MouseButtonEvent managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.MouseButtonEvent managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static MouseButtonEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new MouseButtonEvent(native.ToPointer(), skipVTables);
        }

        internal static MouseButtonEvent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (MouseButtonEvent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static MouseButtonEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new MouseButtonEvent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MouseButtonEvent(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected MouseButtonEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public MouseButtonEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.MouseButtonEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public MouseButtonEvent(global::SDL3Sharp.MouseButtonEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.MouseButtonEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.MouseButtonEvent.__Internal*) __Instance) = *((global::SDL3Sharp.MouseButtonEvent.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>::SDL_EVENT_MOUSE_BUTTON_DOWN or ::SDL_EVENT_MOUSE_BUTTON_UP</summary>
        public global::SDL3Sharp.EventType Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint Reserved
        {
            get
            {
                return ((__Internal*)__Instance)->reserved;
            }

            set
            {
                ((__Internal*)__Instance)->reserved = value;
            }
        }

        /// <summary>In nanoseconds, populated using SDL_GetTicksNS()</summary>
        public ulong Timestamp
        {
            get
            {
                return ((__Internal*)__Instance)->timestamp;
            }

            set
            {
                ((__Internal*)__Instance)->timestamp = value;
            }
        }

        /// <summary>The window with mouse focus, if any</summary>
        public uint WindowID
        {
            get
            {
                return ((__Internal*)__Instance)->windowID;
            }

            set
            {
                ((__Internal*)__Instance)->windowID = value;
            }
        }

        /// <summary>The mouse instance id, SDL_TOUCH_MOUSEID, or SDL_PEN_MOUSEID</summary>
        public uint Which
        {
            get
            {
                return ((__Internal*)__Instance)->which;
            }

            set
            {
                ((__Internal*)__Instance)->which = value;
            }
        }

        /// <summary>The mouse button index</summary>
        public byte Button
        {
            get
            {
                return ((__Internal*)__Instance)->button;
            }

            set
            {
                ((__Internal*)__Instance)->button = value;
            }
        }

        /// <summary>::SDL_PRESSED or ::SDL_RELEASED</summary>
        public byte State
        {
            get
            {
                return ((__Internal*)__Instance)->state;
            }

            set
            {
                ((__Internal*)__Instance)->state = value;
            }
        }

        /// <summary>1 for single-click, 2 for double-click, etc.</summary>
        public byte Clicks
        {
            get
            {
                return ((__Internal*)__Instance)->clicks;
            }

            set
            {
                ((__Internal*)__Instance)->clicks = value;
            }
        }

        public byte Padding
        {
            get
            {
                return ((__Internal*)__Instance)->padding;
            }

            set
            {
                ((__Internal*)__Instance)->padding = value;
            }
        }

        /// <summary>X coordinate, relative to window</summary>
        public float X
        {
            get
            {
                return ((__Internal*)__Instance)->x;
            }

            set
            {
                ((__Internal*)__Instance)->x = value;
            }
        }

        /// <summary>Y coordinate, relative to window</summary>
        public float Y
        {
            get
            {
                return ((__Internal*)__Instance)->y;
            }

            set
            {
                ((__Internal*)__Instance)->y = value;
            }
        }
    }

    /// <summary>Mouse wheel event structure (event.wheel.*)</summary>
    public unsafe partial class MouseWheelEvent : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 48, Pack = 8)]
        public partial struct __Internal
        {
            internal global::SDL3Sharp.EventType type;
            internal uint reserved;
            internal ulong timestamp;
            internal uint windowID;
            internal uint which;
            internal float x;
            internal float y;
            internal global::SDL3Sharp.MouseWheelDirection direction;
            internal float mouse_x;
            internal float mouse_y;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_MouseWheelEvent@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.MouseWheelEvent> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.MouseWheelEvent>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.MouseWheelEvent managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.MouseWheelEvent managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static MouseWheelEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new MouseWheelEvent(native.ToPointer(), skipVTables);
        }

        internal static MouseWheelEvent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (MouseWheelEvent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static MouseWheelEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new MouseWheelEvent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MouseWheelEvent(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected MouseWheelEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public MouseWheelEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.MouseWheelEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public MouseWheelEvent(global::SDL3Sharp.MouseWheelEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.MouseWheelEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.MouseWheelEvent.__Internal*) __Instance) = *((global::SDL3Sharp.MouseWheelEvent.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>::SDL_EVENT_MOUSE_WHEEL</summary>
        public global::SDL3Sharp.EventType Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint Reserved
        {
            get
            {
                return ((__Internal*)__Instance)->reserved;
            }

            set
            {
                ((__Internal*)__Instance)->reserved = value;
            }
        }

        /// <summary>In nanoseconds, populated using SDL_GetTicksNS()</summary>
        public ulong Timestamp
        {
            get
            {
                return ((__Internal*)__Instance)->timestamp;
            }

            set
            {
                ((__Internal*)__Instance)->timestamp = value;
            }
        }

        /// <summary>The window with mouse focus, if any</summary>
        public uint WindowID
        {
            get
            {
                return ((__Internal*)__Instance)->windowID;
            }

            set
            {
                ((__Internal*)__Instance)->windowID = value;
            }
        }

        /// <summary>The mouse instance id, SDL_TOUCH_MOUSEID, or SDL_PEN_MOUSEID</summary>
        public uint Which
        {
            get
            {
                return ((__Internal*)__Instance)->which;
            }

            set
            {
                ((__Internal*)__Instance)->which = value;
            }
        }

        /// <summary>The amount scrolled horizontally, positive to the right and negative to the left</summary>
        public float X
        {
            get
            {
                return ((__Internal*)__Instance)->x;
            }

            set
            {
                ((__Internal*)__Instance)->x = value;
            }
        }

        /// <summary>The amount scrolled vertically, positive away from the user and negative toward the user</summary>
        public float Y
        {
            get
            {
                return ((__Internal*)__Instance)->y;
            }

            set
            {
                ((__Internal*)__Instance)->y = value;
            }
        }

        /// <summary>Set to one of the SDL_MOUSEWHEEL_* defines. When FLIPPED the values in X and Y will be opposite. Multiply by -1 to change them back</summary>
        public global::SDL3Sharp.MouseWheelDirection Direction
        {
            get
            {
                return ((__Internal*)__Instance)->direction;
            }

            set
            {
                ((__Internal*)__Instance)->direction = value;
            }
        }

        /// <summary>X coordinate, relative to window</summary>
        public float MouseX
        {
            get
            {
                return ((__Internal*)__Instance)->mouse_x;
            }

            set
            {
                ((__Internal*)__Instance)->mouse_x = value;
            }
        }

        /// <summary>Y coordinate, relative to window</summary>
        public float MouseY
        {
            get
            {
                return ((__Internal*)__Instance)->mouse_y;
            }

            set
            {
                ((__Internal*)__Instance)->mouse_y = value;
            }
        }
    }

    /// <summary>Joystick axis motion event structure (event.jaxis.*)</summary>
    public unsafe partial class JoyAxisEvent : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32, Pack = 8)]
        public partial struct __Internal
        {
            internal global::SDL3Sharp.EventType type;
            internal uint reserved;
            internal ulong timestamp;
            internal uint which;
            internal byte axis;
            internal byte padding1;
            internal byte padding2;
            internal byte padding3;
            internal short value;
            internal ushort padding4;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_JoyAxisEvent@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.JoyAxisEvent> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.JoyAxisEvent>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.JoyAxisEvent managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.JoyAxisEvent managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static JoyAxisEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new JoyAxisEvent(native.ToPointer(), skipVTables);
        }

        internal static JoyAxisEvent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (JoyAxisEvent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static JoyAxisEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new JoyAxisEvent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private JoyAxisEvent(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected JoyAxisEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public JoyAxisEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.JoyAxisEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public JoyAxisEvent(global::SDL3Sharp.JoyAxisEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.JoyAxisEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.JoyAxisEvent.__Internal*) __Instance) = *((global::SDL3Sharp.JoyAxisEvent.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>::SDL_EVENT_JOYSTICK_AXIS_MOTION</summary>
        public global::SDL3Sharp.EventType Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint Reserved
        {
            get
            {
                return ((__Internal*)__Instance)->reserved;
            }

            set
            {
                ((__Internal*)__Instance)->reserved = value;
            }
        }

        /// <summary>In nanoseconds, populated using SDL_GetTicksNS()</summary>
        public ulong Timestamp
        {
            get
            {
                return ((__Internal*)__Instance)->timestamp;
            }

            set
            {
                ((__Internal*)__Instance)->timestamp = value;
            }
        }

        /// <summary>The joystick instance id</summary>
        public uint Which
        {
            get
            {
                return ((__Internal*)__Instance)->which;
            }

            set
            {
                ((__Internal*)__Instance)->which = value;
            }
        }

        /// <summary>The joystick axis index</summary>
        public byte Axis
        {
            get
            {
                return ((__Internal*)__Instance)->axis;
            }

            set
            {
                ((__Internal*)__Instance)->axis = value;
            }
        }

        public byte Padding1
        {
            get
            {
                return ((__Internal*)__Instance)->padding1;
            }

            set
            {
                ((__Internal*)__Instance)->padding1 = value;
            }
        }

        public byte Padding2
        {
            get
            {
                return ((__Internal*)__Instance)->padding2;
            }

            set
            {
                ((__Internal*)__Instance)->padding2 = value;
            }
        }

        public byte Padding3
        {
            get
            {
                return ((__Internal*)__Instance)->padding3;
            }

            set
            {
                ((__Internal*)__Instance)->padding3 = value;
            }
        }

        /// <summary>The axis value (range: -32768 to 32767)</summary>
        public short Value
        {
            get
            {
                return ((__Internal*)__Instance)->value;
            }

            set
            {
                ((__Internal*)__Instance)->value = value;
            }
        }

        public ushort Padding4
        {
            get
            {
                return ((__Internal*)__Instance)->padding4;
            }

            set
            {
                ((__Internal*)__Instance)->padding4 = value;
            }
        }
    }

    /// <summary>Joystick hat position change event structure (event.jhat.*)</summary>
    public unsafe partial class JoyHatEvent : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public partial struct __Internal
        {
            internal global::SDL3Sharp.EventType type;
            internal uint reserved;
            internal ulong timestamp;
            internal uint which;
            internal byte hat;
            internal byte value;
            internal byte padding1;
            internal byte padding2;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_JoyHatEvent@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.JoyHatEvent> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.JoyHatEvent>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.JoyHatEvent managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.JoyHatEvent managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static JoyHatEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new JoyHatEvent(native.ToPointer(), skipVTables);
        }

        internal static JoyHatEvent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (JoyHatEvent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static JoyHatEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new JoyHatEvent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private JoyHatEvent(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected JoyHatEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public JoyHatEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.JoyHatEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public JoyHatEvent(global::SDL3Sharp.JoyHatEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.JoyHatEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.JoyHatEvent.__Internal*) __Instance) = *((global::SDL3Sharp.JoyHatEvent.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>::SDL_EVENT_JOYSTICK_HAT_MOTION</summary>
        public global::SDL3Sharp.EventType Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint Reserved
        {
            get
            {
                return ((__Internal*)__Instance)->reserved;
            }

            set
            {
                ((__Internal*)__Instance)->reserved = value;
            }
        }

        /// <summary>In nanoseconds, populated using SDL_GetTicksNS()</summary>
        public ulong Timestamp
        {
            get
            {
                return ((__Internal*)__Instance)->timestamp;
            }

            set
            {
                ((__Internal*)__Instance)->timestamp = value;
            }
        }

        /// <summary>The joystick instance id</summary>
        public uint Which
        {
            get
            {
                return ((__Internal*)__Instance)->which;
            }

            set
            {
                ((__Internal*)__Instance)->which = value;
            }
        }

        /// <summary>The joystick hat index</summary>
        public byte Hat
        {
            get
            {
                return ((__Internal*)__Instance)->hat;
            }

            set
            {
                ((__Internal*)__Instance)->hat = value;
            }
        }

        /// <summary>The hat position value.</summary>
        /// <remarks>
        /// <para>::SDL_HAT_LEFTUP ::SDL_HAT_UP ::SDL_HAT_RIGHTUP</para>
        /// <para>::SDL_HAT_LEFT ::SDL_HAT_CENTERED ::SDL_HAT_RIGHT</para>
        /// <para>::SDL_HAT_LEFTDOWN ::SDL_HAT_DOWN ::SDL_HAT_RIGHTDOWN</para>
        /// <para>Note that zero means the POV is centered.</para>
        /// </remarks>
        public byte Value
        {
            get
            {
                return ((__Internal*)__Instance)->value;
            }

            set
            {
                ((__Internal*)__Instance)->value = value;
            }
        }

        public byte Padding1
        {
            get
            {
                return ((__Internal*)__Instance)->padding1;
            }

            set
            {
                ((__Internal*)__Instance)->padding1 = value;
            }
        }

        public byte Padding2
        {
            get
            {
                return ((__Internal*)__Instance)->padding2;
            }

            set
            {
                ((__Internal*)__Instance)->padding2 = value;
            }
        }
    }

    /// <summary>Joystick button event structure (event.jbutton.*)</summary>
    public unsafe partial class JoyButtonEvent : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public partial struct __Internal
        {
            internal global::SDL3Sharp.EventType type;
            internal uint reserved;
            internal ulong timestamp;
            internal uint which;
            internal byte button;
            internal byte state;
            internal byte padding1;
            internal byte padding2;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_JoyButtonEvent@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.JoyButtonEvent> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.JoyButtonEvent>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.JoyButtonEvent managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.JoyButtonEvent managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static JoyButtonEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new JoyButtonEvent(native.ToPointer(), skipVTables);
        }

        internal static JoyButtonEvent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (JoyButtonEvent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static JoyButtonEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new JoyButtonEvent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private JoyButtonEvent(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected JoyButtonEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public JoyButtonEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.JoyButtonEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public JoyButtonEvent(global::SDL3Sharp.JoyButtonEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.JoyButtonEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.JoyButtonEvent.__Internal*) __Instance) = *((global::SDL3Sharp.JoyButtonEvent.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>::SDL_EVENT_JOYSTICK_BUTTON_DOWN or ::SDL_EVENT_JOYSTICK_BUTTON_UP</summary>
        public global::SDL3Sharp.EventType Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint Reserved
        {
            get
            {
                return ((__Internal*)__Instance)->reserved;
            }

            set
            {
                ((__Internal*)__Instance)->reserved = value;
            }
        }

        /// <summary>In nanoseconds, populated using SDL_GetTicksNS()</summary>
        public ulong Timestamp
        {
            get
            {
                return ((__Internal*)__Instance)->timestamp;
            }

            set
            {
                ((__Internal*)__Instance)->timestamp = value;
            }
        }

        /// <summary>The joystick instance id</summary>
        public uint Which
        {
            get
            {
                return ((__Internal*)__Instance)->which;
            }

            set
            {
                ((__Internal*)__Instance)->which = value;
            }
        }

        /// <summary>The joystick button index</summary>
        public byte Button
        {
            get
            {
                return ((__Internal*)__Instance)->button;
            }

            set
            {
                ((__Internal*)__Instance)->button = value;
            }
        }

        /// <summary>::SDL_PRESSED or ::SDL_RELEASED</summary>
        public byte State
        {
            get
            {
                return ((__Internal*)__Instance)->state;
            }

            set
            {
                ((__Internal*)__Instance)->state = value;
            }
        }

        public byte Padding1
        {
            get
            {
                return ((__Internal*)__Instance)->padding1;
            }

            set
            {
                ((__Internal*)__Instance)->padding1 = value;
            }
        }

        public byte Padding2
        {
            get
            {
                return ((__Internal*)__Instance)->padding2;
            }

            set
            {
                ((__Internal*)__Instance)->padding2 = value;
            }
        }
    }

    /// <summary>Joystick device event structure (event.jdevice.*)</summary>
    public unsafe partial class JoyDeviceEvent : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public partial struct __Internal
        {
            internal global::SDL3Sharp.EventType type;
            internal uint reserved;
            internal ulong timestamp;
            internal uint which;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_JoyDeviceEvent@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.JoyDeviceEvent> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.JoyDeviceEvent>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.JoyDeviceEvent managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.JoyDeviceEvent managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static JoyDeviceEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new JoyDeviceEvent(native.ToPointer(), skipVTables);
        }

        internal static JoyDeviceEvent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (JoyDeviceEvent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static JoyDeviceEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new JoyDeviceEvent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private JoyDeviceEvent(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected JoyDeviceEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public JoyDeviceEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.JoyDeviceEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public JoyDeviceEvent(global::SDL3Sharp.JoyDeviceEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.JoyDeviceEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.JoyDeviceEvent.__Internal*) __Instance) = *((global::SDL3Sharp.JoyDeviceEvent.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>::SDL_EVENT_JOYSTICK_ADDED or ::SDL_EVENT_JOYSTICK_REMOVED or ::SDL_EVENT_JOYSTICK_UPDATE_COMPLETE</summary>
        public global::SDL3Sharp.EventType Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint Reserved
        {
            get
            {
                return ((__Internal*)__Instance)->reserved;
            }

            set
            {
                ((__Internal*)__Instance)->reserved = value;
            }
        }

        /// <summary>In nanoseconds, populated using SDL_GetTicksNS()</summary>
        public ulong Timestamp
        {
            get
            {
                return ((__Internal*)__Instance)->timestamp;
            }

            set
            {
                ((__Internal*)__Instance)->timestamp = value;
            }
        }

        /// <summary>The joystick instance id</summary>
        public uint Which
        {
            get
            {
                return ((__Internal*)__Instance)->which;
            }

            set
            {
                ((__Internal*)__Instance)->which = value;
            }
        }
    }

    /// <summary>Joysick battery level change event structure (event.jbattery.*)</summary>
    public unsafe partial class JoyBatteryEvent : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public partial struct __Internal
        {
            internal global::SDL3Sharp.EventType type;
            internal uint reserved;
            internal ulong timestamp;
            internal uint which;
            internal global::SDL3Sharp.JoystickPowerLevel level;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_JoyBatteryEvent@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.JoyBatteryEvent> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.JoyBatteryEvent>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.JoyBatteryEvent managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.JoyBatteryEvent managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static JoyBatteryEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new JoyBatteryEvent(native.ToPointer(), skipVTables);
        }

        internal static JoyBatteryEvent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (JoyBatteryEvent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static JoyBatteryEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new JoyBatteryEvent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private JoyBatteryEvent(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected JoyBatteryEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public JoyBatteryEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.JoyBatteryEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public JoyBatteryEvent(global::SDL3Sharp.JoyBatteryEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.JoyBatteryEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.JoyBatteryEvent.__Internal*) __Instance) = *((global::SDL3Sharp.JoyBatteryEvent.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>::SDL_EVENT_JOYSTICK_BATTERY_UPDATED</summary>
        public global::SDL3Sharp.EventType Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint Reserved
        {
            get
            {
                return ((__Internal*)__Instance)->reserved;
            }

            set
            {
                ((__Internal*)__Instance)->reserved = value;
            }
        }

        /// <summary>In nanoseconds, populated using SDL_GetTicksNS()</summary>
        public ulong Timestamp
        {
            get
            {
                return ((__Internal*)__Instance)->timestamp;
            }

            set
            {
                ((__Internal*)__Instance)->timestamp = value;
            }
        }

        /// <summary>The joystick instance id</summary>
        public uint Which
        {
            get
            {
                return ((__Internal*)__Instance)->which;
            }

            set
            {
                ((__Internal*)__Instance)->which = value;
            }
        }

        /// <summary>The joystick battery level</summary>
        public global::SDL3Sharp.JoystickPowerLevel Level
        {
            get
            {
                return ((__Internal*)__Instance)->level;
            }

            set
            {
                ((__Internal*)__Instance)->level = value;
            }
        }
    }

    /// <summary>Gamepad axis motion event structure (event.gaxis.*)</summary>
    public unsafe partial class GamepadAxisEvent : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32, Pack = 8)]
        public partial struct __Internal
        {
            internal global::SDL3Sharp.EventType type;
            internal uint reserved;
            internal ulong timestamp;
            internal uint which;
            internal byte axis;
            internal byte padding1;
            internal byte padding2;
            internal byte padding3;
            internal short value;
            internal ushort padding4;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_GamepadAxisEvent@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.GamepadAxisEvent> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.GamepadAxisEvent>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.GamepadAxisEvent managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.GamepadAxisEvent managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static GamepadAxisEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new GamepadAxisEvent(native.ToPointer(), skipVTables);
        }

        internal static GamepadAxisEvent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (GamepadAxisEvent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static GamepadAxisEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new GamepadAxisEvent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private GamepadAxisEvent(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected GamepadAxisEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public GamepadAxisEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.GamepadAxisEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public GamepadAxisEvent(global::SDL3Sharp.GamepadAxisEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.GamepadAxisEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.GamepadAxisEvent.__Internal*) __Instance) = *((global::SDL3Sharp.GamepadAxisEvent.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>::SDL_EVENT_GAMEPAD_AXIS_MOTION</summary>
        public global::SDL3Sharp.EventType Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint Reserved
        {
            get
            {
                return ((__Internal*)__Instance)->reserved;
            }

            set
            {
                ((__Internal*)__Instance)->reserved = value;
            }
        }

        /// <summary>In nanoseconds, populated using SDL_GetTicksNS()</summary>
        public ulong Timestamp
        {
            get
            {
                return ((__Internal*)__Instance)->timestamp;
            }

            set
            {
                ((__Internal*)__Instance)->timestamp = value;
            }
        }

        /// <summary>The joystick instance id</summary>
        public uint Which
        {
            get
            {
                return ((__Internal*)__Instance)->which;
            }

            set
            {
                ((__Internal*)__Instance)->which = value;
            }
        }

        /// <summary>The gamepad axis (SDL_GamepadAxis)</summary>
        public byte Axis
        {
            get
            {
                return ((__Internal*)__Instance)->axis;
            }

            set
            {
                ((__Internal*)__Instance)->axis = value;
            }
        }

        public byte Padding1
        {
            get
            {
                return ((__Internal*)__Instance)->padding1;
            }

            set
            {
                ((__Internal*)__Instance)->padding1 = value;
            }
        }

        public byte Padding2
        {
            get
            {
                return ((__Internal*)__Instance)->padding2;
            }

            set
            {
                ((__Internal*)__Instance)->padding2 = value;
            }
        }

        public byte Padding3
        {
            get
            {
                return ((__Internal*)__Instance)->padding3;
            }

            set
            {
                ((__Internal*)__Instance)->padding3 = value;
            }
        }

        /// <summary>The axis value (range: -32768 to 32767)</summary>
        public short Value
        {
            get
            {
                return ((__Internal*)__Instance)->value;
            }

            set
            {
                ((__Internal*)__Instance)->value = value;
            }
        }

        public ushort Padding4
        {
            get
            {
                return ((__Internal*)__Instance)->padding4;
            }

            set
            {
                ((__Internal*)__Instance)->padding4 = value;
            }
        }
    }

    /// <summary>Gamepad button event structure (event.gbutton.*)</summary>
    public unsafe partial class GamepadButtonEvent : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public partial struct __Internal
        {
            internal global::SDL3Sharp.EventType type;
            internal uint reserved;
            internal ulong timestamp;
            internal uint which;
            internal byte button;
            internal byte state;
            internal byte padding1;
            internal byte padding2;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_GamepadButtonEvent@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.GamepadButtonEvent> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.GamepadButtonEvent>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.GamepadButtonEvent managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.GamepadButtonEvent managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static GamepadButtonEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new GamepadButtonEvent(native.ToPointer(), skipVTables);
        }

        internal static GamepadButtonEvent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (GamepadButtonEvent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static GamepadButtonEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new GamepadButtonEvent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private GamepadButtonEvent(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected GamepadButtonEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public GamepadButtonEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.GamepadButtonEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public GamepadButtonEvent(global::SDL3Sharp.GamepadButtonEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.GamepadButtonEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.GamepadButtonEvent.__Internal*) __Instance) = *((global::SDL3Sharp.GamepadButtonEvent.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>::SDL_EVENT_GAMEPAD_BUTTON_DOWN or ::SDL_EVENT_GAMEPAD_BUTTON_UP</summary>
        public global::SDL3Sharp.EventType Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint Reserved
        {
            get
            {
                return ((__Internal*)__Instance)->reserved;
            }

            set
            {
                ((__Internal*)__Instance)->reserved = value;
            }
        }

        /// <summary>In nanoseconds, populated using SDL_GetTicksNS()</summary>
        public ulong Timestamp
        {
            get
            {
                return ((__Internal*)__Instance)->timestamp;
            }

            set
            {
                ((__Internal*)__Instance)->timestamp = value;
            }
        }

        /// <summary>The joystick instance id</summary>
        public uint Which
        {
            get
            {
                return ((__Internal*)__Instance)->which;
            }

            set
            {
                ((__Internal*)__Instance)->which = value;
            }
        }

        /// <summary>The gamepad button (SDL_GamepadButton)</summary>
        public byte Button
        {
            get
            {
                return ((__Internal*)__Instance)->button;
            }

            set
            {
                ((__Internal*)__Instance)->button = value;
            }
        }

        /// <summary>::SDL_PRESSED or ::SDL_RELEASED</summary>
        public byte State
        {
            get
            {
                return ((__Internal*)__Instance)->state;
            }

            set
            {
                ((__Internal*)__Instance)->state = value;
            }
        }

        public byte Padding1
        {
            get
            {
                return ((__Internal*)__Instance)->padding1;
            }

            set
            {
                ((__Internal*)__Instance)->padding1 = value;
            }
        }

        public byte Padding2
        {
            get
            {
                return ((__Internal*)__Instance)->padding2;
            }

            set
            {
                ((__Internal*)__Instance)->padding2 = value;
            }
        }
    }

    /// <summary>Gamepad device event structure (event.gdevice.*)</summary>
    public unsafe partial class GamepadDeviceEvent : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public partial struct __Internal
        {
            internal global::SDL3Sharp.EventType type;
            internal uint reserved;
            internal ulong timestamp;
            internal uint which;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_GamepadDeviceEvent@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.GamepadDeviceEvent> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.GamepadDeviceEvent>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.GamepadDeviceEvent managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.GamepadDeviceEvent managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static GamepadDeviceEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new GamepadDeviceEvent(native.ToPointer(), skipVTables);
        }

        internal static GamepadDeviceEvent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (GamepadDeviceEvent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static GamepadDeviceEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new GamepadDeviceEvent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private GamepadDeviceEvent(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected GamepadDeviceEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public GamepadDeviceEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.GamepadDeviceEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public GamepadDeviceEvent(global::SDL3Sharp.GamepadDeviceEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.GamepadDeviceEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.GamepadDeviceEvent.__Internal*) __Instance) = *((global::SDL3Sharp.GamepadDeviceEvent.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>::SDL_EVENT_GAMEPAD_ADDED, ::SDL_EVENT_GAMEPAD_REMOVED, or ::SDL_EVENT_GAMEPAD_REMAPPED, ::SDL_EVENT_GAMEPAD_UPDATE_COMPLETE or ::SDL_EVENT_GAMEPAD_STEAM_HANDLE_UPDATED</summary>
        public global::SDL3Sharp.EventType Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint Reserved
        {
            get
            {
                return ((__Internal*)__Instance)->reserved;
            }

            set
            {
                ((__Internal*)__Instance)->reserved = value;
            }
        }

        /// <summary>In nanoseconds, populated using SDL_GetTicksNS()</summary>
        public ulong Timestamp
        {
            get
            {
                return ((__Internal*)__Instance)->timestamp;
            }

            set
            {
                ((__Internal*)__Instance)->timestamp = value;
            }
        }

        /// <summary>The joystick instance id</summary>
        public uint Which
        {
            get
            {
                return ((__Internal*)__Instance)->which;
            }

            set
            {
                ((__Internal*)__Instance)->which = value;
            }
        }
    }

    /// <summary>Gamepad touchpad event structure (event.gtouchpad.*)</summary>
    public unsafe partial class GamepadTouchpadEvent : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 40, Pack = 8)]
        public partial struct __Internal
        {
            internal global::SDL3Sharp.EventType type;
            internal uint reserved;
            internal ulong timestamp;
            internal uint which;
            internal int touchpad;
            internal int finger;
            internal float x;
            internal float y;
            internal float pressure;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_GamepadTouchpadEvent@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.GamepadTouchpadEvent> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.GamepadTouchpadEvent>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.GamepadTouchpadEvent managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.GamepadTouchpadEvent managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static GamepadTouchpadEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new GamepadTouchpadEvent(native.ToPointer(), skipVTables);
        }

        internal static GamepadTouchpadEvent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (GamepadTouchpadEvent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static GamepadTouchpadEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new GamepadTouchpadEvent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private GamepadTouchpadEvent(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected GamepadTouchpadEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public GamepadTouchpadEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.GamepadTouchpadEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public GamepadTouchpadEvent(global::SDL3Sharp.GamepadTouchpadEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.GamepadTouchpadEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.GamepadTouchpadEvent.__Internal*) __Instance) = *((global::SDL3Sharp.GamepadTouchpadEvent.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>::SDL_EVENT_GAMEPAD_TOUCHPAD_DOWN or ::SDL_EVENT_GAMEPAD_TOUCHPAD_MOTION or ::SDL_EVENT_GAMEPAD_TOUCHPAD_UP</summary>
        public global::SDL3Sharp.EventType Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint Reserved
        {
            get
            {
                return ((__Internal*)__Instance)->reserved;
            }

            set
            {
                ((__Internal*)__Instance)->reserved = value;
            }
        }

        /// <summary>In nanoseconds, populated using SDL_GetTicksNS()</summary>
        public ulong Timestamp
        {
            get
            {
                return ((__Internal*)__Instance)->timestamp;
            }

            set
            {
                ((__Internal*)__Instance)->timestamp = value;
            }
        }

        /// <summary>The joystick instance id</summary>
        public uint Which
        {
            get
            {
                return ((__Internal*)__Instance)->which;
            }

            set
            {
                ((__Internal*)__Instance)->which = value;
            }
        }

        /// <summary>The index of the touchpad</summary>
        public int Touchpad
        {
            get
            {
                return ((__Internal*)__Instance)->touchpad;
            }

            set
            {
                ((__Internal*)__Instance)->touchpad = value;
            }
        }

        /// <summary>The index of the finger on the touchpad</summary>
        public int Finger
        {
            get
            {
                return ((__Internal*)__Instance)->finger;
            }

            set
            {
                ((__Internal*)__Instance)->finger = value;
            }
        }

        /// <summary>Normalized in the range 0...1 with 0 being on the left</summary>
        public float X
        {
            get
            {
                return ((__Internal*)__Instance)->x;
            }

            set
            {
                ((__Internal*)__Instance)->x = value;
            }
        }

        /// <summary>Normalized in the range 0...1 with 0 being at the top</summary>
        public float Y
        {
            get
            {
                return ((__Internal*)__Instance)->y;
            }

            set
            {
                ((__Internal*)__Instance)->y = value;
            }
        }

        /// <summary>Normalized in the range 0...1</summary>
        public float Pressure
        {
            get
            {
                return ((__Internal*)__Instance)->pressure;
            }

            set
            {
                ((__Internal*)__Instance)->pressure = value;
            }
        }
    }

    /// <summary>Gamepad sensor event structure (event.gsensor.*)</summary>
    public unsafe partial class GamepadSensorEvent : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 48, Pack = 8)]
        public partial struct __Internal
        {
            internal global::SDL3Sharp.EventType type;
            internal uint reserved;
            internal ulong timestamp;
            internal uint which;
            internal int sensor;
            internal fixed float data[3];
            internal ulong sensor_timestamp;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_GamepadSensorEvent@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.GamepadSensorEvent> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.GamepadSensorEvent>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.GamepadSensorEvent managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.GamepadSensorEvent managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static GamepadSensorEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new GamepadSensorEvent(native.ToPointer(), skipVTables);
        }

        internal static GamepadSensorEvent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (GamepadSensorEvent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static GamepadSensorEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new GamepadSensorEvent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private GamepadSensorEvent(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected GamepadSensorEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public GamepadSensorEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.GamepadSensorEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public GamepadSensorEvent(global::SDL3Sharp.GamepadSensorEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.GamepadSensorEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.GamepadSensorEvent.__Internal*) __Instance) = *((global::SDL3Sharp.GamepadSensorEvent.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>::SDL_EVENT_GAMEPAD_SENSOR_UPDATE</summary>
        public global::SDL3Sharp.EventType Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint Reserved
        {
            get
            {
                return ((__Internal*)__Instance)->reserved;
            }

            set
            {
                ((__Internal*)__Instance)->reserved = value;
            }
        }

        /// <summary>In nanoseconds, populated using SDL_GetTicksNS()</summary>
        public ulong Timestamp
        {
            get
            {
                return ((__Internal*)__Instance)->timestamp;
            }

            set
            {
                ((__Internal*)__Instance)->timestamp = value;
            }
        }

        /// <summary>The joystick instance id</summary>
        public uint Which
        {
            get
            {
                return ((__Internal*)__Instance)->which;
            }

            set
            {
                ((__Internal*)__Instance)->which = value;
            }
        }

        /// <summary>The type of the sensor, one of the values of ::SDL_SensorType</summary>
        public int Sensor
        {
            get
            {
                return ((__Internal*)__Instance)->sensor;
            }

            set
            {
                ((__Internal*)__Instance)->sensor = value;
            }
        }

        /// <summary>Up to 3 values from the sensor, as defined in SDL_sensor.h</summary>
        public float[] Data
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<float>(((__Internal*)__Instance)->data, 3);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 3; i++)
                        ((__Internal*)__Instance)->data[i] = value[i];
                }
            }
        }

        /// <summary>The timestamp of the sensor reading in nanoseconds, not necessarily synchronized with the system clock</summary>
        public ulong SensorTimestamp
        {
            get
            {
                return ((__Internal*)__Instance)->sensor_timestamp;
            }

            set
            {
                ((__Internal*)__Instance)->sensor_timestamp = value;
            }
        }
    }

    /// <summary>Audio device event structure (event.adevice.*)</summary>
    public unsafe partial class AudioDeviceEvent : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public partial struct __Internal
        {
            internal global::SDL3Sharp.EventType type;
            internal uint reserved;
            internal ulong timestamp;
            internal uint which;
            internal byte iscapture;
            internal byte padding1;
            internal byte padding2;
            internal byte padding3;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_AudioDeviceEvent@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.AudioDeviceEvent> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.AudioDeviceEvent>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.AudioDeviceEvent managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.AudioDeviceEvent managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static AudioDeviceEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new AudioDeviceEvent(native.ToPointer(), skipVTables);
        }

        internal static AudioDeviceEvent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (AudioDeviceEvent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static AudioDeviceEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new AudioDeviceEvent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private AudioDeviceEvent(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected AudioDeviceEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public AudioDeviceEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.AudioDeviceEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public AudioDeviceEvent(global::SDL3Sharp.AudioDeviceEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.AudioDeviceEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.AudioDeviceEvent.__Internal*) __Instance) = *((global::SDL3Sharp.AudioDeviceEvent.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>::SDL_EVENT_AUDIO_DEVICE_ADDED, or ::SDL_EVENT_AUDIO_DEVICE_REMOVED, or ::SDL_EVENT_AUDIO_DEVICE_FORMAT_CHANGED</summary>
        public global::SDL3Sharp.EventType Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint Reserved
        {
            get
            {
                return ((__Internal*)__Instance)->reserved;
            }

            set
            {
                ((__Internal*)__Instance)->reserved = value;
            }
        }

        /// <summary>In nanoseconds, populated using SDL_GetTicksNS()</summary>
        public ulong Timestamp
        {
            get
            {
                return ((__Internal*)__Instance)->timestamp;
            }

            set
            {
                ((__Internal*)__Instance)->timestamp = value;
            }
        }

        /// <summary>SDL_AudioDeviceID for the device being added or removed or changing</summary>
        public uint Which
        {
            get
            {
                return ((__Internal*)__Instance)->which;
            }

            set
            {
                ((__Internal*)__Instance)->which = value;
            }
        }

        /// <summary>zero if an output device, non-zero if a capture device.</summary>
        public byte Iscapture
        {
            get
            {
                return ((__Internal*)__Instance)->iscapture;
            }

            set
            {
                ((__Internal*)__Instance)->iscapture = value;
            }
        }

        public byte Padding1
        {
            get
            {
                return ((__Internal*)__Instance)->padding1;
            }

            set
            {
                ((__Internal*)__Instance)->padding1 = value;
            }
        }

        public byte Padding2
        {
            get
            {
                return ((__Internal*)__Instance)->padding2;
            }

            set
            {
                ((__Internal*)__Instance)->padding2 = value;
            }
        }

        public byte Padding3
        {
            get
            {
                return ((__Internal*)__Instance)->padding3;
            }

            set
            {
                ((__Internal*)__Instance)->padding3 = value;
            }
        }
    }

    /// <summary>Camera device event structure (event.cdevice.*)</summary>
    public unsafe partial class CameraDeviceEvent : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public partial struct __Internal
        {
            internal global::SDL3Sharp.EventType type;
            internal ulong timestamp;
            internal uint which;
            internal byte padding1;
            internal byte padding2;
            internal byte padding3;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_CameraDeviceEvent@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.CameraDeviceEvent> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.CameraDeviceEvent>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.CameraDeviceEvent managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.CameraDeviceEvent managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static CameraDeviceEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new CameraDeviceEvent(native.ToPointer(), skipVTables);
        }

        internal static CameraDeviceEvent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (CameraDeviceEvent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static CameraDeviceEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new CameraDeviceEvent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private CameraDeviceEvent(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected CameraDeviceEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public CameraDeviceEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.CameraDeviceEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public CameraDeviceEvent(global::SDL3Sharp.CameraDeviceEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.CameraDeviceEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.CameraDeviceEvent.__Internal*) __Instance) = *((global::SDL3Sharp.CameraDeviceEvent.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>::SDL_EVENT_CAMERA_DEVICE_ADDED, ::SDL_EVENT_CAMERA_DEVICE_REMOVED, ::SDL_EVENT_CAMERA_DEVICE_APPROVED, ::SDL_EVENT_CAMERA_DEVICE_DENIED</summary>
        public global::SDL3Sharp.EventType Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        /// <summary>In nanoseconds, populated using SDL_GetTicksNS()</summary>
        public ulong Timestamp
        {
            get
            {
                return ((__Internal*)__Instance)->timestamp;
            }

            set
            {
                ((__Internal*)__Instance)->timestamp = value;
            }
        }

        /// <summary>SDL_CameraDeviceID for the device being added or removed or changing</summary>
        public uint Which
        {
            get
            {
                return ((__Internal*)__Instance)->which;
            }

            set
            {
                ((__Internal*)__Instance)->which = value;
            }
        }

        public byte Padding1
        {
            get
            {
                return ((__Internal*)__Instance)->padding1;
            }

            set
            {
                ((__Internal*)__Instance)->padding1 = value;
            }
        }

        public byte Padding2
        {
            get
            {
                return ((__Internal*)__Instance)->padding2;
            }

            set
            {
                ((__Internal*)__Instance)->padding2 = value;
            }
        }

        public byte Padding3
        {
            get
            {
                return ((__Internal*)__Instance)->padding3;
            }

            set
            {
                ((__Internal*)__Instance)->padding3 = value;
            }
        }
    }

    /// <summary>Touch finger event structure (event.tfinger.*)</summary>
    public unsafe partial class TouchFingerEvent : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 56, Pack = 8)]
        public partial struct __Internal
        {
            internal global::SDL3Sharp.EventType type;
            internal uint reserved;
            internal ulong timestamp;
            internal ulong touchID;
            internal ulong fingerID;
            internal float x;
            internal float y;
            internal float dx;
            internal float dy;
            internal float pressure;
            internal uint windowID;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_TouchFingerEvent@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.TouchFingerEvent> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.TouchFingerEvent>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.TouchFingerEvent managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.TouchFingerEvent managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static TouchFingerEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new TouchFingerEvent(native.ToPointer(), skipVTables);
        }

        internal static TouchFingerEvent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (TouchFingerEvent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static TouchFingerEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new TouchFingerEvent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TouchFingerEvent(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected TouchFingerEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public TouchFingerEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.TouchFingerEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public TouchFingerEvent(global::SDL3Sharp.TouchFingerEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.TouchFingerEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.TouchFingerEvent.__Internal*) __Instance) = *((global::SDL3Sharp.TouchFingerEvent.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>::SDL_EVENT_FINGER_MOTION or ::SDL_EVENT_FINGER_DOWN or ::SDL_EVENT_FINGER_UP</summary>
        public global::SDL3Sharp.EventType Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint Reserved
        {
            get
            {
                return ((__Internal*)__Instance)->reserved;
            }

            set
            {
                ((__Internal*)__Instance)->reserved = value;
            }
        }

        /// <summary>In nanoseconds, populated using SDL_GetTicksNS()</summary>
        public ulong Timestamp
        {
            get
            {
                return ((__Internal*)__Instance)->timestamp;
            }

            set
            {
                ((__Internal*)__Instance)->timestamp = value;
            }
        }

        /// <summary>The touch device id</summary>
        public ulong TouchID
        {
            get
            {
                return ((__Internal*)__Instance)->touchID;
            }

            set
            {
                ((__Internal*)__Instance)->touchID = value;
            }
        }

        public ulong FingerID
        {
            get
            {
                return ((__Internal*)__Instance)->fingerID;
            }

            set
            {
                ((__Internal*)__Instance)->fingerID = value;
            }
        }

        /// <summary>Normalized in the range 0...1</summary>
        public float X
        {
            get
            {
                return ((__Internal*)__Instance)->x;
            }

            set
            {
                ((__Internal*)__Instance)->x = value;
            }
        }

        /// <summary>Normalized in the range 0...1</summary>
        public float Y
        {
            get
            {
                return ((__Internal*)__Instance)->y;
            }

            set
            {
                ((__Internal*)__Instance)->y = value;
            }
        }

        /// <summary>Normalized in the range -1...1</summary>
        public float Dx
        {
            get
            {
                return ((__Internal*)__Instance)->dx;
            }

            set
            {
                ((__Internal*)__Instance)->dx = value;
            }
        }

        /// <summary>Normalized in the range -1...1</summary>
        public float Dy
        {
            get
            {
                return ((__Internal*)__Instance)->dy;
            }

            set
            {
                ((__Internal*)__Instance)->dy = value;
            }
        }

        /// <summary>Normalized in the range 0...1</summary>
        public float Pressure
        {
            get
            {
                return ((__Internal*)__Instance)->pressure;
            }

            set
            {
                ((__Internal*)__Instance)->pressure = value;
            }
        }

        /// <summary>The window underneath the finger, if any</summary>
        public uint WindowID
        {
            get
            {
                return ((__Internal*)__Instance)->windowID;
            }

            set
            {
                ((__Internal*)__Instance)->windowID = value;
            }
        }
    }

    /// <summary>Pressure-sensitive pen touched or stopped touching surface (event.ptip.*)</summary>
    public unsafe partial class PenTipEvent : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 64, Pack = 8)]
        public partial struct __Internal
        {
            internal global::SDL3Sharp.EventType type;
            internal uint reserved;
            internal ulong timestamp;
            internal uint windowID;
            internal uint which;
            internal byte tip;
            internal byte state;
            internal ushort pen_state;
            internal float x;
            internal float y;
            internal fixed float axes[6];

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_PenTipEvent@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.PenTipEvent> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.PenTipEvent>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.PenTipEvent managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.PenTipEvent managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static PenTipEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new PenTipEvent(native.ToPointer(), skipVTables);
        }

        internal static PenTipEvent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (PenTipEvent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static PenTipEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new PenTipEvent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PenTipEvent(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected PenTipEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public PenTipEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.PenTipEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public PenTipEvent(global::SDL3Sharp.PenTipEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.PenTipEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.PenTipEvent.__Internal*) __Instance) = *((global::SDL3Sharp.PenTipEvent.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>::SDL_EVENT_PEN_DOWN or ::SDL_EVENT_PEN_UP</summary>
        public global::SDL3Sharp.EventType Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint Reserved
        {
            get
            {
                return ((__Internal*)__Instance)->reserved;
            }

            set
            {
                ((__Internal*)__Instance)->reserved = value;
            }
        }

        /// <summary>In nanoseconds, populated using SDL_GetTicksNS()</summary>
        public ulong Timestamp
        {
            get
            {
                return ((__Internal*)__Instance)->timestamp;
            }

            set
            {
                ((__Internal*)__Instance)->timestamp = value;
            }
        }

        /// <summary>The window with pen focus, if any</summary>
        public uint WindowID
        {
            get
            {
                return ((__Internal*)__Instance)->windowID;
            }

            set
            {
                ((__Internal*)__Instance)->windowID = value;
            }
        }

        /// <summary>The pen instance id</summary>
        public uint Which
        {
            get
            {
                return ((__Internal*)__Instance)->which;
            }

            set
            {
                ((__Internal*)__Instance)->which = value;
            }
        }

        /// <summary>::SDL_PEN_TIP_INK when using a regular pen tip, or ::SDL_PEN_TIP_ERASER if the pen is being used as an eraser (e.g., flipped to use the eraser tip)</summary>
        public byte Tip
        {
            get
            {
                return ((__Internal*)__Instance)->tip;
            }

            set
            {
                ((__Internal*)__Instance)->tip = value;
            }
        }

        /// <summary>::SDL_PRESSED on ::SDL_EVENT_PEN_DOWN and ::SDL_RELEASED on ::SDL_EVENT_PEN_UP</summary>
        public byte State
        {
            get
            {
                return ((__Internal*)__Instance)->state;
            }

            set
            {
                ((__Internal*)__Instance)->state = value;
            }
        }

        /// <summary>Pen button masks (where SDL_BUTTON(1) is the first button, SDL_BUTTON(2) is the second button etc.), ::SDL_PEN_DOWN_MASK is set if the pen is touching the surface, and ::SDL_PEN_ERASER_MASK is set if the pen is (used as) an eraser.</summary>
        public ushort PenState
        {
            get
            {
                return ((__Internal*)__Instance)->pen_state;
            }

            set
            {
                ((__Internal*)__Instance)->pen_state = value;
            }
        }

        /// <summary>X coordinate, relative to window</summary>
        public float X
        {
            get
            {
                return ((__Internal*)__Instance)->x;
            }

            set
            {
                ((__Internal*)__Instance)->x = value;
            }
        }

        /// <summary>Y coordinate, relative to window</summary>
        public float Y
        {
            get
            {
                return ((__Internal*)__Instance)->y;
            }

            set
            {
                ((__Internal*)__Instance)->y = value;
            }
        }

        /// <summary>Pen axes such as pressure and tilt (ordered as per ::SDL_PenAxis)</summary>
        public float[] Axes
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<float>(((__Internal*)__Instance)->axes, 6);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 6; i++)
                        ((__Internal*)__Instance)->axes[i] = value[i];
                }
            }
        }
    }

    /// <summary>Pressure-sensitive pen motion / pressure / angle event structure (event.pmotion.*)</summary>
    public unsafe partial class PenMotionEvent : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 64, Pack = 8)]
        public partial struct __Internal
        {
            internal global::SDL3Sharp.EventType type;
            internal uint reserved;
            internal ulong timestamp;
            internal uint windowID;
            internal uint which;
            internal byte padding1;
            internal byte padding2;
            internal ushort pen_state;
            internal float x;
            internal float y;
            internal fixed float axes[6];

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_PenMotionEvent@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.PenMotionEvent> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.PenMotionEvent>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.PenMotionEvent managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.PenMotionEvent managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static PenMotionEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new PenMotionEvent(native.ToPointer(), skipVTables);
        }

        internal static PenMotionEvent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (PenMotionEvent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static PenMotionEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new PenMotionEvent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PenMotionEvent(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected PenMotionEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public PenMotionEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.PenMotionEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public PenMotionEvent(global::SDL3Sharp.PenMotionEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.PenMotionEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.PenMotionEvent.__Internal*) __Instance) = *((global::SDL3Sharp.PenMotionEvent.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>::SDL_EVENT_PEN_MOTION</summary>
        public global::SDL3Sharp.EventType Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint Reserved
        {
            get
            {
                return ((__Internal*)__Instance)->reserved;
            }

            set
            {
                ((__Internal*)__Instance)->reserved = value;
            }
        }

        /// <summary>In nanoseconds, populated using SDL_GetTicksNS()</summary>
        public ulong Timestamp
        {
            get
            {
                return ((__Internal*)__Instance)->timestamp;
            }

            set
            {
                ((__Internal*)__Instance)->timestamp = value;
            }
        }

        /// <summary>The window with pen focus, if any</summary>
        public uint WindowID
        {
            get
            {
                return ((__Internal*)__Instance)->windowID;
            }

            set
            {
                ((__Internal*)__Instance)->windowID = value;
            }
        }

        /// <summary>The pen instance id</summary>
        public uint Which
        {
            get
            {
                return ((__Internal*)__Instance)->which;
            }

            set
            {
                ((__Internal*)__Instance)->which = value;
            }
        }

        public byte Padding1
        {
            get
            {
                return ((__Internal*)__Instance)->padding1;
            }

            set
            {
                ((__Internal*)__Instance)->padding1 = value;
            }
        }

        public byte Padding2
        {
            get
            {
                return ((__Internal*)__Instance)->padding2;
            }

            set
            {
                ((__Internal*)__Instance)->padding2 = value;
            }
        }

        /// <summary>Pen button masks (where SDL_BUTTON(1) is the first button, SDL_BUTTON(2) is the second button etc.), ::SDL_PEN_DOWN_MASK is set if the pen is touching the surface, and ::SDL_PEN_ERASER_MASK is set if the pen is (used as) an eraser.</summary>
        public ushort PenState
        {
            get
            {
                return ((__Internal*)__Instance)->pen_state;
            }

            set
            {
                ((__Internal*)__Instance)->pen_state = value;
            }
        }

        /// <summary>X coordinate, relative to window</summary>
        public float X
        {
            get
            {
                return ((__Internal*)__Instance)->x;
            }

            set
            {
                ((__Internal*)__Instance)->x = value;
            }
        }

        /// <summary>Y coordinate, relative to window</summary>
        public float Y
        {
            get
            {
                return ((__Internal*)__Instance)->y;
            }

            set
            {
                ((__Internal*)__Instance)->y = value;
            }
        }

        /// <summary>Pen axes such as pressure and tilt (ordered as per ::SDL_PenAxis)</summary>
        public float[] Axes
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<float>(((__Internal*)__Instance)->axes, 6);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 6; i++)
                        ((__Internal*)__Instance)->axes[i] = value[i];
                }
            }
        }
    }

    /// <summary>Pressure-sensitive pen button event structure (event.pbutton.*)</summary>
    public unsafe partial class PenButtonEvent : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 64, Pack = 8)]
        public partial struct __Internal
        {
            internal global::SDL3Sharp.EventType type;
            internal uint reserved;
            internal ulong timestamp;
            internal uint windowID;
            internal uint which;
            internal byte button;
            internal byte state;
            internal ushort pen_state;
            internal float x;
            internal float y;
            internal fixed float axes[6];

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_PenButtonEvent@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.PenButtonEvent> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.PenButtonEvent>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.PenButtonEvent managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.PenButtonEvent managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static PenButtonEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new PenButtonEvent(native.ToPointer(), skipVTables);
        }

        internal static PenButtonEvent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (PenButtonEvent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static PenButtonEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new PenButtonEvent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PenButtonEvent(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected PenButtonEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public PenButtonEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.PenButtonEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public PenButtonEvent(global::SDL3Sharp.PenButtonEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.PenButtonEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.PenButtonEvent.__Internal*) __Instance) = *((global::SDL3Sharp.PenButtonEvent.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>::SDL_EVENT_PEN_BUTTON_DOWN or ::SDL_EVENT_PEN_BUTTON_UP</summary>
        public global::SDL3Sharp.EventType Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint Reserved
        {
            get
            {
                return ((__Internal*)__Instance)->reserved;
            }

            set
            {
                ((__Internal*)__Instance)->reserved = value;
            }
        }

        /// <summary>In nanoseconds, populated using SDL_GetTicksNS()</summary>
        public ulong Timestamp
        {
            get
            {
                return ((__Internal*)__Instance)->timestamp;
            }

            set
            {
                ((__Internal*)__Instance)->timestamp = value;
            }
        }

        /// <summary>The window with pen focus, if any</summary>
        public uint WindowID
        {
            get
            {
                return ((__Internal*)__Instance)->windowID;
            }

            set
            {
                ((__Internal*)__Instance)->windowID = value;
            }
        }

        /// <summary>The pen instance id</summary>
        public uint Which
        {
            get
            {
                return ((__Internal*)__Instance)->which;
            }

            set
            {
                ((__Internal*)__Instance)->which = value;
            }
        }

        /// <summary>The pen button index (1 represents the pen tip for compatibility with mouse events)</summary>
        public byte Button
        {
            get
            {
                return ((__Internal*)__Instance)->button;
            }

            set
            {
                ((__Internal*)__Instance)->button = value;
            }
        }

        /// <summary>::SDL_PRESSED or ::SDL_RELEASED</summary>
        public byte State
        {
            get
            {
                return ((__Internal*)__Instance)->state;
            }

            set
            {
                ((__Internal*)__Instance)->state = value;
            }
        }

        /// <summary>Pen button masks (where SDL_BUTTON(1) is the first button, SDL_BUTTON(2) is the second button etc.), ::SDL_PEN_DOWN_MASK is set if the pen is touching the surface, and ::SDL_PEN_ERASER_MASK is set if the pen is (used as) an eraser.</summary>
        public ushort PenState
        {
            get
            {
                return ((__Internal*)__Instance)->pen_state;
            }

            set
            {
                ((__Internal*)__Instance)->pen_state = value;
            }
        }

        /// <summary>X coordinate, relative to window</summary>
        public float X
        {
            get
            {
                return ((__Internal*)__Instance)->x;
            }

            set
            {
                ((__Internal*)__Instance)->x = value;
            }
        }

        /// <summary>Y coordinate, relative to window</summary>
        public float Y
        {
            get
            {
                return ((__Internal*)__Instance)->y;
            }

            set
            {
                ((__Internal*)__Instance)->y = value;
            }
        }

        /// <summary>Pen axes such as pressure and tilt (ordered as per ::SDL_PenAxis)</summary>
        public float[] Axes
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<float>(((__Internal*)__Instance)->axes, 6);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 6; i++)
                        ((__Internal*)__Instance)->axes[i] = value[i];
                }
            }
        }
    }

    /// <summary>An event used to drop text or request a file open by the system (event.drop.*)</summary>
    /// <remarks>
    /// <para>The `data` is owned by SDL and should be copied if the application</para>
    /// <para>wants to hold onto it beyond the scope of handling this event.</para>
    /// </remarks>
    public unsafe partial class DropEvent : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 48, Pack = 8)]
        public partial struct __Internal
        {
            internal global::SDL3Sharp.EventType type;
            internal uint reserved;
            internal ulong timestamp;
            internal uint windowID;
            internal float x;
            internal float y;
            internal __IntPtr source;
            internal __IntPtr data;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_DropEvent@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.DropEvent> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.DropEvent>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.DropEvent managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.DropEvent managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static DropEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new DropEvent(native.ToPointer(), skipVTables);
        }

        internal static DropEvent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (DropEvent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static DropEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DropEvent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DropEvent(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected DropEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public DropEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.DropEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public DropEvent(global::SDL3Sharp.DropEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.DropEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.DropEvent.__Internal*) __Instance) = *((global::SDL3Sharp.DropEvent.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>::SDL_EVENT_DROP_BEGIN or ::SDL_EVENT_DROP_FILE or ::SDL_EVENT_DROP_TEXT or ::SDL_EVENT_DROP_COMPLETE or ::SDL_EVENT_DROP_POSITION</summary>
        public global::SDL3Sharp.EventType Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint Reserved
        {
            get
            {
                return ((__Internal*)__Instance)->reserved;
            }

            set
            {
                ((__Internal*)__Instance)->reserved = value;
            }
        }

        /// <summary>In nanoseconds, populated using SDL_GetTicksNS()</summary>
        public ulong Timestamp
        {
            get
            {
                return ((__Internal*)__Instance)->timestamp;
            }

            set
            {
                ((__Internal*)__Instance)->timestamp = value;
            }
        }

        /// <summary>The window that was dropped on, if any</summary>
        public uint WindowID
        {
            get
            {
                return ((__Internal*)__Instance)->windowID;
            }

            set
            {
                ((__Internal*)__Instance)->windowID = value;
            }
        }

        /// <summary>X coordinate, relative to window (not on begin)</summary>
        public float X
        {
            get
            {
                return ((__Internal*)__Instance)->x;
            }

            set
            {
                ((__Internal*)__Instance)->x = value;
            }
        }

        /// <summary>Y coordinate, relative to window (not on begin)</summary>
        public float Y
        {
            get
            {
                return ((__Internal*)__Instance)->y;
            }

            set
            {
                ((__Internal*)__Instance)->y = value;
            }
        }

        /// <summary>The source app that sent this drop event, or NULL if that isn't available</summary>
        public sbyte* Source
        {
            get
            {
                return (sbyte*) ((__Internal*)__Instance)->source;
            }

            set
            {
                ((__Internal*)__Instance)->source = (__IntPtr) value;
            }
        }

        /// <summary>The text for SDL_EVENT_DROP_TEXT and the file name for SDL_EVENT_DROP_FILE, NULL for other events</summary>
        public sbyte* Data
        {
            get
            {
                return (sbyte*) ((__Internal*)__Instance)->data;
            }

            set
            {
                ((__Internal*)__Instance)->data = (__IntPtr) value;
            }
        }
    }

    /// <summary>An event triggered when the clipboard contents have changed (event.clipboard.*)</summary>
    public unsafe partial class ClipboardEvent : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public partial struct __Internal
        {
            internal global::SDL3Sharp.EventType type;
            internal uint reserved;
            internal ulong timestamp;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_ClipboardEvent@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.ClipboardEvent> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.ClipboardEvent>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.ClipboardEvent managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.ClipboardEvent managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ClipboardEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new ClipboardEvent(native.ToPointer(), skipVTables);
        }

        internal static ClipboardEvent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ClipboardEvent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ClipboardEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ClipboardEvent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ClipboardEvent(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected ClipboardEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ClipboardEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.ClipboardEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ClipboardEvent(global::SDL3Sharp.ClipboardEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.ClipboardEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.ClipboardEvent.__Internal*) __Instance) = *((global::SDL3Sharp.ClipboardEvent.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>::SDL_EVENT_CLIPBOARD_UPDATE</summary>
        public global::SDL3Sharp.EventType Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint Reserved
        {
            get
            {
                return ((__Internal*)__Instance)->reserved;
            }

            set
            {
                ((__Internal*)__Instance)->reserved = value;
            }
        }

        /// <summary>In nanoseconds, populated using SDL_GetTicksNS()</summary>
        public ulong Timestamp
        {
            get
            {
                return ((__Internal*)__Instance)->timestamp;
            }

            set
            {
                ((__Internal*)__Instance)->timestamp = value;
            }
        }
    }

    /// <summary>Sensor event structure (event.sensor.*)</summary>
    public unsafe partial class SensorEvent : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 56, Pack = 8)]
        public partial struct __Internal
        {
            internal global::SDL3Sharp.EventType type;
            internal uint reserved;
            internal ulong timestamp;
            internal uint which;
            internal fixed float data[6];
            internal ulong sensor_timestamp;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_SensorEvent@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.SensorEvent> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.SensorEvent>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.SensorEvent managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.SensorEvent managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static SensorEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new SensorEvent(native.ToPointer(), skipVTables);
        }

        internal static SensorEvent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (SensorEvent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static SensorEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SensorEvent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SensorEvent(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected SensorEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SensorEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.SensorEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public SensorEvent(global::SDL3Sharp.SensorEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.SensorEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.SensorEvent.__Internal*) __Instance) = *((global::SDL3Sharp.SensorEvent.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>::SDL_EVENT_SENSOR_UPDATE</summary>
        public global::SDL3Sharp.EventType Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint Reserved
        {
            get
            {
                return ((__Internal*)__Instance)->reserved;
            }

            set
            {
                ((__Internal*)__Instance)->reserved = value;
            }
        }

        /// <summary>In nanoseconds, populated using SDL_GetTicksNS()</summary>
        public ulong Timestamp
        {
            get
            {
                return ((__Internal*)__Instance)->timestamp;
            }

            set
            {
                ((__Internal*)__Instance)->timestamp = value;
            }
        }

        /// <summary>The instance ID of the sensor</summary>
        public uint Which
        {
            get
            {
                return ((__Internal*)__Instance)->which;
            }

            set
            {
                ((__Internal*)__Instance)->which = value;
            }
        }

        /// <summary>Up to 6 values from the sensor - additional values can be queried using SDL_GetSensorData()</summary>
        public float[] Data
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<float>(((__Internal*)__Instance)->data, 6);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 6; i++)
                        ((__Internal*)__Instance)->data[i] = value[i];
                }
            }
        }

        /// <summary>The timestamp of the sensor reading in nanoseconds, not necessarily synchronized with the system clock</summary>
        public ulong SensorTimestamp
        {
            get
            {
                return ((__Internal*)__Instance)->sensor_timestamp;
            }

            set
            {
                ((__Internal*)__Instance)->sensor_timestamp = value;
            }
        }
    }

    /// <summary>The &quot;quit requested&quot; event</summary>
    public unsafe partial class QuitEvent : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public partial struct __Internal
        {
            internal global::SDL3Sharp.EventType type;
            internal uint reserved;
            internal ulong timestamp;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_QuitEvent@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.QuitEvent> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.QuitEvent>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.QuitEvent managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.QuitEvent managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static QuitEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new QuitEvent(native.ToPointer(), skipVTables);
        }

        internal static QuitEvent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (QuitEvent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static QuitEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new QuitEvent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private QuitEvent(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected QuitEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public QuitEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.QuitEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public QuitEvent(global::SDL3Sharp.QuitEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.QuitEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.QuitEvent.__Internal*) __Instance) = *((global::SDL3Sharp.QuitEvent.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>::SDL_EVENT_QUIT</summary>
        public global::SDL3Sharp.EventType Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint Reserved
        {
            get
            {
                return ((__Internal*)__Instance)->reserved;
            }

            set
            {
                ((__Internal*)__Instance)->reserved = value;
            }
        }

        /// <summary>In nanoseconds, populated using SDL_GetTicksNS()</summary>
        public ulong Timestamp
        {
            get
            {
                return ((__Internal*)__Instance)->timestamp;
            }

            set
            {
                ((__Internal*)__Instance)->timestamp = value;
            }
        }
    }

    /// <summary>A user-defined event type (event.user.*)</summary>
    public unsafe partial class UserEvent : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 40, Pack = 8)]
        public partial struct __Internal
        {
            internal uint type;
            internal uint reserved;
            internal ulong timestamp;
            internal uint windowID;
            internal int code;
            internal __IntPtr data1;
            internal __IntPtr data2;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_UserEvent@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.UserEvent> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.UserEvent>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.UserEvent managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.UserEvent managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UserEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new UserEvent(native.ToPointer(), skipVTables);
        }

        internal static UserEvent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (UserEvent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static UserEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UserEvent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private UserEvent(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected UserEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public UserEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.UserEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public UserEvent(global::SDL3Sharp.UserEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.UserEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.UserEvent.__Internal*) __Instance) = *((global::SDL3Sharp.UserEvent.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>::SDL_EVENT_USER through ::SDL_EVENT_LAST-1</summary>
        public uint Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint Reserved
        {
            get
            {
                return ((__Internal*)__Instance)->reserved;
            }

            set
            {
                ((__Internal*)__Instance)->reserved = value;
            }
        }

        /// <summary>In nanoseconds, populated using SDL_GetTicksNS()</summary>
        public ulong Timestamp
        {
            get
            {
                return ((__Internal*)__Instance)->timestamp;
            }

            set
            {
                ((__Internal*)__Instance)->timestamp = value;
            }
        }

        /// <summary>The associated window if any</summary>
        public uint WindowID
        {
            get
            {
                return ((__Internal*)__Instance)->windowID;
            }

            set
            {
                ((__Internal*)__Instance)->windowID = value;
            }
        }

        /// <summary>User defined event code</summary>
        public int Code
        {
            get
            {
                return ((__Internal*)__Instance)->code;
            }

            set
            {
                ((__Internal*)__Instance)->code = value;
            }
        }

        /// <summary>User defined data pointer</summary>
        public __IntPtr Data1
        {
            get
            {
                return ((__Internal*)__Instance)->data1;
            }

            set
            {
                ((__Internal*)__Instance)->data1 = (__IntPtr) value;
            }
        }

        /// <summary>User defined data pointer</summary>
        public __IntPtr Data2
        {
            get
            {
                return ((__Internal*)__Instance)->data2;
            }

            set
            {
                ((__Internal*)__Instance)->data2 = (__IntPtr) value;
            }
        }
    }

    /// <summary>General event structure</summary>
    public unsafe partial struct Event
    {
        [StructLayout(LayoutKind.Explicit, Size = 128, Pack = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint type;

            [FieldOffset(0)]
            internal global::SDL3Sharp.CommonEvent.__Internal common;

            [FieldOffset(0)]
            internal global::SDL3Sharp.DisplayEvent.__Internal display;

            [FieldOffset(0)]
            internal global::SDL3Sharp.WindowEvent.__Internal window;

            [FieldOffset(0)]
            internal global::SDL3Sharp.KeyboardEvent.__Internal key;

            [FieldOffset(0)]
            internal global::SDL3Sharp.TextEditingEvent.__Internal edit;

            [FieldOffset(0)]
            internal global::SDL3Sharp.TextInputEvent.__Internal text;

            [FieldOffset(0)]
            internal global::SDL3Sharp.MouseMotionEvent.__Internal motion;

            [FieldOffset(0)]
            internal global::SDL3Sharp.MouseButtonEvent.__Internal button;

            [FieldOffset(0)]
            internal global::SDL3Sharp.MouseWheelEvent.__Internal wheel;

            [FieldOffset(0)]
            internal global::SDL3Sharp.JoyAxisEvent.__Internal jaxis;

            [FieldOffset(0)]
            internal global::SDL3Sharp.JoyBallEvent.__Internal jball;

            [FieldOffset(0)]
            internal global::SDL3Sharp.JoyHatEvent.__Internal jhat;

            [FieldOffset(0)]
            internal global::SDL3Sharp.JoyButtonEvent.__Internal jbutton;

            [FieldOffset(0)]
            internal global::SDL3Sharp.JoyDeviceEvent.__Internal jdevice;

            [FieldOffset(0)]
            internal global::SDL3Sharp.JoyBatteryEvent.__Internal jbattery;

            [FieldOffset(0)]
            internal global::SDL3Sharp.GamepadAxisEvent.__Internal gaxis;

            [FieldOffset(0)]
            internal global::SDL3Sharp.GamepadButtonEvent.__Internal gbutton;

            [FieldOffset(0)]
            internal global::SDL3Sharp.GamepadDeviceEvent.__Internal gdevice;

            [FieldOffset(0)]
            internal global::SDL3Sharp.GamepadTouchpadEvent.__Internal gtouchpad;

            [FieldOffset(0)]
            internal global::SDL3Sharp.GamepadSensorEvent.__Internal gsensor;

            [FieldOffset(0)]
            internal global::SDL3Sharp.AudioDeviceEvent.__Internal adevice;

            [FieldOffset(0)]
            internal global::SDL3Sharp.CameraDeviceEvent.__Internal cdevice;

            [FieldOffset(0)]
            internal global::SDL3Sharp.SensorEvent.__Internal sensor;

            [FieldOffset(0)]
            internal global::SDL3Sharp.QuitEvent.__Internal quit;

            [FieldOffset(0)]
            internal global::SDL3Sharp.UserEvent.__Internal user;

            [FieldOffset(0)]
            internal global::SDL3Sharp.TouchFingerEvent.__Internal tfinger;

            [FieldOffset(0)]
            internal global::SDL3Sharp.PenTipEvent.__Internal ptip;

            [FieldOffset(0)]
            internal global::SDL3Sharp.PenMotionEvent.__Internal pmotion;

            [FieldOffset(0)]
            internal global::SDL3Sharp.PenButtonEvent.__Internal pbutton;

            [FieldOffset(0)]
            internal global::SDL3Sharp.DropEvent.__Internal drop;

            [FieldOffset(0)]
            internal global::SDL3Sharp.ClipboardEvent.__Internal clipboard;

            [FieldOffset(0)]
            internal fixed byte padding[128];

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_Event@@QEAA@AEBT0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        private Event.__Internal __instance;
        internal ref Event.__Internal __Instance => ref __instance;

        internal static Event __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new Event(native.ToPointer(), skipVTables);
        }

        internal static Event __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Event(native, skipVTables);
        }

        private Event(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private Event(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::SDL3Sharp.Event.__Internal*) native;
        }

        public Event(global::SDL3Sharp.Event _0)
            : this()
        {
            var ____arg0 = _0.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
            }
        }

        /// <summary>Event type, shared with all events</summary>
        public uint Type
        {
            get
            {
                return __instance.type;
            }

            set
            {
                __instance.type = value;
            }
        }

        /// <summary>Common event data</summary>
        public global::SDL3Sharp.CommonEvent Common
        {
            get
            {
                return global::SDL3Sharp.CommonEvent.__CreateInstance(__instance.common);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.common = *(global::SDL3Sharp.CommonEvent.__Internal*) value.__Instance;
            }
        }

        /// <summary>Display event data</summary>
        public global::SDL3Sharp.DisplayEvent Display
        {
            get
            {
                return global::SDL3Sharp.DisplayEvent.__CreateInstance(__instance.display);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.display = *(global::SDL3Sharp.DisplayEvent.__Internal*) value.__Instance;
            }
        }

        /// <summary>Window event data</summary>
        public global::SDL3Sharp.WindowEvent Window
        {
            get
            {
                return global::SDL3Sharp.WindowEvent.__CreateInstance(__instance.window);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.window = *(global::SDL3Sharp.WindowEvent.__Internal*) value.__Instance;
            }
        }

        /// <summary>Keyboard event data</summary>
        public global::SDL3Sharp.KeyboardEvent Key
        {
            get
            {
                return global::SDL3Sharp.KeyboardEvent.__CreateInstance(__instance.key);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.key = *(global::SDL3Sharp.KeyboardEvent.__Internal*) value.__Instance;
            }
        }

        /// <summary>Text editing event data</summary>
        public global::SDL3Sharp.TextEditingEvent Edit
        {
            get
            {
                return global::SDL3Sharp.TextEditingEvent.__CreateInstance(__instance.edit);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.edit = *(global::SDL3Sharp.TextEditingEvent.__Internal*) value.__Instance;
            }
        }

        /// <summary>Text input event data</summary>
        public global::SDL3Sharp.TextInputEvent Text
        {
            get
            {
                return global::SDL3Sharp.TextInputEvent.__CreateInstance(__instance.text);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.text = *(global::SDL3Sharp.TextInputEvent.__Internal*) value.__Instance;
            }
        }

        /// <summary>Mouse motion event data</summary>
        public global::SDL3Sharp.MouseMotionEvent Motion
        {
            get
            {
                return global::SDL3Sharp.MouseMotionEvent.__CreateInstance(__instance.motion);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.motion = *(global::SDL3Sharp.MouseMotionEvent.__Internal*) value.__Instance;
            }
        }

        /// <summary>Mouse button event data</summary>
        public global::SDL3Sharp.MouseButtonEvent Button
        {
            get
            {
                return global::SDL3Sharp.MouseButtonEvent.__CreateInstance(__instance.button);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.button = *(global::SDL3Sharp.MouseButtonEvent.__Internal*) value.__Instance;
            }
        }

        /// <summary>Mouse wheel event data</summary>
        public global::SDL3Sharp.MouseWheelEvent Wheel
        {
            get
            {
                return global::SDL3Sharp.MouseWheelEvent.__CreateInstance(__instance.wheel);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.wheel = *(global::SDL3Sharp.MouseWheelEvent.__Internal*) value.__Instance;
            }
        }

        /// <summary>Joystick axis event data</summary>
        public global::SDL3Sharp.JoyAxisEvent Jaxis
        {
            get
            {
                return global::SDL3Sharp.JoyAxisEvent.__CreateInstance(__instance.jaxis);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.jaxis = *(global::SDL3Sharp.JoyAxisEvent.__Internal*) value.__Instance;
            }
        }

        /// <summary>Joystick ball event data</summary>
        public global::SDL3Sharp.JoyBallEvent Jball
        {
            get
            {
                return global::SDL3Sharp.JoyBallEvent.__CreateInstance(__instance.jball);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.jball = *(global::SDL3Sharp.JoyBallEvent.__Internal*) value.__Instance;
            }
        }

        /// <summary>Joystick hat event data</summary>
        public global::SDL3Sharp.JoyHatEvent Jhat
        {
            get
            {
                return global::SDL3Sharp.JoyHatEvent.__CreateInstance(__instance.jhat);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.jhat = *(global::SDL3Sharp.JoyHatEvent.__Internal*) value.__Instance;
            }
        }

        /// <summary>Joystick button event data</summary>
        public global::SDL3Sharp.JoyButtonEvent Jbutton
        {
            get
            {
                return global::SDL3Sharp.JoyButtonEvent.__CreateInstance(__instance.jbutton);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.jbutton = *(global::SDL3Sharp.JoyButtonEvent.__Internal*) value.__Instance;
            }
        }

        /// <summary>Joystick device change event data</summary>
        public global::SDL3Sharp.JoyDeviceEvent Jdevice
        {
            get
            {
                return global::SDL3Sharp.JoyDeviceEvent.__CreateInstance(__instance.jdevice);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.jdevice = *(global::SDL3Sharp.JoyDeviceEvent.__Internal*) value.__Instance;
            }
        }

        /// <summary>Joystick battery event data</summary>
        public global::SDL3Sharp.JoyBatteryEvent Jbattery
        {
            get
            {
                return global::SDL3Sharp.JoyBatteryEvent.__CreateInstance(__instance.jbattery);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.jbattery = *(global::SDL3Sharp.JoyBatteryEvent.__Internal*) value.__Instance;
            }
        }

        /// <summary>Gamepad axis event data</summary>
        public global::SDL3Sharp.GamepadAxisEvent Gaxis
        {
            get
            {
                return global::SDL3Sharp.GamepadAxisEvent.__CreateInstance(__instance.gaxis);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.gaxis = *(global::SDL3Sharp.GamepadAxisEvent.__Internal*) value.__Instance;
            }
        }

        /// <summary>Gamepad button event data</summary>
        public global::SDL3Sharp.GamepadButtonEvent Gbutton
        {
            get
            {
                return global::SDL3Sharp.GamepadButtonEvent.__CreateInstance(__instance.gbutton);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.gbutton = *(global::SDL3Sharp.GamepadButtonEvent.__Internal*) value.__Instance;
            }
        }

        /// <summary>Gamepad device event data</summary>
        public global::SDL3Sharp.GamepadDeviceEvent Gdevice
        {
            get
            {
                return global::SDL3Sharp.GamepadDeviceEvent.__CreateInstance(__instance.gdevice);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.gdevice = *(global::SDL3Sharp.GamepadDeviceEvent.__Internal*) value.__Instance;
            }
        }

        /// <summary>Gamepad touchpad event data</summary>
        public global::SDL3Sharp.GamepadTouchpadEvent Gtouchpad
        {
            get
            {
                return global::SDL3Sharp.GamepadTouchpadEvent.__CreateInstance(__instance.gtouchpad);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.gtouchpad = *(global::SDL3Sharp.GamepadTouchpadEvent.__Internal*) value.__Instance;
            }
        }

        /// <summary>Gamepad sensor event data</summary>
        public global::SDL3Sharp.GamepadSensorEvent Gsensor
        {
            get
            {
                return global::SDL3Sharp.GamepadSensorEvent.__CreateInstance(__instance.gsensor);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.gsensor = *(global::SDL3Sharp.GamepadSensorEvent.__Internal*) value.__Instance;
            }
        }

        /// <summary>Audio device event data</summary>
        public global::SDL3Sharp.AudioDeviceEvent Adevice
        {
            get
            {
                return global::SDL3Sharp.AudioDeviceEvent.__CreateInstance(__instance.adevice);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.adevice = *(global::SDL3Sharp.AudioDeviceEvent.__Internal*) value.__Instance;
            }
        }

        /// <summary>Camera device event data</summary>
        public global::SDL3Sharp.CameraDeviceEvent Cdevice
        {
            get
            {
                return global::SDL3Sharp.CameraDeviceEvent.__CreateInstance(__instance.cdevice);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.cdevice = *(global::SDL3Sharp.CameraDeviceEvent.__Internal*) value.__Instance;
            }
        }

        /// <summary>Sensor event data</summary>
        public global::SDL3Sharp.SensorEvent Sensor
        {
            get
            {
                return global::SDL3Sharp.SensorEvent.__CreateInstance(__instance.sensor);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.sensor = *(global::SDL3Sharp.SensorEvent.__Internal*) value.__Instance;
            }
        }

        /// <summary>Quit request event data</summary>
        public global::SDL3Sharp.QuitEvent Quit
        {
            get
            {
                return global::SDL3Sharp.QuitEvent.__CreateInstance(__instance.quit);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.quit = *(global::SDL3Sharp.QuitEvent.__Internal*) value.__Instance;
            }
        }

        /// <summary>Custom event data</summary>
        public global::SDL3Sharp.UserEvent User
        {
            get
            {
                return global::SDL3Sharp.UserEvent.__CreateInstance(__instance.user);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.user = *(global::SDL3Sharp.UserEvent.__Internal*) value.__Instance;
            }
        }

        /// <summary>Touch finger event data</summary>
        public global::SDL3Sharp.TouchFingerEvent Tfinger
        {
            get
            {
                return global::SDL3Sharp.TouchFingerEvent.__CreateInstance(__instance.tfinger);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.tfinger = *(global::SDL3Sharp.TouchFingerEvent.__Internal*) value.__Instance;
            }
        }

        /// <summary>Pen tip touching or leaving drawing surface</summary>
        public global::SDL3Sharp.PenTipEvent Ptip
        {
            get
            {
                return global::SDL3Sharp.PenTipEvent.__CreateInstance(__instance.ptip);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.ptip = *(global::SDL3Sharp.PenTipEvent.__Internal*) value.__Instance;
            }
        }

        /// <summary>Pen change in position, pressure, or angle</summary>
        public global::SDL3Sharp.PenMotionEvent Pmotion
        {
            get
            {
                return global::SDL3Sharp.PenMotionEvent.__CreateInstance(__instance.pmotion);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.pmotion = *(global::SDL3Sharp.PenMotionEvent.__Internal*) value.__Instance;
            }
        }

        /// <summary>Pen button press</summary>
        public global::SDL3Sharp.PenButtonEvent Pbutton
        {
            get
            {
                return global::SDL3Sharp.PenButtonEvent.__CreateInstance(__instance.pbutton);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.pbutton = *(global::SDL3Sharp.PenButtonEvent.__Internal*) value.__Instance;
            }
        }

        /// <summary>Drag and drop event data</summary>
        public global::SDL3Sharp.DropEvent Drop
        {
            get
            {
                return global::SDL3Sharp.DropEvent.__CreateInstance(__instance.drop);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.drop = *(global::SDL3Sharp.DropEvent.__Internal*) value.__Instance;
            }
        }

        /// <summary>Clipboard event data</summary>
        public global::SDL3Sharp.ClipboardEvent Clipboard
        {
            get
            {
                return global::SDL3Sharp.ClipboardEvent.__CreateInstance(__instance.clipboard);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.clipboard = *(global::SDL3Sharp.ClipboardEvent.__Internal*) value.__Instance;
            }
        }

        public byte[] Padding
        {
            get
            {
                fixed (byte* __arrPtr = __instance.padding)
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<byte>(__arrPtr, 128);
                }
            }

            set
            {
                fixed (byte* __arrPtr = __instance.padding)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 128; i++)
                            __arrPtr[i] = value[i];
                    }
                }
            }
        }
    }

    public unsafe partial class SDL
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_PumpEvents", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PumpEvents();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_PeepEvents", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int PeepEvents(__IntPtr events, int numevents, global::SDL3Sharp.Eventaction action, uint minType, uint maxType);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_HasEvent", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool HasEvent(uint type);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_HasEvents", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool HasEvents(uint minType, uint maxType);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_FlushEvent", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FlushEvent(uint type);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_FlushEvents", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FlushEvents(uint minType, uint maxType);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_PollEvent", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool PollEvent(__IntPtr @event);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_WaitEvent", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool WaitEvent(__IntPtr @event);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_WaitEventTimeout", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool WaitEventTimeout(__IntPtr @event, int timeoutMS);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_PushEvent", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int PushEvent(__IntPtr @event);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetEventFilter", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetEventFilter(__IntPtr filter, __IntPtr userdata);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetEventFilter", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool GetEventFilter(__IntPtr filter, __IntPtr* userdata);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_AddEventWatch", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int AddEventWatch(__IntPtr filter, __IntPtr userdata);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_DelEventWatch", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void DelEventWatch(__IntPtr filter, __IntPtr userdata);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_FilterEvents", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void FilterEvents(__IntPtr filter, __IntPtr userdata);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetEventEnabled", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetEventEnabled(uint type, bool enabled);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_EventEnabled", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool EventEnabled(uint type);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_RegisterEvents", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint RegisterEvents(int numevents);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_AllocateEventMemory", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr AllocateEventMemory(ulong size);
        }

        /// <summary>Pump the event loop, gathering events from the input devices.</summary>
        /// <remarks>
        /// <para>This function updates the event queue and internal input device state.</para>
        /// <para>**WARNING**: This should only be run in the thread that initialized the</para>
        /// <para>video subsystem, and for extra safety, you should consider only doing those</para>
        /// <para>things on the main thread in any case.</para>
        /// <para>SDL_PumpEvents() gathers all the pending input information from devices and</para>
        /// <para>places it in the event queue. Without calls to SDL_PumpEvents() no events</para>
        /// <para>would ever be placed on the queue. Often the need for calls to</para>
        /// <para>SDL_PumpEvents() is hidden from the user since SDL_PollEvent() and</para>
        /// <para>SDL_WaitEvent() implicitly call SDL_PumpEvents(). However, if you are not</para>
        /// <para>polling or waiting for events (e.g. you are filtering them), then you must</para>
        /// <para>call SDL_PumpEvents() to force an event queue update.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_PollEvent</para>
        /// <para>SDL_WaitEvent</para>
        /// </remarks>
        public static void PumpEvents()
        {
            __Internal.PumpEvents();
        }

        /// <summary>Check the event queue for messages and optionally return them.</summary>
        /// <param name="events">destination buffer for the retrieved events</param>
        /// <param name="numevents">
        /// <para>if action is SDL_ADDEVENT, the number of events to add</para>
        /// <para>back to the event queue; if action is SDL_PEEKEVENT or</para>
        /// <para>SDL_GETEVENT, the maximum number of events to retrieve</para>
        /// </param>
        /// <param name="action">action to take; see [[#action|Remarks]] for details</param>
        /// <param name="minType">
        /// <para>minimum value of the event type to be considered;</para>
        /// <para>SDL_EVENT_FIRST is a safe choice</para>
        /// </param>
        /// <param name="maxType">
        /// <para>maximum value of the event type to be considered;</para>
        /// <para>SDL_EVENT_LAST is a safe choice</para>
        /// </param>
        /// <remarks>
        /// <para>`action` may be any of the following:</para>
        /// <para>- `SDL_ADDEVENT`: up to `numevents` events will be added to the back of the</para>
        /// <para>event queue.</para>
        /// <para>- `SDL_PEEKEVENT`: `numevents` events at the front of the event queue,</para>
        /// <para>within the specified minimum and maximum type, will be returned to the</para>
        /// <para>caller and will _not_ be removed from the queue.</para>
        /// <para>- `SDL_GETEVENT`: up to `numevents` events at the front of the event queue,</para>
        /// <para>within the specified minimum and maximum type, will be returned to the</para>
        /// <para>caller and will be removed from the queue.</para>
        /// <para>You may have to call SDL_PumpEvents() before calling this function.</para>
        /// <para>Otherwise, the events may not be ready to be filtered when you call</para>
        /// <para>SDL_PeepEvents().</para>
        /// <para>This function is thread-safe.</para>
        /// <para>the number of events actually stored or a negative error code on</para>
        /// <para>failure; call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_PollEvent</para>
        /// <para>SDL_PumpEvents</para>
        /// <para>SDL_PushEvent</para>
        /// </remarks>
        public static int PeepEvents(global::SDL3Sharp.Event events, int numevents, global::SDL3Sharp.Eventaction action, uint minType, uint maxType)
        {
            var ____arg0 = events.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            var ___ret = __Internal.PeepEvents(__arg0, numevents, action, minType, maxType);
            return ___ret;
        }

        /// <summary>Check for the existence of a certain event type in the event queue.</summary>
        /// <param name="type">the type of event to be queried; see SDL_EventType for details</param>
        /// <remarks>
        /// <para>If you need to check for a range of event types, use SDL_HasEvents()</para>
        /// <para>instead.</para>
        /// <para>SDL_TRUE if events matching `type` are present, or SDL_FALSE if</para>
        /// <para>events matching `type` are not present.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_HasEvents</para>
        /// </remarks>
        public static bool HasEvent(uint type)
        {
            var ___ret = __Internal.HasEvent(type);
            return ___ret;
        }

        /// <summary>Check for the existence of certain event types in the event queue.</summary>
        /// <param name="minType">
        /// <para>the low end of event type to be queried, inclusive; see</para>
        /// <para>SDL_EventType for details</para>
        /// </param>
        /// <param name="maxType">
        /// <para>the high end of event type to be queried, inclusive; see</para>
        /// <para>SDL_EventType for details</para>
        /// </param>
        /// <remarks>
        /// <para>If you need to check for a single event type, use SDL_HasEvent() instead.</para>
        /// <para>SDL_TRUE if events with type &gt;= `minType` and&lt;= `maxType` are</para>
        /// <para>present, or SDL_FALSE if not.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_HasEvents</para>
        /// </remarks>
        public static bool HasEvents(uint minType, uint maxType)
        {
            var ___ret = __Internal.HasEvents(minType, maxType);
            return ___ret;
        }

        /// <summary>Clear events of a specific type from the event queue.</summary>
        /// <param name="type">the type of event to be cleared; see SDL_EventType for details</param>
        /// <remarks>
        /// <para>This will unconditionally remove any events from the queue that match</para>
        /// <para>`type`. If you need to remove a range of event types, use SDL_FlushEvents()</para>
        /// <para>instead.</para>
        /// <para>It's also normal to just ignore events you don't care about in your event</para>
        /// <para>loop without calling this function.</para>
        /// <para>This function only affects currently queued events. If you want to make</para>
        /// <para>sure that all pending OS events are flushed, you can call SDL_PumpEvents()</para>
        /// <para>on the main thread immediately before the flush call.</para>
        /// <para>If you have user events with custom data that needs to be freed, you should</para>
        /// <para>use SDL_PeepEvents() to remove and clean up those events before calling</para>
        /// <para>this function.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_FlushEvents</para>
        /// </remarks>
        public static void FlushEvent(uint type)
        {
            __Internal.FlushEvent(type);
        }

        /// <summary>Clear events of a range of types from the event queue.</summary>
        /// <param name="minType">
        /// <para>the low end of event type to be cleared, inclusive; see</para>
        /// <para>SDL_EventType for details</para>
        /// </param>
        /// <param name="maxType">
        /// <para>the high end of event type to be cleared, inclusive; see</para>
        /// <para>SDL_EventType for details</para>
        /// </param>
        /// <remarks>
        /// <para>This will unconditionally remove any events from the queue that are in the</para>
        /// <para>range of `minType` to `maxType`, inclusive. If you need to remove a single</para>
        /// <para>event type, use SDL_FlushEvent() instead.</para>
        /// <para>It's also normal to just ignore events you don't care about in your event</para>
        /// <para>loop without calling this function.</para>
        /// <para>This function only affects currently queued events. If you want to make</para>
        /// <para>sure that all pending OS events are flushed, you can call SDL_PumpEvents()</para>
        /// <para>on the main thread immediately before the flush call.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_FlushEvent</para>
        /// </remarks>
        public static void FlushEvents(uint minType, uint maxType)
        {
            __Internal.FlushEvents(minType, maxType);
        }

        /// <summary>Poll for currently pending events.</summary>
        /// <param name="event">
        /// <para>the SDL_Event structure to be filled with the next event from</para>
        /// <para>the queue, or NULL</para>
        /// </param>
        /// <remarks>
        /// <para>If `event` is not NULL, the next event is removed from the queue and stored</para>
        /// <para>in the SDL_Event structure pointed to by `event`. The 1 returned refers to</para>
        /// <para>this event, immediately stored in the SDL Event structure -- not an event</para>
        /// <para>to follow.</para>
        /// <para>If `event` is NULL, it simply returns 1 if there is an event in the queue,</para>
        /// <para>but will not remove it from the queue.</para>
        /// <para>As this function may implicitly call SDL_PumpEvents(), you can only call</para>
        /// <para>this function in the thread that set the video mode.</para>
        /// <para>SDL_PollEvent() is the favored way of receiving system events since it can</para>
        /// <para>be done from the main loop and does not suspend the main loop while waiting</para>
        /// <para>on an event to be posted.</para>
        /// <para>The common practice is to fully process the event queue once every frame,</para>
        /// <para>usually as a first step before updating the game's state:</para>
        /// <para>```c</para>
        /// <para>while (game_is_still_running) {</para>
        /// <para>SDL_Event event;</para>
        /// <para>while (SDL_PollEvent(&amp;event)) {  // poll until all events are handled!</para>
        /// <para>// decide what to do with this event.</para>
        /// <para>}</para>
        /// <para>// update game state, draw the current frame</para>
        /// <para>}</para>
        /// <para>```</para>
        /// <para>SDL_TRUE if this got an event or SDL_FALSE if there are none</para>
        /// <para>available.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_PushEvent</para>
        /// <para>SDL_WaitEvent</para>
        /// <para>SDL_WaitEventTimeout</para>
        /// </remarks>
        public static bool PollEvent(out global::SDL3Sharp.Event @event)
        {
            @event = new global::SDL3Sharp.Event();
            fixed (global::SDL3Sharp.Event.__Internal* ____arg0 = &@event.__Instance)
            {
                var __arg0 = new __IntPtr(____arg0);
                var ___ret = __Internal.PollEvent(__arg0);
                return ___ret;
            }
        }

        /// <summary>Wait indefinitely for the next available event.</summary>
        /// <param name="event">
        /// <para>the SDL_Event structure to be filled in with the next event</para>
        /// <para>from the queue, or NULL</para>
        /// </param>
        /// <remarks>
        /// <para>If `event` is not NULL, the next event is removed from the queue and stored</para>
        /// <para>in the SDL_Event structure pointed to by `event`.</para>
        /// <para>As this function may implicitly call SDL_PumpEvents(), you can only call</para>
        /// <para>this function in the thread that initialized the video subsystem.</para>
        /// <para>SDL_TRUE on success or SDL_FALSE if there was an error while</para>
        /// <para>waiting for events; call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_PollEvent</para>
        /// <para>SDL_PushEvent</para>
        /// <para>SDL_WaitEventTimeout</para>
        /// </remarks>
        public static bool WaitEvent(global::SDL3Sharp.Event @event)
        {
            var ____arg0 = @event.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            var ___ret = __Internal.WaitEvent(__arg0);
            return ___ret;
        }

        /// <summary>
        /// <para>Wait until the specified timeout (in milliseconds) for the next available</para>
        /// <para>event.</para>
        /// </summary>
        /// <param name="event">
        /// <para>the SDL_Event structure to be filled in with the next event</para>
        /// <para>from the queue, or NULL</para>
        /// </param>
        /// <param name="timeoutMS">
        /// <para>the maximum number of milliseconds to wait for the next</para>
        /// <para>available event</para>
        /// </param>
        /// <remarks>
        /// <para>If `event` is not NULL, the next event is removed from the queue and stored</para>
        /// <para>in the SDL_Event structure pointed to by `event`.</para>
        /// <para>As this function may implicitly call SDL_PumpEvents(), you can only call</para>
        /// <para>this function in the thread that initialized the video subsystem.</para>
        /// <para>The timeout is not guaranteed, the actual wait time could be longer due to</para>
        /// <para>system scheduling.</para>
        /// <para>SDL_TRUE if this got an event or SDL_FALSE if the timeout elapsed</para>
        /// <para>without any events available.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_PollEvent</para>
        /// <para>SDL_PushEvent</para>
        /// <para>SDL_WaitEvent</para>
        /// </remarks>
        public static bool WaitEventTimeout(global::SDL3Sharp.Event @event, int timeoutMS)
        {
            var ____arg0 = @event.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            var ___ret = __Internal.WaitEventTimeout(__arg0, timeoutMS);
            return ___ret;
        }

        /// <summary>Add an event to the event queue.</summary>
        /// <param name="event">the SDL_Event to be added to the queue</param>
        /// <remarks>
        /// <para>The event queue can actually be used as a two way communication channel.</para>
        /// <para>Not only can events be read from the queue, but the user can also push</para>
        /// <para>their own events onto it. `event` is a pointer to the event structure you</para>
        /// <para>wish to push onto the queue. The event is copied into the queue, and the</para>
        /// <para>caller may dispose of the memory pointed to after SDL_PushEvent() returns.</para>
        /// <para>Note: Pushing device input events onto the queue doesn't modify the state</para>
        /// <para>of the device within SDL.</para>
        /// <para>This function is thread-safe, and can be called from other threads safely.</para>
        /// <para>Note: Events pushed onto the queue with SDL_PushEvent() get passed through</para>
        /// <para>the event filter but events added with SDL_PeepEvents() do not.</para>
        /// <para>For pushing application-specific events, please use SDL_RegisterEvents() to</para>
        /// <para>get an event type that does not conflict with other code that also wants</para>
        /// <para>its own custom event types.</para>
        /// <para>1 on success, 0 if the event was filtered, or a negative error</para>
        /// <para>code on failure; call SDL_GetError() for more information. A</para>
        /// <para>common reason for error is the event queue being full.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_PeepEvents</para>
        /// <para>SDL_PollEvent</para>
        /// <para>SDL_RegisterEvents</para>
        /// </remarks>
        public static int PushEvent(global::SDL3Sharp.Event @event)
        {
            var ____arg0 = @event.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            var ___ret = __Internal.PushEvent(__arg0);
            return ___ret;
        }

        /// <summary>
        /// <para>Set up a filter to process all events before they change internal state and</para>
        /// <para>are posted to the internal event queue.</para>
        /// </summary>
        /// <param name="filter">An SDL_EventFilter function to call when an event happens</param>
        /// <param name="userdata">a pointer that is passed to `filter`</param>
        /// <remarks>
        /// <para>If the filter function returns 1 when called, then the event will be added</para>
        /// <para>to the internal queue. If it returns 0, then the event will be dropped from</para>
        /// <para>the queue, but the internal state will still be updated. This allows</para>
        /// <para>selective filtering of dynamically arriving events.</para>
        /// <para>**WARNING**: Be very careful of what you do in the event filter function,</para>
        /// <para>as it may run in a different thread!</para>
        /// <para>On platforms that support it, if the quit event is generated by an</para>
        /// <para>interrupt signal (e.g. pressing Ctrl-C), it will be delivered to the</para>
        /// <para>application at the next event poll.</para>
        /// <para>There is one caveat when dealing with the ::SDL_QuitEvent event type. The</para>
        /// <para>event filter is only called when the window manager desires to close the</para>
        /// <para>application window. If the event filter returns 1, then the window will be</para>
        /// <para>closed, otherwise the window will remain open if possible.</para>
        /// <para>Note: Disabled events never make it to the event filter function; see</para>
        /// <para>SDL_SetEventEnabled().</para>
        /// <para>Note: If you just want to inspect events without filtering, you should use</para>
        /// <para>SDL_AddEventWatch() instead.</para>
        /// <para>Note: Events pushed onto the queue with SDL_PushEvent() get passed through</para>
        /// <para>the event filter, but events pushed onto the queue with SDL_PeepEvents() do</para>
        /// <para>not.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_AddEventWatch</para>
        /// <para>SDL_SetEventEnabled</para>
        /// <para>SDL_GetEventFilter</para>
        /// <para>SDL_PeepEvents</para>
        /// <para>SDL_PushEvent</para>
        /// </remarks>
        public static void SetEventFilter(global::SDL3Sharp.EventFilter filter, __IntPtr userdata)
        {
            var __arg0 = filter == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(filter);
            __Internal.SetEventFilter(__arg0, userdata);
        }

        /// <summary>Query the current event filter.</summary>
        /// <param name="filter">the current callback function will be stored here</param>
        /// <param name="userdata">
        /// <para>the pointer that is passed to the current event filter will</para>
        /// <para>be stored here</para>
        /// </param>
        /// <remarks>
        /// <para>This function can be used to &quot;chain&quot; filters, by saving the existing filter</para>
        /// <para>before replacing it with a function that will call that saved filter.</para>
        /// <para>SDL_TRUE on success or SDL_FALSE if there is no event filter set.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_SetEventFilter</para>
        /// </remarks>
        public static bool GetEventFilter(global::SDL3Sharp.EventFilter filter, __IntPtr* userdata)
        {
            var __arg0 = filter == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(filter);
            var ___ret = __Internal.GetEventFilter(__arg0, userdata);
            return ___ret;
        }

        /// <summary>Add a callback to be triggered when an event is added to the event queue.</summary>
        /// <param name="filter">an SDL_EventFilter function to call when an event happens.</param>
        /// <param name="userdata">a pointer that is passed to `filter`</param>
        /// <remarks>
        /// <para>`filter` will be called when an event happens, and its return value is</para>
        /// <para>ignored.</para>
        /// <para>**WARNING**: Be very careful of what you do in the event filter function,</para>
        /// <para>as it may run in a different thread!</para>
        /// <para>If the quit event is generated by a signal (e.g. SIGINT), it will bypass</para>
        /// <para>the internal queue and be delivered to the watch callback immediately, and</para>
        /// <para>arrive at the next event poll.</para>
        /// <para>Note: the callback is called for events posted by the user through</para>
        /// <para>SDL_PushEvent(), but not for disabled events, nor for events by a filter</para>
        /// <para>callback set with SDL_SetEventFilter(), nor for events posted by the user</para>
        /// <para>through SDL_PeepEvents().</para>
        /// <para>0 on success, or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_DelEventWatch</para>
        /// <para>SDL_SetEventFilter</para>
        /// </remarks>
        public static int AddEventWatch(global::SDL3Sharp.EventFilter filter, __IntPtr userdata)
        {
            var __arg0 = filter == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(filter);
            var ___ret = __Internal.AddEventWatch(__arg0, userdata);
            return ___ret;
        }

        /// <summary>Remove an event watch callback added with SDL_AddEventWatch().</summary>
        /// <param name="filter">the function originally passed to SDL_AddEventWatch()</param>
        /// <param name="userdata">the pointer originally passed to SDL_AddEventWatch()</param>
        /// <remarks>
        /// <para>This function takes the same input as SDL_AddEventWatch() to identify and</para>
        /// <para>delete the corresponding callback.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_AddEventWatch</para>
        /// </remarks>
        public static void DelEventWatch(global::SDL3Sharp.EventFilter filter, __IntPtr userdata)
        {
            var __arg0 = filter == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(filter);
            __Internal.DelEventWatch(__arg0, userdata);
        }

        /// <summary>
        /// <para>Run a specific filter function on the current event queue, removing any</para>
        /// <para>events for which the filter returns 0.</para>
        /// </summary>
        /// <param name="filter">the SDL_EventFilter function to call when an event happens</param>
        /// <param name="userdata">a pointer that is passed to `filter`</param>
        /// <remarks>
        /// <para>See SDL_SetEventFilter() for more information. Unlike SDL_SetEventFilter(),</para>
        /// <para>this function does not change the filter permanently, it only uses the</para>
        /// <para>supplied filter until this function returns.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetEventFilter</para>
        /// <para>SDL_SetEventFilter</para>
        /// </remarks>
        public static void FilterEvents(global::SDL3Sharp.EventFilter filter, __IntPtr userdata)
        {
            var __arg0 = filter == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(filter);
            __Internal.FilterEvents(__arg0, userdata);
        }

        /// <summary>Set the state of processing events by type.</summary>
        /// <param name="type">the type of event; see SDL_EventType for details</param>
        /// <param name="enabled">whether to process the event or not</param>
        /// <remarks>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_IsEventEnabled</para>
        /// </remarks>
        public static void SetEventEnabled(uint type, bool enabled)
        {
            __Internal.SetEventEnabled(type, enabled);
        }

        /// <summary>Query the state of processing events by type.</summary>
        /// <param name="type">the type of event; see SDL_EventType for details</param>
        /// <remarks>
        /// <para>SDL_TRUE if the event is being processed, SDL_FALSE otherwise.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_SetEventEnabled</para>
        /// </remarks>
        public static bool EventEnabled(uint type)
        {
            var ___ret = __Internal.EventEnabled(type);
            return ___ret;
        }

        /// <summary>
        /// <para>Allocate a set of user-defined events, and return the beginning event</para>
        /// <para>number for that set of events.</para>
        /// </summary>
        /// <param name="numevents">the number of events to be allocated</param>
        /// <remarks>
        /// <para>the beginning event number, or 0 if numevents is invalid or if</para>
        /// <para>there are not enough user-defined events left.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_PushEvent</para>
        /// </remarks>
        public static uint RegisterEvents(int numevents)
        {
            var ___ret = __Internal.RegisterEvents(numevents);
            return ___ret;
        }

        /// <summary>Allocate dynamic memory for an SDL event</summary>
        /// <param name="size">the amount of memory to allocate</param>
        /// <remarks>
        /// <para>You can use this to allocate memory for user events that will be</para>
        /// <para>automatically freed after the event is processed.</para>
        /// <para>a pointer to the memory allocated or NULL on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static __IntPtr AllocateEventMemory(ulong size)
        {
            var ___ret = __Internal.AllocateEventMemory(size);
            return ___ret;
        }
    }
}
