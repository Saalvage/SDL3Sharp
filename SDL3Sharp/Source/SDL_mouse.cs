// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required
#pragma warning disable CS9084 // Struct member returns 'this' or other instance members by reference

namespace SDL3Sharp
{
    /// <summary>Cursor types for SDL_CreateSystemCursor().</summary>
    public enum SystemCursor
    {
        /// <summary>Arrow</summary>
        SystemCursorArrow = 0,
        /// <summary>I-beam</summary>
        SystemCursorIbeam = 1,
        /// <summary>Wait</summary>
        SystemCursorWait = 2,
        /// <summary>Crosshair</summary>
        SystemCursorCrosshair = 3,
        /// <summary>Small wait cursor (or Wait if not available)</summary>
        SystemCursorWaitarrow = 4,
        /// <summary>Double arrow pointing northwest and southeast</summary>
        SystemCursorSizenwse = 5,
        /// <summary>Double arrow pointing northeast and southwest</summary>
        SystemCursorSizenesw = 6,
        /// <summary>Double arrow pointing west and east</summary>
        SystemCursorSizewe = 7,
        /// <summary>Double arrow pointing north and south</summary>
        SystemCursorSizens = 8,
        /// <summary>Four pointed arrow pointing north, south, east, and west</summary>
        SystemCursorSizeall = 9,
        /// <summary>Slashed circle or crossbones</summary>
        SystemCursorNo = 10,
        /// <summary>Hand</summary>
        SystemCursorHand = 11,
        /// <summary>Window resize top-left (or SIZENWSE)</summary>
        SystemCursorWindowTopleft = 12,
        /// <summary>Window resize top (or SIZENS)</summary>
        SystemCursorWindowTop = 13,
        /// <summary>Window resize top-right (or SIZENESW)</summary>
        SystemCursorWindowTopright = 14,
        /// <summary>Window resize right (or SIZEWE)</summary>
        SystemCursorWindowRight = 15,
        /// <summary>Window resize bottom-right (or SIZENWSE)</summary>
        SystemCursorWindowBottomright = 16,
        /// <summary>Window resize bottom (or SIZENS)</summary>
        SystemCursorWindowBottom = 17,
        /// <summary>Window resize bottom-left (or SIZENESW)</summary>
        SystemCursorWindowBottomleft = 18,
        /// <summary>Window resize left (or SIZEWE)</summary>
        SystemCursorWindowLeft = 19,
        NumSystemCursors = 20
    }

    /// <summary>Scroll direction types for the Scroll event</summary>
    public enum MouseWheelDirection
    {
        /// <summary>The scroll direction is normal</summary>
        Normal = 0,
        /// <summary>The scroll direction is flipped / natural</summary>
        Flipped = 1
    }

    public enum MouseButton : byte
    {
        Left = 1,
        Middle = 2,
        Right = 3,
        X1 = 4,
        X2 = 5
    }

    /// <summary>Cursor types for SDL_CreateSystemCursor().</summary>
    /// <summary>Scroll direction types for the Scroll event</summary>
    public unsafe partial class Cursor
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.Cursor> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.Cursor>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.Cursor managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.Cursor managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Cursor __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Cursor(native.ToPointer(), skipVTables);
        }

        internal static Cursor __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Cursor)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Cursor __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Cursor(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Cursor(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Cursor(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class SDL
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetMouseFocus", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetMouseFocus();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetMouseState", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint GetMouseState(float* x, float* y);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetGlobalMouseState", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint GetGlobalMouseState(float* x, float* y);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetRelativeMouseState", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint GetRelativeMouseState(float* x, float* y);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_WarpMouseInWindow", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void WarpMouseInWindow(__IntPtr window, float x, float y);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_WarpMouseGlobal", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int WarpMouseGlobal(float x, float y);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetRelativeMouseMode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetRelativeMouseMode(bool enabled);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_CaptureMouse", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int CaptureMouse(bool enabled);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetRelativeMouseMode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool GetRelativeMouseMode();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_CreateCursor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CreateCursor(byte* data, byte* mask, int w, int h, int hot_x, int hot_y);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_CreateColorCursor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CreateColorCursor(__IntPtr surface, int hot_x, int hot_y);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_CreateSystemCursor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CreateSystemCursor(global::SDL3Sharp.SystemCursor id);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetCursor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetCursor(__IntPtr cursor);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetCursor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetCursor();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetDefaultCursor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetDefaultCursor();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_DestroyCursor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void DestroyCursor(__IntPtr cursor);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_ShowCursor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int ShowCursor();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_HideCursor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int HideCursor();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_CursorVisible", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool CursorVisible();
        }

        /// <summary>Get the window which currently has mouse focus.</summary>
        /// <remarks>
        /// <para>the window with mouse focus.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static global::SDL3Sharp.Window GetMouseFocus()
        {
            var ___ret = __Internal.GetMouseFocus();
            var __result0 = global::SDL3Sharp.Window.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Retrieve the current state of the mouse.</summary>
        /// <param name="x">
        /// <para>the x coordinate of the mouse cursor position relative to the</para>
        /// <para>focus window</para>
        /// </param>
        /// <param name="y">
        /// <para>the y coordinate of the mouse cursor position relative to the</para>
        /// <para>focus window</para>
        /// </param>
        /// <remarks>
        /// <para>The current button state is returned as a button bitmask, which can be</para>
        /// <para>tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the</para>
        /// <para>left, 2 for middle, 3 for the right button), and `x` and `y` are set to the</para>
        /// <para>mouse cursor position relative to the focus window. You can pass NULL for</para>
        /// <para>either `x` or `y`.</para>
        /// <para>a 32-bit button bitmask of the current button state.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetGlobalMouseState</para>
        /// <para>SDL_GetRelativeMouseState</para>
        /// <para>SDL_PumpEvents</para>
        /// </remarks>
        public static uint GetMouseState(ref float x, ref float y)
        {
            fixed (float* __x0 = &x)
            {
                var __arg0 = __x0;
                fixed (float* __y1 = &y)
                {
                    var __arg1 = __y1;
                    var ___ret = __Internal.GetMouseState(__arg0, __arg1);
                    return ___ret;
                }
            }
        }

        /// <summary>Get the current state of the mouse in relation to the desktop.</summary>
        /// <param name="x">
        /// <para>filled in with the current X coord relative to the desktop; can be</para>
        /// <para>NULL</para>
        /// </param>
        /// <param name="y">
        /// <para>filled in with the current Y coord relative to the desktop; can be</para>
        /// <para>NULL</para>
        /// </param>
        /// <remarks>
        /// <para>This works similarly to SDL_GetMouseState(), but the coordinates will be</para>
        /// <para>reported relative to the top-left of the desktop. This can be useful if you</para>
        /// <para>need to track the mouse outside of a specific window and SDL_CaptureMouse()</para>
        /// <para>doesn't fit your needs. For example, it could be useful if you need to</para>
        /// <para>track the mouse while dragging a window, where coordinates relative to a</para>
        /// <para>window might not be in sync at all times.</para>
        /// <para>Note: SDL_GetMouseState() returns the mouse position as SDL understands it</para>
        /// <para>from the last pump of the event queue. This function, however, queries the</para>
        /// <para>OS for the current mouse position, and as such, might be a slightly less</para>
        /// <para>efficient function. Unless you know what you're doing and have a good</para>
        /// <para>reason to use this function, you probably want SDL_GetMouseState() instead.</para>
        /// <para>the current button state as a bitmask which can be tested using</para>
        /// <para>the SDL_BUTTON(X) macros.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CaptureMouse</para>
        /// </remarks>
        public static uint GetGlobalMouseState(ref float x, ref float y)
        {
            fixed (float* __x0 = &x)
            {
                var __arg0 = __x0;
                fixed (float* __y1 = &y)
                {
                    var __arg1 = __y1;
                    var ___ret = __Internal.GetGlobalMouseState(__arg0, __arg1);
                    return ___ret;
                }
            }
        }

        /// <summary>Retrieve the relative state of the mouse.</summary>
        /// <param name="x">a pointer filled with the last recorded x coordinate of the mouse</param>
        /// <param name="y">a pointer filled with the last recorded y coordinate of the mouse</param>
        /// <remarks>
        /// <para>The current button state is returned as a button bitmask, which can be</para>
        /// <para>tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the</para>
        /// <para>left, 2 for middle, 3 for the right button), and `x` and `y` are set to the</para>
        /// <para>mouse deltas since the last call to SDL_GetRelativeMouseState() or since</para>
        /// <para>event initialization. You can pass NULL for either `x` or `y`.</para>
        /// <para>a 32-bit button bitmask of the relative button state.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetMouseState</para>
        /// </remarks>
        public static uint GetRelativeMouseState(ref float x, ref float y)
        {
            fixed (float* __x0 = &x)
            {
                var __arg0 = __x0;
                fixed (float* __y1 = &y)
                {
                    var __arg1 = __y1;
                    var ___ret = __Internal.GetRelativeMouseState(__arg0, __arg1);
                    return ___ret;
                }
            }
        }

        /// <summary>Move the mouse cursor to the given position within the window.</summary>
        /// <param name="window">
        /// <para>the window to move the mouse into, or NULL for the current</para>
        /// <para>mouse focus</para>
        /// </param>
        /// <param name="x">the x coordinate within the window</param>
        /// <param name="y">the y coordinate within the window</param>
        /// <remarks>
        /// <para>This function generates a mouse motion event if relative mode is not</para>
        /// <para>enabled. If relative mode is enabled, you can force mouse events for the</para>
        /// <para>warp by setting the SDL_HINT_MOUSE_RELATIVE_WARP_MOTION hint.</para>
        /// <para>Note that this function will appear to succeed, but not actually move the</para>
        /// <para>mouse when used over Microsoft Remote Desktop.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_WarpMouseGlobal</para>
        /// </remarks>
        public static void WarpMouseInWindow(global::SDL3Sharp.Window window, float x, float y)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.WarpMouseInWindow(__arg0, x, y);
        }

        /// <summary>Move the mouse to the given position in global screen space.</summary>
        /// <param name="x">the x coordinate</param>
        /// <param name="y">the y coordinate</param>
        /// <remarks>
        /// <para>This function generates a mouse motion event.</para>
        /// <para>A failure of this function usually means that it is unsupported by a</para>
        /// <para>platform.</para>
        /// <para>Note that this function will appear to succeed, but not actually move the</para>
        /// <para>mouse when used over Microsoft Remote Desktop.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_WarpMouseInWindow</para>
        /// </remarks>
        public static int WarpMouseGlobal(float x, float y)
        {
            var ___ret = __Internal.WarpMouseGlobal(x, y);
            return ___ret;
        }

        /// <summary>Set relative mouse mode.</summary>
        /// <param name="enabled">SDL_TRUE to enable relative mode, SDL_FALSE to disable.</param>
        /// <remarks>
        /// <para>While the mouse is in relative mode, the cursor is hidden, the mouse</para>
        /// <para>position is constrained to the window, and SDL will report continuous</para>
        /// <para>relative mouse motion even if the mouse is at the edge of the window.</para>
        /// <para>This function will flush any pending mouse motion.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetRelativeMouseMode</para>
        /// </remarks>
        public static int SetRelativeMouseMode(bool enabled)
        {
            var ___ret = __Internal.SetRelativeMouseMode(enabled);
            return ___ret;
        }

        /// <summary>Capture the mouse and to track input outside an SDL window.</summary>
        /// <param name="enabled">SDL_TRUE to enable capturing, SDL_FALSE to disable.</param>
        /// <remarks>
        /// <para>Capturing enables your app to obtain mouse events globally, instead of just</para>
        /// <para>within your window. Not all video targets support this function. When</para>
        /// <para>capturing is enabled, the current window will get all mouse events, but</para>
        /// <para>unlike relative mode, no change is made to the cursor and it is not</para>
        /// <para>restrained to your window.</para>
        /// <para>This function may also deny mouse input to other windows--both those in</para>
        /// <para>your application and others on the system--so you should use this function</para>
        /// <para>sparingly, and in small bursts. For example, you might want to track the</para>
        /// <para>mouse while the user is dragging something, until the user releases a mouse</para>
        /// <para>button. It is not recommended that you capture the mouse for long periods</para>
        /// <para>of time, such as the entire time your app is running. For that, you should</para>
        /// <para>probably use SDL_SetRelativeMouseMode() or SDL_SetWindowGrab(), depending</para>
        /// <para>on your goals.</para>
        /// <para>While captured, mouse events still report coordinates relative to the</para>
        /// <para>current (foreground) window, but those coordinates may be outside the</para>
        /// <para>bounds of the window (including negative values). Capturing is only allowed</para>
        /// <para>for the foreground window. If the window loses focus while capturing, the</para>
        /// <para>capture will be disabled automatically.</para>
        /// <para>While capturing is enabled, the current window will have the</para>
        /// <para>`SDL_WINDOW_MOUSE_CAPTURE` flag set.</para>
        /// <para>Please note that as of SDL 2.0.22, SDL will attempt to &quot;auto capture&quot; the</para>
        /// <para>mouse while the user is pressing a button; this is to try and make mouse</para>
        /// <para>behavior more consistent between platforms, and deal with the common case</para>
        /// <para>of a user dragging the mouse outside of the window. This means that if you</para>
        /// <para>are calling SDL_CaptureMouse() only to deal with this situation, you no</para>
        /// <para>longer have to (although it is safe to do so). If this causes problems for</para>
        /// <para>your app, you can disable auto capture by setting the</para>
        /// <para>`SDL_HINT_MOUSE_AUTO_CAPTURE` hint to zero.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetGlobalMouseState</para>
        /// </remarks>
        public static int CaptureMouse(bool enabled)
        {
            var ___ret = __Internal.CaptureMouse(enabled);
            return ___ret;
        }

        /// <summary>Query whether relative mouse mode is enabled.</summary>
        /// <remarks>
        /// <para>SDL_TRUE if relative mode is enabled or SDL_FALSE otherwise.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_SetRelativeMouseMode</para>
        /// </remarks>
        public static bool GetRelativeMouseMode()
        {
            var ___ret = __Internal.GetRelativeMouseMode();
            return ___ret;
        }

        /// <summary>Create a cursor using the specified bitmap data and mask (in MSB format).</summary>
        /// <param name="data">the color value for each pixel of the cursor</param>
        /// <param name="mask">the mask value for each pixel of the cursor</param>
        /// <param name="w">the width of the cursor</param>
        /// <param name="h">the height of the cursor</param>
        /// <param name="hot_x">
        /// <para>the X-axis location of the upper left corner of the cursor</para>
        /// <para>relative to the actual mouse position</para>
        /// </param>
        /// <param name="hot_y">
        /// <para>the Y-axis location of the upper left corner of the cursor</para>
        /// <para>relative to the actual mouse position</para>
        /// </param>
        /// <remarks>
        /// <para>`mask` has to be in MSB (Most Significant Bit) format.</para>
        /// <para>The cursor width (`w`) must be a multiple of 8 bits.</para>
        /// <para>The cursor is created in black and white according to the following:</para>
        /// <para>- data=0, mask=1: white</para>
        /// <para>- data=1, mask=1: black</para>
        /// <para>- data=0, mask=0: transparent</para>
        /// <para>- data=1, mask=0: inverted color if possible, black if not.</para>
        /// <para>Cursors created with this function must be freed with SDL_DestroyCursor().</para>
        /// <para>If you want to have a color cursor, or create your cursor from an</para>
        /// <para>SDL_Surface, you should use SDL_CreateColorCursor(). Alternately, you can</para>
        /// <para>hide the cursor and draw your own as part of your game's rendering, but it</para>
        /// <para>will be bound to the framerate.</para>
        /// <para>Also, since SDL 2.0.0, SDL_CreateSystemCursor() is available, which</para>
        /// <para>provides twelve readily available system cursors to pick from.</para>
        /// <para>a new cursor with the specified parameters on success or NULL on</para>
        /// <para>failure; call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_DestroyCursor</para>
        /// <para>SDL_SetCursor</para>
        /// </remarks>
        public static global::SDL3Sharp.Cursor CreateCursor(byte* data, byte* mask, int w, int h, int hot_x, int hot_y)
        {
            var ___ret = __Internal.CreateCursor(data, mask, w, h, hot_x, hot_y);
            var __result0 = global::SDL3Sharp.Cursor.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Create a color cursor.</summary>
        /// <param name="surface">an SDL_Surface structure representing the cursor image</param>
        /// <param name="hot_x">the x position of the cursor hot spot</param>
        /// <param name="hot_y">the y position of the cursor hot spot</param>
        /// <remarks>
        /// <para>the new cursor on success or NULL on failure; call SDL_GetError()</para>
        /// <para>for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateCursor</para>
        /// <para>SDL_DestroyCursor</para>
        /// </remarks>
        public static global::SDL3Sharp.Cursor CreateColorCursor(global::SDL3Sharp.Surface surface, int hot_x, int hot_y)
        {
            var __arg0 = surface is null ? __IntPtr.Zero : surface.__Instance;
            var ___ret = __Internal.CreateColorCursor(__arg0, hot_x, hot_y);
            var __result0 = global::SDL3Sharp.Cursor.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Create a system cursor.</summary>
        /// <param name="id">an SDL_SystemCursor enum value</param>
        /// <remarks>
        /// <para>a cursor on success or NULL on failure; call SDL_GetError() for</para>
        /// <para>more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_DestroyCursor</para>
        /// </remarks>
        public static global::SDL3Sharp.Cursor CreateSystemCursor(global::SDL3Sharp.SystemCursor id)
        {
            var ___ret = __Internal.CreateSystemCursor(id);
            var __result0 = global::SDL3Sharp.Cursor.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Set the active cursor.</summary>
        /// <param name="cursor">a cursor to make active</param>
        /// <remarks>
        /// <para>This function sets the currently active cursor to the specified one. If the</para>
        /// <para>cursor is currently visible, the change will be immediately represented on</para>
        /// <para>the display. SDL_SetCursor(NULL) can be used to force cursor redraw, if</para>
        /// <para>this is desired for any reason.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateCursor</para>
        /// <para>SDL_GetCursor</para>
        /// </remarks>
        public static int SetCursor(global::SDL3Sharp.Cursor cursor)
        {
            var __arg0 = cursor is null ? __IntPtr.Zero : cursor.__Instance;
            var ___ret = __Internal.SetCursor(__arg0);
            return ___ret;
        }

        /// <summary>Get the active cursor.</summary>
        /// <remarks>
        /// <para>This function returns a pointer to the current cursor which is owned by the</para>
        /// <para>library. It is not necessary to free the cursor with SDL_DestroyCursor().</para>
        /// <para>the active cursor or NULL if there is no mouse.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_SetCursor</para>
        /// </remarks>
        public static global::SDL3Sharp.Cursor GetCursor()
        {
            var ___ret = __Internal.GetCursor();
            var __result0 = global::SDL3Sharp.Cursor.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the default cursor.</summary>
        /// <remarks>
        /// <para>You do not have to call SDL_DestroyCursor() on the return value, but it is</para>
        /// <para>safe to do so.</para>
        /// <para>the default cursor on success or NULL on failure.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateSystemCursor</para>
        /// </remarks>
        public static global::SDL3Sharp.Cursor GetDefaultCursor()
        {
            var ___ret = __Internal.GetDefaultCursor();
            var __result0 = global::SDL3Sharp.Cursor.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Free a previously-created cursor.</summary>
        /// <param name="cursor">the cursor to free</param>
        /// <remarks>
        /// <para>Use this function to free cursor resources created with SDL_CreateCursor(),</para>
        /// <para>SDL_CreateColorCursor() or SDL_CreateSystemCursor().</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateColorCursor</para>
        /// <para>SDL_CreateCursor</para>
        /// <para>SDL_CreateSystemCursor</para>
        /// </remarks>
        public static void DestroyCursor(global::SDL3Sharp.Cursor cursor)
        {
            var __arg0 = cursor is null ? __IntPtr.Zero : cursor.__Instance;
            __Internal.DestroyCursor(__arg0);
        }

        /// <summary>Show the cursor.</summary>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CursorVisible</para>
        /// <para>SDL_HideCursor</para>
        /// </remarks>
        public static int ShowCursor()
        {
            var ___ret = __Internal.ShowCursor();
            return ___ret;
        }

        /// <summary>Hide the cursor.</summary>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CursorVisible</para>
        /// <para>SDL_ShowCursor</para>
        /// </remarks>
        public static int HideCursor()
        {
            var ___ret = __Internal.HideCursor();
            return ___ret;
        }

        /// <summary>Return whether the cursor is currently being shown.</summary>
        /// <remarks>
        /// <para>`SDL_TRUE` if the cursor is being shown, or `SDL_FALSE` if the</para>
        /// <para>cursor is hidden.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_HideCursor</para>
        /// <para>SDL_ShowCursor</para>
        /// </remarks>
        public static bool CursorVisible()
        {
            var ___ret = __Internal.CursorVisible();
            return ___ret;
        }
    }
}
