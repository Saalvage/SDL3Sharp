// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required
#pragma warning disable CS9084 // Struct member returns 'this' or other instance members by reference

namespace SDL3Sharp
{
    /// <summary>The SDL thread priority.</summary>
    /// <remarks>
    /// <para>SDL will make system changes as necessary in order to apply the thread priority.</para>
    /// <para>Code which attempts to control thread state related to priority should be aware</para>
    /// <para>that calling SDL_SetThreadPriority may alter such state.</para>
    /// <para>SDL_HINT_THREAD_PRIORITY_POLICY can be used to control aspects of this behavior.</para>
    /// <para>On many systems you require special privileges to set high or time critical priority.</para>
    /// </remarks>
    public enum ThreadPriority
    {
        Low = 0,
        Normal = 1,
        High = 2,
        TimeCritical = 3
    }

    /// <summary>The SDL thread priority.</summary>
    /// <remarks>
    /// <para>SDL will make system changes as necessary in order to apply the thread priority.</para>
    /// <para>Code which attempts to control thread state related to priority should be aware</para>
    /// <para>that calling SDL_SetThreadPriority may alter such state.</para>
    /// <para>SDL_HINT_THREAD_PRIORITY_POLICY can be used to control aspects of this behavior.</para>
    /// <para>On many systems you require special privileges to set high or time critical priority.</para>
    /// </remarks>
    /// <summary>The function passed to SDL_CreateThread().</summary>
    /// <param name="data">what was passed as `data` to SDL_CreateThread()</param>
    /// <remarks>a value that can be reported through SDL_WaitThread().</remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate int ThreadFunction(__IntPtr data);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate ulong PfnSDL_CurrentBeginThread(__IntPtr __0, uint __1, global::SDL3Sharp.Delegates.Func_uint___IntPtr func, __IntPtr __2, uint __3, uint* __4);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void PfnSDL_CurrentEndThread(uint code);

    public unsafe partial class Thread
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.Thread> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.Thread>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.Thread managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.Thread managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Thread __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Thread(native.ToPointer(), skipVTables);
        }

        internal static Thread __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Thread)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Thread __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Thread(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Thread(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Thread(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class SDL
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_CreateThread", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CreateThread(__IntPtr fn, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, __IntPtr data, __IntPtr pfnBeginThread, __IntPtr pfnEndThread);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_CreateThreadWithStackSize", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CreateThreadWithStackSize(__IntPtr fn, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, ulong stacksize, __IntPtr data, __IntPtr pfnBeginThread, __IntPtr pfnEndThread);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetThreadName", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetThreadName(__IntPtr thread);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetCurrentThreadID", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong GetCurrentThreadID();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetThreadID", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong GetThreadID(__IntPtr thread);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetThreadPriority", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetThreadPriority(global::SDL3Sharp.ThreadPriority priority);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_WaitThread", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void WaitThread(__IntPtr thread, int* status);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_DetachThread", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void DetachThread(__IntPtr thread);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_CreateTLS", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint CreateTLS();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetTLS", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetTLS(uint id);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetTLS", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetTLS(uint id, __IntPtr value, __IntPtr destructor);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_CleanupTLS", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void CleanupTLS();
        }

        public static global::SDL3Sharp.Thread CreateThread(global::SDL3Sharp.ThreadFunction fn, string name, __IntPtr data, global::SDL3Sharp.PfnSDL_CurrentBeginThread pfnBeginThread, global::SDL3Sharp.PfnSDL_CurrentEndThread pfnEndThread)
        {
            var __arg0 = fn == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(fn);
            var __arg3 = pfnBeginThread == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(pfnBeginThread);
            var __arg4 = pfnEndThread == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(pfnEndThread);
            var ___ret = __Internal.CreateThread(__arg0, name, data, __arg3, __arg4);
            var __result0 = global::SDL3Sharp.Thread.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::SDL3Sharp.Thread CreateThreadWithStackSize(global::SDL3Sharp.ThreadFunction fn, string name, ulong stacksize, __IntPtr data, global::SDL3Sharp.PfnSDL_CurrentBeginThread pfnBeginThread, global::SDL3Sharp.PfnSDL_CurrentEndThread pfnEndThread)
        {
            var __arg0 = fn == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(fn);
            var __arg4 = pfnBeginThread == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(pfnBeginThread);
            var __arg5 = pfnEndThread == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(pfnEndThread);
            var ___ret = __Internal.CreateThreadWithStackSize(__arg0, name, stacksize, data, __arg4, __arg5);
            var __result0 = global::SDL3Sharp.Thread.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the thread name as it was specified in SDL_CreateThread().</summary>
        /// <param name="thread">the thread to query</param>
        /// <remarks>
        /// <para>This is internal memory, not to be freed by the caller, and remains valid</para>
        /// <para>until the specified thread is cleaned up by SDL_WaitThread().</para>
        /// <para>a pointer to a UTF-8 string that names the specified thread, or</para>
        /// <para>NULL if it doesn't have a name.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateThread</para>
        /// </remarks>
        public static string GetThreadName(global::SDL3Sharp.Thread thread)
        {
            var __arg0 = thread is null ? __IntPtr.Zero : thread.__Instance;
            var ___ret = __Internal.GetThreadName(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Get the thread identifier for the current thread.</summary>
        /// <remarks>
        /// <para>This thread identifier is as reported by the underlying operating system.</para>
        /// <para>If SDL is running on a platform that does not support threads the return</para>
        /// <para>value will always be zero.</para>
        /// <para>This function also returns a valid thread ID when called from the main</para>
        /// <para>thread.</para>
        /// <para>the ID of the current thread.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetThreadID</para>
        /// </remarks>
        public static ulong GetCurrentThreadID()
        {
            var ___ret = __Internal.GetCurrentThreadID();
            return ___ret;
        }

        /// <summary>Get the thread identifier for the specified thread.</summary>
        /// <param name="thread">the thread to query</param>
        /// <remarks>
        /// <para>This thread identifier is as reported by the underlying operating system.</para>
        /// <para>If SDL is running on a platform that does not support threads the return</para>
        /// <para>value will always be zero.</para>
        /// <para>the ID of the specified thread, or the ID of the current thread if</para>
        /// <para>`thread` is NULL.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetCurrentThreadID</para>
        /// </remarks>
        public static ulong GetThreadID(global::SDL3Sharp.Thread thread)
        {
            var __arg0 = thread is null ? __IntPtr.Zero : thread.__Instance;
            var ___ret = __Internal.GetThreadID(__arg0);
            return ___ret;
        }

        /// <summary>Set the priority for the current thread.</summary>
        /// <param name="priority">the SDL_ThreadPriority to set</param>
        /// <remarks>
        /// <para>Note that some platforms will not let you alter the priority (or at least,</para>
        /// <para>promote the thread to a higher priority) at all, and some require you to be</para>
        /// <para>an administrator account. Be prepared for this to fail.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int SetThreadPriority(global::SDL3Sharp.ThreadPriority priority)
        {
            var ___ret = __Internal.SetThreadPriority(priority);
            return ___ret;
        }

        /// <summary>Wait for a thread to finish.</summary>
        /// <param name="thread">
        /// <para>the SDL_Thread pointer that was returned from the</para>
        /// <para>SDL_CreateThread() call that started this thread</para>
        /// </param>
        /// <param name="status">
        /// <para>pointer to an integer that will receive the value returned</para>
        /// <para>from the thread function by its 'return', or NULL to not</para>
        /// <para>receive such value back.</para>
        /// </param>
        /// <remarks>
        /// <para>Threads that haven't been detached will remain (as a &quot;zombie&quot;) until this</para>
        /// <para>function cleans them up. Not doing so is a resource leak.</para>
        /// <para>Once a thread has been cleaned up through this function, the SDL_Thread</para>
        /// <para>that references it becomes invalid and should not be referenced again. As</para>
        /// <para>such, only one thread may call SDL_WaitThread() on another.</para>
        /// <para>The return code for the thread function is placed in the area pointed to by</para>
        /// <para>`status`, if `status` is not NULL.</para>
        /// <para>You may not wait on a thread that has been used in a call to</para>
        /// <para>SDL_DetachThread(). Use either that function or this one, but not both, or</para>
        /// <para>behavior is undefined.</para>
        /// <para>It is safe to pass a NULL thread to this function; it is a no-op.</para>
        /// <para>Note that the thread pointer is freed by this function and is not valid</para>
        /// <para>afterward.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateThread</para>
        /// <para>SDL_DetachThread</para>
        /// </remarks>
        public static void WaitThread(global::SDL3Sharp.Thread thread, ref int status)
        {
            var __arg0 = thread is null ? __IntPtr.Zero : thread.__Instance;
            fixed (int* __status1 = &status)
            {
                var __arg1 = __status1;
                __Internal.WaitThread(__arg0, __arg1);
            }
        }

        /// <summary>Let a thread clean up on exit without intervention.</summary>
        /// <param name="thread">
        /// <para>the SDL_Thread pointer that was returned from the</para>
        /// <para>SDL_CreateThread() call that started this thread</para>
        /// </param>
        /// <remarks>
        /// <para>A thread may be &quot;detached&quot; to signify that it should not remain until</para>
        /// <para>another thread has called SDL_WaitThread() on it. Detaching a thread is</para>
        /// <para>useful for long-running threads that nothing needs to synchronize with or</para>
        /// <para>further manage. When a detached thread is done, it simply goes away.</para>
        /// <para>There is no way to recover the return code of a detached thread. If you</para>
        /// <para>need this, don't detach the thread and instead use SDL_WaitThread().</para>
        /// <para>Once a thread is detached, you should usually assume the SDL_Thread isn't</para>
        /// <para>safe to reference again, as it will become invalid immediately upon the</para>
        /// <para>detached thread's exit, instead of remaining until someone has called</para>
        /// <para>SDL_WaitThread() to finally clean it up. As such, don't detach the same</para>
        /// <para>thread more than once.</para>
        /// <para>If a thread has already exited when passed to SDL_DetachThread(), it will</para>
        /// <para>stop waiting for a call to SDL_WaitThread() and clean up immediately. It is</para>
        /// <para>not safe to detach a thread that might be used with SDL_WaitThread().</para>
        /// <para>You may not call SDL_WaitThread() on a thread that has been detached. Use</para>
        /// <para>either that function or this one, but not both, or behavior is undefined.</para>
        /// <para>It is safe to pass NULL to this function; it is a no-op.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateThread</para>
        /// <para>SDL_WaitThread</para>
        /// </remarks>
        public static void DetachThread(global::SDL3Sharp.Thread thread)
        {
            var __arg0 = thread is null ? __IntPtr.Zero : thread.__Instance;
            __Internal.DetachThread(__arg0);
        }

        /// <summary>Create a piece of thread-local storage.</summary>
        /// <remarks>
        /// <para>This creates an identifier that is globally visible to all threads but</para>
        /// <para>refers to data that is thread-specific.</para>
        /// <para>the newly created thread local storage identifier or 0 on error.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetTLS</para>
        /// <para>SDL_SetTLS</para>
        /// </remarks>
        public static uint CreateTLS()
        {
            var ___ret = __Internal.CreateTLS();
            return ___ret;
        }

        /// <summary>Get the current thread's value associated with a thread local storage ID.</summary>
        /// <param name="id">the thread local storage ID</param>
        /// <remarks>
        /// <para>the value associated with the ID for the current thread or NULL if</para>
        /// <para>no value has been set; call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateTLS</para>
        /// <para>SDL_SetTLS</para>
        /// </remarks>
        public static __IntPtr GetTLS(uint id)
        {
            var ___ret = __Internal.GetTLS(id);
            return ___ret;
        }

        /// <summary>Set the current thread's value associated with a thread local storage ID.</summary>
        /// <param name="id">the thread local storage ID</param>
        /// <param name="value">the value to associate with the ID for the current thread</param>
        /// <param name="destructor">
        /// <para>a function called when the thread exits, to free the</para>
        /// <para>value</para>
        /// </param>
        /// <remarks>
        /// <para>The function prototype for `destructor` is:</para>
        /// <para>```c</para>
        /// <para>void destructor(void *value)</para>
        /// <para>```</para>
        /// <para>where its parameter `value` is what was passed as `value` to SDL_SetTLS().</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateTLS</para>
        /// <para>SDL_GetTLS</para>
        /// </remarks>
        public static int SetTLS(uint id, __IntPtr value, global::SDL3Sharp.Delegates.Action___IntPtr destructor)
        {
            var __arg2 = destructor == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(destructor);
            var ___ret = __Internal.SetTLS(id, value, __arg2);
            return ___ret;
        }

        /// <summary>Cleanup all TLS data for this thread.</summary>
        /// <remarks>This function is available since SDL 3.0.0.</remarks>
        public static void CleanupTLS()
        {
            __Internal.CleanupTLS();
        }
    }
}
