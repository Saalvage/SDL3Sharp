// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required
#pragma warning disable CS9084 // Struct member returns 'this' or other instance members by reference

namespace SDL3Sharp
{
    public enum JoystickType
    {
        Unknown = 0,
        Gamepad = 1,
        Wheel = 2,
        ArcadeStick = 3,
        FlightStick = 4,
        DancePad = 5,
        Guitar = 6,
        DrumKit = 7,
        ArcadePad = 8,
        Throttle = 9
    }

    public enum JoystickPowerLevel
    {
        Unknown = -1,
        Empty = 0,
        Low = 1,
        Medium = 2,
        Full = 3,
        Wired = 4,
        Max = 5
    }

    /// <summary>
    /// <para>This is a unique ID for a joystick for the time it is connected to the system,</para>
    /// <para>and is never reused for the lifetime of the application. If the joystick is</para>
    /// <para>disconnected and reconnected, it will get a new ID.</para>
    /// </summary>
    /// <remarks>The ID value starts at 1 and increments from there. The value 0 is an invalid ID.</remarks>
    /// <summary>The structure that defines an extended virtual joystick description</summary>
    /// <remarks>
    /// <para>The caller must zero the structure and then initialize the version with `SDL_VIRTUAL_JOYSTICK_DESC_VERSION` before passing it to SDL_AttachVirtualJoystickEx()</para>
    /// <para>All other elements of this structure are optional and can be left 0.</para>
    /// <para>SDL_AttachVirtualJoystickEx</para>
    /// </remarks>
    public unsafe partial class Joystick
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.Joystick> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.Joystick>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.Joystick managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.Joystick managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Joystick __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Joystick(native.ToPointer(), skipVTables);
        }

        internal static Joystick __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Joystick)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Joystick __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Joystick(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Joystick(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Joystick(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    /// <summary>The structure that defines an extended virtual joystick description</summary>
    /// <remarks>
    /// <para>The caller must zero the structure and then initialize the version with `SDL_VIRTUAL_JOYSTICK_DESC_VERSION` before passing it to SDL_AttachVirtualJoystickEx()</para>
    /// <para>All other elements of this structure are optional and can be left 0.</para>
    /// <para>SDL_AttachVirtualJoystickEx</para>
    /// </remarks>
    public unsafe partial class VirtualJoystickDesc : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 88, Pack = 8)]
        public partial struct __Internal
        {
            internal ushort version;
            internal ushort type;
            internal ushort naxes;
            internal ushort nbuttons;
            internal ushort nhats;
            internal ushort vendor_id;
            internal ushort product_id;
            internal ushort padding;
            internal uint button_mask;
            internal uint axis_mask;
            internal __IntPtr name;
            internal __IntPtr userdata;
            internal __IntPtr Update;
            internal __IntPtr SetPlayerIndex;
            internal __IntPtr Rumble;
            internal __IntPtr RumbleTriggers;
            internal __IntPtr SetLED;
            internal __IntPtr SendEffect;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_VirtualJoystickDesc@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.VirtualJoystickDesc> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.VirtualJoystickDesc>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.VirtualJoystickDesc managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.VirtualJoystickDesc managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        private bool __name_OwnsNativeMemory = false;
        protected bool __ownsNativeInstance;

        internal static VirtualJoystickDesc __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new VirtualJoystickDesc(native.ToPointer(), skipVTables);
        }

        internal static VirtualJoystickDesc __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VirtualJoystickDesc)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VirtualJoystickDesc __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VirtualJoystickDesc(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VirtualJoystickDesc(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected VirtualJoystickDesc(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public VirtualJoystickDesc()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.VirtualJoystickDesc.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VirtualJoystickDesc(global::SDL3Sharp.VirtualJoystickDesc _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.VirtualJoystickDesc.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.VirtualJoystickDesc.__Internal*) __Instance) = *((global::SDL3Sharp.VirtualJoystickDesc.__Internal*) _0.__Instance);
            if (_0.__name_OwnsNativeMemory)
                this.Name = _0.Name;
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__name_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->name);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>`SDL_VIRTUAL_JOYSTICK_DESC_VERSION`</summary>
        public ushort Version
        {
            get
            {
                return ((__Internal*)__Instance)->version;
            }

            set
            {
                ((__Internal*)__Instance)->version = value;
            }
        }

        /// <summary>`SDL_JoystickType`</summary>
        public ushort Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        /// <summary>the number of axes on this joystick</summary>
        public ushort Naxes
        {
            get
            {
                return ((__Internal*)__Instance)->naxes;
            }

            set
            {
                ((__Internal*)__Instance)->naxes = value;
            }
        }

        /// <summary>the number of buttons on this joystick</summary>
        public ushort Nbuttons
        {
            get
            {
                return ((__Internal*)__Instance)->nbuttons;
            }

            set
            {
                ((__Internal*)__Instance)->nbuttons = value;
            }
        }

        /// <summary>the number of hats on this joystick</summary>
        public ushort Nhats
        {
            get
            {
                return ((__Internal*)__Instance)->nhats;
            }

            set
            {
                ((__Internal*)__Instance)->nhats = value;
            }
        }

        /// <summary>the USB vendor ID of this joystick</summary>
        public ushort VendorId
        {
            get
            {
                return ((__Internal*)__Instance)->vendor_id;
            }

            set
            {
                ((__Internal*)__Instance)->vendor_id = value;
            }
        }

        /// <summary>the USB product ID of this joystick</summary>
        public ushort ProductId
        {
            get
            {
                return ((__Internal*)__Instance)->product_id;
            }

            set
            {
                ((__Internal*)__Instance)->product_id = value;
            }
        }

        /// <summary>unused</summary>
        public ushort Padding
        {
            get
            {
                return ((__Internal*)__Instance)->padding;
            }

            set
            {
                ((__Internal*)__Instance)->padding = value;
            }
        }

        /// <summary>
        /// <para>A mask of which buttons are valid for this controller</para>
        /// <para>e.g. (1&lt;&lt;SDL_GAMEPAD_BUTTON_SOUTH)</para>
        /// </summary>
        public uint ButtonMask
        {
            get
            {
                return ((__Internal*)__Instance)->button_mask;
            }

            set
            {
                ((__Internal*)__Instance)->button_mask = value;
            }
        }

        /// <summary>
        /// <para>A mask of which axes are valid for this controller</para>
        /// <para>e.g. (1&lt;&lt;SDL_GAMEPAD_AXIS_LEFTX)</para>
        /// </summary>
        public uint AxisMask
        {
            get
            {
                return ((__Internal*)__Instance)->axis_mask;
            }

            set
            {
                ((__Internal*)__Instance)->axis_mask = value;
            }
        }

        /// <summary>the name of the joystick</summary>
        public string Name
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->name);
            }

            set
            {
                if (__name_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->name);
                __name_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->name = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->name = (__IntPtr) __bytePtr0;
            }
        }

        /// <summary>User data pointer passed to callbacks</summary>
        public __IntPtr Userdata
        {
            get
            {
                return ((__Internal*)__Instance)->userdata;
            }

            set
            {
                ((__Internal*)__Instance)->userdata = (__IntPtr) value;
            }
        }

        /// <summary>Called when the joystick state should be updated</summary>
        public global::SDL3Sharp.Delegates.Action___IntPtr Update
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Update;
                return __ptr0 == IntPtr.Zero? null : (global::SDL3Sharp.Delegates.Action___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::SDL3Sharp.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->Update = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Called when the player index is set</summary>
        public global::SDL3Sharp.Delegates.Action___IntPtr_int SetPlayerIndex
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->SetPlayerIndex;
                return __ptr0 == IntPtr.Zero? null : (global::SDL3Sharp.Delegates.Action___IntPtr_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::SDL3Sharp.Delegates.Action___IntPtr_int));
            }

            set
            {
                ((__Internal*)__Instance)->SetPlayerIndex = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Implements SDL_RumbleJoystick()</summary>
        public global::SDL3Sharp.Delegates.Func_int___IntPtr_ushort_ushort Rumble
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Rumble;
                return __ptr0 == IntPtr.Zero? null : (global::SDL3Sharp.Delegates.Func_int___IntPtr_ushort_ushort) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::SDL3Sharp.Delegates.Func_int___IntPtr_ushort_ushort));
            }

            set
            {
                ((__Internal*)__Instance)->Rumble = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Implements SDL_RumbleJoystickTriggers()</summary>
        public global::SDL3Sharp.Delegates.Func_int___IntPtr_ushort_ushort RumbleTriggers
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->RumbleTriggers;
                return __ptr0 == IntPtr.Zero? null : (global::SDL3Sharp.Delegates.Func_int___IntPtr_ushort_ushort) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::SDL3Sharp.Delegates.Func_int___IntPtr_ushort_ushort));
            }

            set
            {
                ((__Internal*)__Instance)->RumbleTriggers = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Implements SDL_SetJoystickLED()</summary>
        public global::SDL3Sharp.Delegates.Func_int___IntPtr_byte_byte_byte SetLED
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->SetLED;
                return __ptr0 == IntPtr.Zero? null : (global::SDL3Sharp.Delegates.Func_int___IntPtr_byte_byte_byte) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::SDL3Sharp.Delegates.Func_int___IntPtr_byte_byte_byte));
            }

            set
            {
                ((__Internal*)__Instance)->SetLED = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Implements SDL_SendJoystickEffect()</summary>
        public global::SDL3Sharp.Delegates.Func_int___IntPtr___IntPtr_int SendEffect
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->SendEffect;
                return __ptr0 == IntPtr.Zero? null : (global::SDL3Sharp.Delegates.Func_int___IntPtr___IntPtr_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::SDL3Sharp.Delegates.Func_int___IntPtr___IntPtr_int));
            }

            set
            {
                ((__Internal*)__Instance)->SendEffect = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class SDL
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_LockJoysticks", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LockJoysticks();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_UnlockJoysticks", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UnlockJoysticks();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetJoysticks", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint* GetJoysticks(int* count);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetJoystickInstanceName", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetJoystickInstanceName(uint instance_id);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetJoystickInstancePath", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetJoystickInstancePath(uint instance_id);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetJoystickInstancePlayerIndex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetJoystickInstancePlayerIndex(uint instance_id);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetJoystickInstanceGUID", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GetJoystickInstanceGUID(__IntPtr @return, uint instance_id);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetJoystickInstanceVendor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ushort GetJoystickInstanceVendor(uint instance_id);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetJoystickInstanceProduct", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ushort GetJoystickInstanceProduct(uint instance_id);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetJoystickInstanceProductVersion", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ushort GetJoystickInstanceProductVersion(uint instance_id);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetJoystickInstanceType", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::SDL3Sharp.JoystickType GetJoystickInstanceType(uint instance_id);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_OpenJoystick", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr OpenJoystick(uint instance_id);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetJoystickFromInstanceID", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetJoystickFromInstanceID(uint instance_id);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetJoystickFromPlayerIndex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetJoystickFromPlayerIndex(int player_index);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_AttachVirtualJoystick", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint AttachVirtualJoystick(global::SDL3Sharp.JoystickType type, int naxes, int nbuttons, int nhats);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_AttachVirtualJoystickEx", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint AttachVirtualJoystickEx(__IntPtr desc);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_DetachVirtualJoystick", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int DetachVirtualJoystick(uint instance_id);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_IsJoystickVirtual", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool IsJoystickVirtual(uint instance_id);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetJoystickVirtualAxis", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetJoystickVirtualAxis(__IntPtr joystick, int axis, short value);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetJoystickVirtualButton", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetJoystickVirtualButton(__IntPtr joystick, int button, byte value);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetJoystickVirtualHat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetJoystickVirtualHat(__IntPtr joystick, int hat, byte value);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetJoystickProperties", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint GetJoystickProperties(__IntPtr joystick);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetJoystickName", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetJoystickName(__IntPtr joystick);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetJoystickPath", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetJoystickPath(__IntPtr joystick);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetJoystickPlayerIndex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetJoystickPlayerIndex(__IntPtr joystick);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetJoystickPlayerIndex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetJoystickPlayerIndex(__IntPtr joystick, int player_index);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetJoystickGUID", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::SDL3Sharp.GUID.__Internal GetJoystickGUID(__IntPtr joystick);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetJoystickVendor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ushort GetJoystickVendor(__IntPtr joystick);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetJoystickProduct", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ushort GetJoystickProduct(__IntPtr joystick);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetJoystickProductVersion", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ushort GetJoystickProductVersion(__IntPtr joystick);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetJoystickFirmwareVersion", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ushort GetJoystickFirmwareVersion(__IntPtr joystick);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetJoystickSerial", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetJoystickSerial(__IntPtr joystick);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetJoystickType", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::SDL3Sharp.JoystickType GetJoystickType(__IntPtr joystick);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetJoystickGUIDString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetJoystickGUIDString(__IntPtr guid, sbyte* pszGUID, int cbGUID);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetJoystickGUIDFromString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GetJoystickGUIDFromString(__IntPtr @return, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string pchGUID);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetJoystickGUIDInfo", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GetJoystickGUIDInfo(__IntPtr guid, ushort* vendor, ushort* product, ushort* version, ushort* crc16);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_JoystickConnected", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool JoystickConnected(__IntPtr joystick);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetJoystickInstanceID", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint GetJoystickInstanceID(__IntPtr joystick);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetNumJoystickAxes", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetNumJoystickAxes(__IntPtr joystick);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetNumJoystickHats", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetNumJoystickHats(__IntPtr joystick);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetNumJoystickButtons", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetNumJoystickButtons(__IntPtr joystick);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetJoystickEventsEnabled", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetJoystickEventsEnabled(bool enabled);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_JoystickEventsEnabled", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool JoystickEventsEnabled();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_UpdateJoysticks", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UpdateJoysticks();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetJoystickAxis", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern short GetJoystickAxis(__IntPtr joystick, int axis);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetJoystickAxisInitialState", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool GetJoystickAxisInitialState(__IntPtr joystick, int axis, short* state);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetJoystickHat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte GetJoystickHat(__IntPtr joystick, int hat);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetJoystickButton", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte GetJoystickButton(__IntPtr joystick, int button);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_RumbleJoystick", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int RumbleJoystick(__IntPtr joystick, ushort low_frequency_rumble, ushort high_frequency_rumble, uint duration_ms);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_RumbleJoystickTriggers", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int RumbleJoystickTriggers(__IntPtr joystick, ushort left_rumble, ushort right_rumble, uint duration_ms);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetJoystickLED", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetJoystickLED(__IntPtr joystick, byte red, byte green, byte blue);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SendJoystickEffect", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SendJoystickEffect(__IntPtr joystick, __IntPtr data, int size);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_CloseJoystick", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void CloseJoystick(__IntPtr joystick);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetJoystickPowerLevel", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::SDL3Sharp.JoystickPowerLevel GetJoystickPowerLevel(__IntPtr joystick);
        }

        /// <summary>Locking for atomic access to the joystick API</summary>
        /// <remarks>
        /// <para>The SDL joystick functions are thread-safe, however you can lock the</para>
        /// <para>joysticks while processing to guarantee that the joystick list won't change</para>
        /// <para>and joystick and gamepad events will not be delivered.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static void LockJoysticks()
        {
            __Internal.LockJoysticks();
        }

        /// <summary>Unlocking for atomic access to the joystick API</summary>
        /// <remarks>This function is available since SDL 3.0.0.</remarks>
        public static void UnlockJoysticks()
        {
            __Internal.UnlockJoysticks();
        }

        /// <summary>Get a list of currently connected joysticks.</summary>
        /// <param name="count">a pointer filled in with the number of joysticks returned</param>
        /// <remarks>
        /// <para>a 0 terminated array of joystick instance IDs which should be</para>
        /// <para>freed with SDL_free(), or NULL on error; call SDL_GetError() for</para>
        /// <para>more details.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_OpenJoystick</para>
        /// </remarks>
        public static uint* GetJoysticks(out int count)
        {
            fixed (int* __count0 = &count)
            {
                var __arg0 = __count0;
                var ___ret = __Internal.GetJoysticks(__arg0);
                return ___ret;
            }
        }

        /// <summary>Get the implementation dependent name of a joystick.</summary>
        /// <param name="instance_id">the joystick instance ID</param>
        /// <remarks>
        /// <para>This can be called before any joysticks are opened.</para>
        /// <para>the name of the selected joystick. If no name can be found, this</para>
        /// <para>function returns NULL; call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetJoystickName</para>
        /// <para>SDL_OpenJoystick</para>
        /// </remarks>
        public static string GetJoystickInstanceName(uint instance_id)
        {
            var ___ret = __Internal.GetJoystickInstanceName(instance_id);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Get the implementation dependent path of a joystick.</summary>
        /// <param name="instance_id">the joystick instance ID</param>
        /// <remarks>
        /// <para>This can be called before any joysticks are opened.</para>
        /// <para>the path of the selected joystick. If no path can be found, this</para>
        /// <para>function returns NULL; call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetJoystickPath</para>
        /// <para>SDL_OpenJoystick</para>
        /// </remarks>
        public static string GetJoystickInstancePath(uint instance_id)
        {
            var ___ret = __Internal.GetJoystickInstancePath(instance_id);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Get the player index of a joystick.</summary>
        /// <param name="instance_id">the joystick instance ID</param>
        /// <remarks>
        /// <para>This can be called before any joysticks are opened.</para>
        /// <para>the player index of a joystick, or -1 if it's not available</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetJoystickPlayerIndex</para>
        /// <para>SDL_OpenJoystick</para>
        /// </remarks>
        public static int GetJoystickInstancePlayerIndex(uint instance_id)
        {
            var ___ret = __Internal.GetJoystickInstancePlayerIndex(instance_id);
            return ___ret;
        }

        /// <summary>Get the implementation-dependent GUID of a joystick.</summary>
        /// <param name="instance_id">the joystick instance ID</param>
        /// <remarks>
        /// <para>This can be called before any joysticks are opened.</para>
        /// <para>the GUID of the selected joystick. If called on an invalid index,</para>
        /// <para>this function returns a zero GUID</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetJoystickGUID</para>
        /// <para>SDL_GetJoystickGUIDString</para>
        /// </remarks>
        public static global::SDL3Sharp.GUID GetJoystickInstanceGUID(uint instance_id)
        {
            var ___ret = new global::SDL3Sharp.GUID.__Internal();
            __Internal.GetJoystickInstanceGUID(new IntPtr(&___ret), instance_id);
            return global::SDL3Sharp.GUID.__CreateInstance(___ret);
        }

        /// <summary>Get the USB vendor ID of a joystick, if available.</summary>
        /// <param name="instance_id">the joystick instance ID</param>
        /// <remarks>
        /// <para>This can be called before any joysticks are opened. If the vendor ID isn't</para>
        /// <para>available this function returns 0.</para>
        /// <para>the USB vendor ID of the selected joystick. If called on an</para>
        /// <para>invalid index, this function returns zero</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static ushort GetJoystickInstanceVendor(uint instance_id)
        {
            var ___ret = __Internal.GetJoystickInstanceVendor(instance_id);
            return ___ret;
        }

        /// <summary>Get the USB product ID of a joystick, if available.</summary>
        /// <param name="instance_id">the joystick instance ID</param>
        /// <remarks>
        /// <para>This can be called before any joysticks are opened. If the product ID isn't</para>
        /// <para>available this function returns 0.</para>
        /// <para>the USB product ID of the selected joystick. If called on an</para>
        /// <para>invalid index, this function returns zero</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static ushort GetJoystickInstanceProduct(uint instance_id)
        {
            var ___ret = __Internal.GetJoystickInstanceProduct(instance_id);
            return ___ret;
        }

        /// <summary>Get the product version of a joystick, if available.</summary>
        /// <param name="instance_id">the joystick instance ID</param>
        /// <remarks>
        /// <para>This can be called before any joysticks are opened. If the product version</para>
        /// <para>isn't available this function returns 0.</para>
        /// <para>the product version of the selected joystick. If called on an</para>
        /// <para>invalid index, this function returns zero</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static ushort GetJoystickInstanceProductVersion(uint instance_id)
        {
            var ___ret = __Internal.GetJoystickInstanceProductVersion(instance_id);
            return ___ret;
        }

        /// <summary>Get the type of a joystick, if available.</summary>
        /// <param name="instance_id">the joystick instance ID</param>
        /// <remarks>
        /// <para>This can be called before any joysticks are opened.</para>
        /// <para>the SDL_JoystickType of the selected joystick. If called on an</para>
        /// <para>invalid index, this function returns `SDL_JOYSTICK_TYPE_UNKNOWN`</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static global::SDL3Sharp.JoystickType GetJoystickInstanceType(uint instance_id)
        {
            var ___ret = __Internal.GetJoystickInstanceType(instance_id);
            return ___ret;
        }

        /// <summary>Open a joystick for use.</summary>
        /// <param name="instance_id">the joystick instance ID</param>
        /// <remarks>
        /// <para>The joystick subsystem must be initialized before a joystick can be opened</para>
        /// <para>for use.</para>
        /// <para>a joystick identifier or NULL if an error occurred; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CloseJoystick</para>
        /// </remarks>
        public static global::SDL3Sharp.Joystick OpenJoystick(uint instance_id)
        {
            var ___ret = __Internal.OpenJoystick(instance_id);
            var __result0 = global::SDL3Sharp.Joystick.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the SDL_Joystick associated with an instance ID, if it has been opened.</summary>
        /// <param name="instance_id">the instance ID to get the SDL_Joystick for</param>
        /// <remarks>
        /// <para>an SDL_Joystick on success or NULL on failure or if it hasn't been</para>
        /// <para>opened yet; call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static global::SDL3Sharp.Joystick GetJoystickFromInstanceID(uint instance_id)
        {
            var ___ret = __Internal.GetJoystickFromInstanceID(instance_id);
            var __result0 = global::SDL3Sharp.Joystick.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the SDL_Joystick associated with a player index.</summary>
        /// <param name="player_index">the player index to get the SDL_Joystick for</param>
        /// <remarks>
        /// <para>an SDL_Joystick on success or NULL on failure; call SDL_GetError()</para>
        /// <para>for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static global::SDL3Sharp.Joystick GetJoystickFromPlayerIndex(int player_index)
        {
            var ___ret = __Internal.GetJoystickFromPlayerIndex(player_index);
            var __result0 = global::SDL3Sharp.Joystick.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Attach a new virtual joystick.</summary>
        /// <param name="type">type of joystick</param>
        /// <param name="naxes">number of axes</param>
        /// <param name="nbuttons">number of buttons</param>
        /// <param name="nhats">number of hats</param>
        /// <remarks>
        /// <para>the joystick instance ID, or 0 if an error occurred; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static uint AttachVirtualJoystick(global::SDL3Sharp.JoystickType type, int naxes, int nbuttons, int nhats)
        {
            var ___ret = __Internal.AttachVirtualJoystick(type, naxes, nbuttons, nhats);
            return ___ret;
        }

        /// <summary>Attach a new virtual joystick with extended properties.</summary>
        /// <param name="desc">Joystick description</param>
        /// <remarks>
        /// <para>the joystick instance ID, or 0 if an error occurred; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static uint AttachVirtualJoystickEx(global::SDL3Sharp.VirtualJoystickDesc desc)
        {
            var __arg0 = desc is null ? __IntPtr.Zero : desc.__Instance;
            var ___ret = __Internal.AttachVirtualJoystickEx(__arg0);
            return ___ret;
        }

        /// <summary>Detach a virtual joystick.</summary>
        /// <param name="instance_id">
        /// <para>the joystick instance ID, previously returned from</para>
        /// <para>SDL_AttachVirtualJoystick()</para>
        /// </param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int DetachVirtualJoystick(uint instance_id)
        {
            var ___ret = __Internal.DetachVirtualJoystick(instance_id);
            return ___ret;
        }

        /// <summary>Query whether or not a joystick is virtual.</summary>
        /// <param name="instance_id">the joystick instance ID</param>
        /// <remarks>
        /// <para>SDL_TRUE if the joystick is virtual, SDL_FALSE otherwise.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static bool IsJoystickVirtual(uint instance_id)
        {
            var ___ret = __Internal.IsJoystickVirtual(instance_id);
            return ___ret;
        }

        /// <summary>Set values on an opened, virtual-joystick's axis.</summary>
        /// <param name="joystick">the virtual joystick on which to set state.</param>
        /// <param name="axis">the specific axis on the virtual joystick to set.</param>
        /// <param name="value">the new value for the specified axis.</param>
        /// <remarks>
        /// <para>Please note that values set here will not be applied until the next call to</para>
        /// <para>SDL_UpdateJoysticks, which can either be called directly, or can be called</para>
        /// <para>indirectly through various other SDL APIs, including, but not limited to</para>
        /// <para>the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,</para>
        /// <para>SDL_WaitEvent.</para>
        /// <para>Note that when sending trigger axes, you should scale the value to the full</para>
        /// <para>range of Sint16. For example, a trigger at rest would have the value of</para>
        /// <para>`SDL_JOYSTICK_AXIS_MIN`.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int SetJoystickVirtualAxis(global::SDL3Sharp.Joystick joystick, int axis, short value)
        {
            var __arg0 = joystick is null ? __IntPtr.Zero : joystick.__Instance;
            var ___ret = __Internal.SetJoystickVirtualAxis(__arg0, axis, value);
            return ___ret;
        }

        /// <summary>Set values on an opened, virtual-joystick's button.</summary>
        /// <param name="joystick">the virtual joystick on which to set state.</param>
        /// <param name="button">the specific button on the virtual joystick to set.</param>
        /// <param name="value">the new value for the specified button.</param>
        /// <remarks>
        /// <para>Please note that values set here will not be applied until the next call to</para>
        /// <para>SDL_UpdateJoysticks, which can either be called directly, or can be called</para>
        /// <para>indirectly through various other SDL APIs, including, but not limited to</para>
        /// <para>the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,</para>
        /// <para>SDL_WaitEvent.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int SetJoystickVirtualButton(global::SDL3Sharp.Joystick joystick, int button, byte value)
        {
            var __arg0 = joystick is null ? __IntPtr.Zero : joystick.__Instance;
            var ___ret = __Internal.SetJoystickVirtualButton(__arg0, button, value);
            return ___ret;
        }

        /// <summary>Set values on an opened, virtual-joystick's hat.</summary>
        /// <param name="joystick">the virtual joystick on which to set state.</param>
        /// <param name="hat">the specific hat on the virtual joystick to set.</param>
        /// <param name="value">the new value for the specified hat.</param>
        /// <remarks>
        /// <para>Please note that values set here will not be applied until the next call to</para>
        /// <para>SDL_UpdateJoysticks, which can either be called directly, or can be called</para>
        /// <para>indirectly through various other SDL APIs, including, but not limited to</para>
        /// <para>the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,</para>
        /// <para>SDL_WaitEvent.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int SetJoystickVirtualHat(global::SDL3Sharp.Joystick joystick, int hat, byte value)
        {
            var __arg0 = joystick is null ? __IntPtr.Zero : joystick.__Instance;
            var ___ret = __Internal.SetJoystickVirtualHat(__arg0, hat, value);
            return ___ret;
        }

        /// <summary>Get the properties associated with a joystick.</summary>
        /// <param name="joystick">the SDL_Joystick obtained from SDL_OpenJoystick()</param>
        /// <remarks>
        /// <para>The following read-only properties are provided by SDL:</para>
        /// <para>- `SDL_PROP_JOYSTICK_CAP_MONO_LED_BOOLEAN`: true if this joystick has an</para>
        /// <para>LED that has adjustable brightness</para>
        /// <para>- `SDL_PROP_JOYSTICK_CAP_RGB_LED_BOOLEAN`: true if this joystick has an LED</para>
        /// <para>that has adjustable color</para>
        /// <para>- `SDL_PROP_JOYSTICK_CAP_PLAYER_LED_BOOLEAN`: true if this joystick has a</para>
        /// <para>player LED</para>
        /// <para>- `SDL_PROP_JOYSTICK_CAP_RUMBLE_BOOLEAN`: true if this joystick has</para>
        /// <para>left/right rumble</para>
        /// <para>- `SDL_PROP_JOYSTICK_CAP_TRIGGER_RUMBLE_BOOLEAN`: true if this joystick has</para>
        /// <para>simple trigger rumble</para>
        /// <para>a valid property ID on success or 0 on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetProperty</para>
        /// <para>SDL_SetProperty</para>
        /// </remarks>
        public static uint GetJoystickProperties(global::SDL3Sharp.Joystick joystick)
        {
            var __arg0 = joystick is null ? __IntPtr.Zero : joystick.__Instance;
            var ___ret = __Internal.GetJoystickProperties(__arg0);
            return ___ret;
        }

        /// <summary>Get the implementation dependent name of a joystick.</summary>
        /// <param name="joystick">the SDL_Joystick obtained from SDL_OpenJoystick()</param>
        /// <remarks>
        /// <para>the name of the selected joystick. If no name can be found, this</para>
        /// <para>function returns NULL; call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetJoystickInstanceName</para>
        /// <para>SDL_OpenJoystick</para>
        /// </remarks>
        public static string GetJoystickName(global::SDL3Sharp.Joystick joystick)
        {
            var __arg0 = joystick is null ? __IntPtr.Zero : joystick.__Instance;
            var ___ret = __Internal.GetJoystickName(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Get the implementation dependent path of a joystick.</summary>
        /// <param name="joystick">the SDL_Joystick obtained from SDL_OpenJoystick()</param>
        /// <remarks>
        /// <para>the path of the selected joystick. If no path can be found, this</para>
        /// <para>function returns NULL; call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetJoystickInstancePath</para>
        /// </remarks>
        public static string GetJoystickPath(global::SDL3Sharp.Joystick joystick)
        {
            var __arg0 = joystick is null ? __IntPtr.Zero : joystick.__Instance;
            var ___ret = __Internal.GetJoystickPath(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Get the player index of an opened joystick.</summary>
        /// <param name="joystick">the SDL_Joystick obtained from SDL_OpenJoystick()</param>
        /// <remarks>
        /// <para>For XInput controllers this returns the XInput user index. Many joysticks</para>
        /// <para>will not be able to supply this information.</para>
        /// <para>the player index, or -1 if it's not available.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int GetJoystickPlayerIndex(global::SDL3Sharp.Joystick joystick)
        {
            var __arg0 = joystick is null ? __IntPtr.Zero : joystick.__Instance;
            var ___ret = __Internal.GetJoystickPlayerIndex(__arg0);
            return ___ret;
        }

        /// <summary>Set the player index of an opened joystick.</summary>
        /// <param name="joystick">the SDL_Joystick obtained from SDL_OpenJoystick()</param>
        /// <param name="player_index">
        /// <para>Player index to assign to this joystick, or -1 to clear</para>
        /// <para>the player index and turn off player LEDs.</para>
        /// </param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int SetJoystickPlayerIndex(global::SDL3Sharp.Joystick joystick, int player_index)
        {
            var __arg0 = joystick is null ? __IntPtr.Zero : joystick.__Instance;
            var ___ret = __Internal.SetJoystickPlayerIndex(__arg0, player_index);
            return ___ret;
        }

        /// <summary>Get the implementation-dependent GUID for the joystick.</summary>
        /// <param name="joystick">the SDL_Joystick obtained from SDL_OpenJoystick()</param>
        /// <remarks>
        /// <para>This function requires an open joystick.</para>
        /// <para>the GUID of the given joystick. If called on an invalid index,</para>
        /// <para>this function returns a zero GUID; call SDL_GetError() for more</para>
        /// <para>information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetJoystickInstanceGUID</para>
        /// <para>SDL_GetJoystickGUIDString</para>
        /// </remarks>
        public static global::SDL3Sharp.GUID GetJoystickGUID(global::SDL3Sharp.Joystick joystick)
        {
            var __arg0 = joystick is null ? __IntPtr.Zero : joystick.__Instance;
            var ___ret = __Internal.GetJoystickGUID(__arg0);
            return global::SDL3Sharp.GUID.__CreateInstance(___ret);
        }

        /// <summary>Get the USB vendor ID of an opened joystick, if available.</summary>
        /// <param name="joystick">the SDL_Joystick obtained from SDL_OpenJoystick()</param>
        /// <remarks>
        /// <para>If the vendor ID isn't available this function returns 0.</para>
        /// <para>the USB vendor ID of the selected joystick, or 0 if unavailable.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static ushort GetJoystickVendor(global::SDL3Sharp.Joystick joystick)
        {
            var __arg0 = joystick is null ? __IntPtr.Zero : joystick.__Instance;
            var ___ret = __Internal.GetJoystickVendor(__arg0);
            return ___ret;
        }

        /// <summary>Get the USB product ID of an opened joystick, if available.</summary>
        /// <param name="joystick">the SDL_Joystick obtained from SDL_OpenJoystick()</param>
        /// <remarks>
        /// <para>If the product ID isn't available this function returns 0.</para>
        /// <para>the USB product ID of the selected joystick, or 0 if unavailable.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static ushort GetJoystickProduct(global::SDL3Sharp.Joystick joystick)
        {
            var __arg0 = joystick is null ? __IntPtr.Zero : joystick.__Instance;
            var ___ret = __Internal.GetJoystickProduct(__arg0);
            return ___ret;
        }

        /// <summary>Get the product version of an opened joystick, if available.</summary>
        /// <param name="joystick">the SDL_Joystick obtained from SDL_OpenJoystick()</param>
        /// <remarks>
        /// <para>If the product version isn't available this function returns 0.</para>
        /// <para>the product version of the selected joystick, or 0 if unavailable.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static ushort GetJoystickProductVersion(global::SDL3Sharp.Joystick joystick)
        {
            var __arg0 = joystick is null ? __IntPtr.Zero : joystick.__Instance;
            var ___ret = __Internal.GetJoystickProductVersion(__arg0);
            return ___ret;
        }

        /// <summary>Get the firmware version of an opened joystick, if available.</summary>
        /// <param name="joystick">the SDL_Joystick obtained from SDL_OpenJoystick()</param>
        /// <remarks>
        /// <para>If the firmware version isn't available this function returns 0.</para>
        /// <para>the firmware version of the selected joystick, or 0 if</para>
        /// <para>unavailable.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static ushort GetJoystickFirmwareVersion(global::SDL3Sharp.Joystick joystick)
        {
            var __arg0 = joystick is null ? __IntPtr.Zero : joystick.__Instance;
            var ___ret = __Internal.GetJoystickFirmwareVersion(__arg0);
            return ___ret;
        }

        /// <summary>Get the serial number of an opened joystick, if available.</summary>
        /// <param name="joystick">the SDL_Joystick obtained from SDL_OpenJoystick()</param>
        /// <remarks>
        /// <para>Returns the serial number of the joystick, or NULL if it is not available.</para>
        /// <para>the serial number of the selected joystick, or NULL if</para>
        /// <para>unavailable.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static string GetJoystickSerial(global::SDL3Sharp.Joystick joystick)
        {
            var __arg0 = joystick is null ? __IntPtr.Zero : joystick.__Instance;
            var ___ret = __Internal.GetJoystickSerial(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Get the type of an opened joystick.</summary>
        /// <param name="joystick">the SDL_Joystick obtained from SDL_OpenJoystick()</param>
        /// <remarks>
        /// <para>the SDL_JoystickType of the selected joystick.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static global::SDL3Sharp.JoystickType GetJoystickType(global::SDL3Sharp.Joystick joystick)
        {
            var __arg0 = joystick is null ? __IntPtr.Zero : joystick.__Instance;
            var ___ret = __Internal.GetJoystickType(__arg0);
            return ___ret;
        }

        /// <summary>Get an ASCII string representation for a given SDL_JoystickGUID.</summary>
        /// <param name="guid">the SDL_JoystickGUID you wish to convert to string</param>
        /// <param name="pszGUID">buffer in which to write the ASCII string</param>
        /// <param name="cbGUID">the size of pszGUID</param>
        /// <remarks>
        /// <para>You should supply at least 33 bytes for pszGUID.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetJoystickInstanceGUID</para>
        /// <para>SDL_GetJoystickGUID</para>
        /// <para>SDL_GetJoystickGUIDFromString</para>
        /// </remarks>
        public static int GetJoystickGUIDString(global::SDL3Sharp.GUID guid, sbyte* pszGUID, int cbGUID)
        {
            if (ReferenceEquals(guid, null))
                throw new global::System.ArgumentNullException("guid", "Cannot be null because it is passed by value.");
            var __arg0 = guid.__Instance;
            var ___ret = __Internal.GetJoystickGUIDString(__arg0, pszGUID, cbGUID);
            return ___ret;
        }

        /// <summary>Convert a GUID string into a SDL_JoystickGUID structure.</summary>
        /// <param name="pchGUID">string containing an ASCII representation of a GUID</param>
        /// <remarks>
        /// <para>Performs no error checking. If this function is given a string containing</para>
        /// <para>an invalid GUID, the function will silently succeed, but the GUID generated</para>
        /// <para>will not be useful.</para>
        /// <para>a SDL_JoystickGUID structure.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetJoystickGUIDString</para>
        /// </remarks>
        public static global::SDL3Sharp.GUID GetJoystickGUIDFromString(string pchGUID)
        {
            var ___ret = new global::SDL3Sharp.GUID.__Internal();
            __Internal.GetJoystickGUIDFromString(new IntPtr(&___ret), pchGUID);
            return global::SDL3Sharp.GUID.__CreateInstance(___ret);
        }

        /// <summary>Get the device information encoded in a SDL_JoystickGUID structure</summary>
        /// <param name="guid">the SDL_JoystickGUID you wish to get info about</param>
        /// <param name="vendor">
        /// <para>A pointer filled in with the device VID, or 0 if not</para>
        /// <para>available</para>
        /// </param>
        /// <param name="product">
        /// <para>A pointer filled in with the device PID, or 0 if not</para>
        /// <para>available</para>
        /// </param>
        /// <param name="version">
        /// <para>A pointer filled in with the device version, or 0 if not</para>
        /// <para>available</para>
        /// </param>
        /// <param name="crc16">
        /// <para>A pointer filled in with a CRC used to distinguish different</para>
        /// <para>products with the same VID/PID, or 0 if not available</para>
        /// </param>
        /// <remarks>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetJoystickInstanceGUID</para>
        /// </remarks>
        public static void GetJoystickGUIDInfo(global::SDL3Sharp.GUID guid, ref ushort vendor, ref ushort product, ref ushort version, ref ushort crc16)
        {
            if (ReferenceEquals(guid, null))
                throw new global::System.ArgumentNullException("guid", "Cannot be null because it is passed by value.");
            var __arg0 = guid.__Instance;
            fixed (ushort* __vendor1 = &vendor)
            {
                var __arg1 = __vendor1;
                fixed (ushort* __product2 = &product)
                {
                    var __arg2 = __product2;
                    fixed (ushort* __version3 = &version)
                    {
                        var __arg3 = __version3;
                        fixed (ushort* __crc164 = &crc16)
                        {
                            var __arg4 = __crc164;
                            __Internal.GetJoystickGUIDInfo(__arg0, __arg1, __arg2, __arg3, __arg4);
                        }
                    }
                }
            }
        }

        /// <summary>Get the status of a specified joystick.</summary>
        /// <param name="joystick">the joystick to query</param>
        /// <remarks>
        /// <para>SDL_TRUE if the joystick has been opened, SDL_FALSE if it has not;</para>
        /// <para>call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CloseJoystick</para>
        /// <para>SDL_OpenJoystick</para>
        /// </remarks>
        public static bool JoystickConnected(global::SDL3Sharp.Joystick joystick)
        {
            var __arg0 = joystick is null ? __IntPtr.Zero : joystick.__Instance;
            var ___ret = __Internal.JoystickConnected(__arg0);
            return ___ret;
        }

        /// <summary>Get the instance ID of an opened joystick.</summary>
        /// <param name="joystick">an SDL_Joystick structure containing joystick information</param>
        /// <remarks>
        /// <para>the instance ID of the specified joystick on success or 0 on</para>
        /// <para>failure; call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_OpenJoystick</para>
        /// </remarks>
        public static uint GetJoystickInstanceID(global::SDL3Sharp.Joystick joystick)
        {
            var __arg0 = joystick is null ? __IntPtr.Zero : joystick.__Instance;
            var ___ret = __Internal.GetJoystickInstanceID(__arg0);
            return ___ret;
        }

        /// <summary>Get the number of general axis controls on a joystick.</summary>
        /// <param name="joystick">an SDL_Joystick structure containing joystick information</param>
        /// <remarks>
        /// <para>Often, the directional pad on a game controller will either look like 4</para>
        /// <para>separate buttons or a POV hat, and not axes, but all of this is up to the</para>
        /// <para>device and platform.</para>
        /// <para>the number of axis controls/number of axes on success or a</para>
        /// <para>negative error code on failure; call SDL_GetError() for more</para>
        /// <para>information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetJoystickAxis</para>
        /// <para>SDL_OpenJoystick</para>
        /// </remarks>
        public static int GetNumJoystickAxes(global::SDL3Sharp.Joystick joystick)
        {
            var __arg0 = joystick is null ? __IntPtr.Zero : joystick.__Instance;
            var ___ret = __Internal.GetNumJoystickAxes(__arg0);
            return ___ret;
        }

        /// <summary>Get the number of POV hats on a joystick.</summary>
        /// <param name="joystick">an SDL_Joystick structure containing joystick information</param>
        /// <remarks>
        /// <para>the number of POV hats on success or a negative error code on</para>
        /// <para>failure; call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetJoystickHat</para>
        /// <para>SDL_OpenJoystick</para>
        /// </remarks>
        public static int GetNumJoystickHats(global::SDL3Sharp.Joystick joystick)
        {
            var __arg0 = joystick is null ? __IntPtr.Zero : joystick.__Instance;
            var ___ret = __Internal.GetNumJoystickHats(__arg0);
            return ___ret;
        }

        /// <summary>Get the number of buttons on a joystick.</summary>
        /// <param name="joystick">an SDL_Joystick structure containing joystick information</param>
        /// <remarks>
        /// <para>the number of buttons on success or a negative error code on</para>
        /// <para>failure; call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetJoystickButton</para>
        /// <para>SDL_OpenJoystick</para>
        /// </remarks>
        public static int GetNumJoystickButtons(global::SDL3Sharp.Joystick joystick)
        {
            var __arg0 = joystick is null ? __IntPtr.Zero : joystick.__Instance;
            var ___ret = __Internal.GetNumJoystickButtons(__arg0);
            return ___ret;
        }

        /// <summary>Set the state of joystick event processing.</summary>
        /// <param name="enabled">whether to process joystick events or not</param>
        /// <remarks>
        /// <para>If joystick events are disabled, you must call SDL_UpdateJoysticks()</para>
        /// <para>yourself and check the state of the joystick when you want joystick</para>
        /// <para>information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_JoystickEventsEnabled</para>
        /// </remarks>
        public static void SetJoystickEventsEnabled(bool enabled)
        {
            __Internal.SetJoystickEventsEnabled(enabled);
        }

        /// <summary>Query the state of joystick event processing.</summary>
        /// <remarks>
        /// <para>If joystick events are disabled, you must call SDL_UpdateJoysticks()</para>
        /// <para>yourself and check the state of the joystick when you want joystick</para>
        /// <para>information.</para>
        /// <para>SDL_TRUE if joystick events are being processed, SDL_FALSE</para>
        /// <para>otherwise.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_SetJoystickEventsEnabled</para>
        /// </remarks>
        public static bool JoystickEventsEnabled()
        {
            var ___ret = __Internal.JoystickEventsEnabled();
            return ___ret;
        }

        /// <summary>Update the current state of the open joysticks.</summary>
        /// <remarks>
        /// <para>This is called automatically by the event loop if any joystick events are</para>
        /// <para>enabled.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static void UpdateJoysticks()
        {
            __Internal.UpdateJoysticks();
        }

        /// <summary>Get the current state of an axis control on a joystick.</summary>
        /// <param name="joystick">an SDL_Joystick structure containing joystick information</param>
        /// <param name="axis">the axis to query; the axis indices start at index 0</param>
        /// <remarks>
        /// <para>SDL makes no promises about what part of the joystick any given axis refers</para>
        /// <para>to. Your game should have some sort of configuration UI to let users</para>
        /// <para>specify what each axis should be bound to. Alternately, SDL's higher-level</para>
        /// <para>Game Controller API makes a great effort to apply order to this lower-level</para>
        /// <para>interface, so you know that a specific axis is the &quot;left thumb stick,&quot; etc.</para>
        /// <para>The value returned by SDL_GetJoystickAxis() is a signed integer (-32768 to</para>
        /// <para>32767) representing the current position of the axis. It may be necessary</para>
        /// <para>to impose certain tolerances on these values to account for jitter.</para>
        /// <para>a 16-bit signed integer representing the current position of the</para>
        /// <para>axis or 0 on failure; call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetNumJoystickAxes</para>
        /// </remarks>
        public static short GetJoystickAxis(global::SDL3Sharp.Joystick joystick, int axis)
        {
            var __arg0 = joystick is null ? __IntPtr.Zero : joystick.__Instance;
            var ___ret = __Internal.GetJoystickAxis(__arg0, axis);
            return ___ret;
        }

        /// <summary>Get the initial state of an axis control on a joystick.</summary>
        /// <param name="joystick">an SDL_Joystick structure containing joystick information</param>
        /// <param name="axis">the axis to query; the axis indices start at index 0</param>
        /// <param name="state">Upon return, the initial value is supplied here.</param>
        /// <remarks>
        /// <para>The state is a value ranging from -32768 to 32767.</para>
        /// <para>The axis indices start at index 0.</para>
        /// <para>SDL_TRUE if this axis has any initial value, or SDL_FALSE if not.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static bool GetJoystickAxisInitialState(global::SDL3Sharp.Joystick joystick, int axis, ref short state)
        {
            var __arg0 = joystick is null ? __IntPtr.Zero : joystick.__Instance;
            fixed (short* __state2 = &state)
            {
                var __arg2 = __state2;
                var ___ret = __Internal.GetJoystickAxisInitialState(__arg0, axis, __arg2);
                return ___ret;
            }
        }

        /// <summary>Get the current state of a POV hat on a joystick.</summary>
        /// <param name="joystick">an SDL_Joystick structure containing joystick information</param>
        /// <param name="hat">the hat index to get the state from; indices start at index 0</param>
        /// <remarks>
        /// <para>The returned value will be one of the following positions:</para>
        /// <para>- `SDL_HAT_CENTERED`</para>
        /// <para>- `SDL_HAT_UP`</para>
        /// <para>- `SDL_HAT_RIGHT`</para>
        /// <para>- `SDL_HAT_DOWN`</para>
        /// <para>- `SDL_HAT_LEFT`</para>
        /// <para>- `SDL_HAT_RIGHTUP`</para>
        /// <para>- `SDL_HAT_RIGHTDOWN`</para>
        /// <para>- `SDL_HAT_LEFTUP`</para>
        /// <para>- `SDL_HAT_LEFTDOWN`</para>
        /// <para>the current hat position.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetNumJoystickHats</para>
        /// </remarks>
        public static byte GetJoystickHat(global::SDL3Sharp.Joystick joystick, int hat)
        {
            var __arg0 = joystick is null ? __IntPtr.Zero : joystick.__Instance;
            var ___ret = __Internal.GetJoystickHat(__arg0, hat);
            return ___ret;
        }

        /// <summary>Get the current state of a button on a joystick.</summary>
        /// <param name="joystick">an SDL_Joystick structure containing joystick information</param>
        /// <param name="button">
        /// <para>the button index to get the state from; indices start at</para>
        /// <para>index 0</para>
        /// </param>
        /// <remarks>
        /// <para>1 if the specified button is pressed, 0 otherwise.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetNumJoystickButtons</para>
        /// </remarks>
        public static byte GetJoystickButton(global::SDL3Sharp.Joystick joystick, int button)
        {
            var __arg0 = joystick is null ? __IntPtr.Zero : joystick.__Instance;
            var ___ret = __Internal.GetJoystickButton(__arg0, button);
            return ___ret;
        }

        /// <summary>Start a rumble effect.</summary>
        /// <param name="joystick">The joystick to vibrate</param>
        /// <param name="low_frequency_rumble">
        /// <para>The intensity of the low frequency (left)</para>
        /// <para>rumble motor, from 0 to 0xFFFF</para>
        /// </param>
        /// <param name="high_frequency_rumble">
        /// <para>The intensity of the high frequency (right)</para>
        /// <para>rumble motor, from 0 to 0xFFFF</para>
        /// </param>
        /// <param name="duration_ms">The duration of the rumble effect, in milliseconds</param>
        /// <remarks>
        /// <para>Each call to this function cancels any previous rumble effect, and calling</para>
        /// <para>it with 0 intensity stops any rumbling.</para>
        /// <para>This function requires you to process SDL events or call</para>
        /// <para>SDL_UpdateJoysticks() to update rumble state.</para>
        /// <para>0, or -1 if rumble isn't supported on this joystick</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int RumbleJoystick(global::SDL3Sharp.Joystick joystick, ushort low_frequency_rumble, ushort high_frequency_rumble, uint duration_ms)
        {
            var __arg0 = joystick is null ? __IntPtr.Zero : joystick.__Instance;
            var ___ret = __Internal.RumbleJoystick(__arg0, low_frequency_rumble, high_frequency_rumble, duration_ms);
            return ___ret;
        }

        /// <summary>Start a rumble effect in the joystick's triggers</summary>
        /// <param name="joystick">The joystick to vibrate</param>
        /// <param name="left_rumble">
        /// <para>The intensity of the left trigger rumble motor, from 0</para>
        /// <para>to 0xFFFF</para>
        /// </param>
        /// <param name="right_rumble">
        /// <para>The intensity of the right trigger rumble motor, from 0</para>
        /// <para>to 0xFFFF</para>
        /// </param>
        /// <param name="duration_ms">The duration of the rumble effect, in milliseconds</param>
        /// <remarks>
        /// <para>Each call to this function cancels any previous trigger rumble effect, and</para>
        /// <para>calling it with 0 intensity stops any rumbling.</para>
        /// <para>Note that this is rumbling of the _triggers_ and not the game controller as</para>
        /// <para>a whole. This is currently only supported on Xbox One controllers. If you</para>
        /// <para>want the (more common) whole-controller rumble, use SDL_RumbleJoystick()</para>
        /// <para>instead.</para>
        /// <para>This function requires you to process SDL events or call</para>
        /// <para>SDL_UpdateJoysticks() to update rumble state.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int RumbleJoystickTriggers(global::SDL3Sharp.Joystick joystick, ushort left_rumble, ushort right_rumble, uint duration_ms)
        {
            var __arg0 = joystick is null ? __IntPtr.Zero : joystick.__Instance;
            var ___ret = __Internal.RumbleJoystickTriggers(__arg0, left_rumble, right_rumble, duration_ms);
            return ___ret;
        }

        /// <summary>Update a joystick's LED color.</summary>
        /// <param name="joystick">The joystick to update</param>
        /// <param name="red">The intensity of the red LED</param>
        /// <param name="green">The intensity of the green LED</param>
        /// <param name="blue">The intensity of the blue LED</param>
        /// <remarks>
        /// <para>An example of a joystick LED is the light on the back of a PlayStation 4's</para>
        /// <para>DualShock 4 controller.</para>
        /// <para>For joysticks with a single color LED, the maximum of the RGB values will</para>
        /// <para>be used as the LED brightness.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int SetJoystickLED(global::SDL3Sharp.Joystick joystick, byte red, byte green, byte blue)
        {
            var __arg0 = joystick is null ? __IntPtr.Zero : joystick.__Instance;
            var ___ret = __Internal.SetJoystickLED(__arg0, red, green, blue);
            return ___ret;
        }

        /// <summary>Send a joystick specific effect packet</summary>
        /// <param name="joystick">The joystick to affect</param>
        /// <param name="data">The data to send to the joystick</param>
        /// <param name="size">The size of the data to send to the joystick</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int SendJoystickEffect(global::SDL3Sharp.Joystick joystick, __IntPtr data, int size)
        {
            var __arg0 = joystick is null ? __IntPtr.Zero : joystick.__Instance;
            var ___ret = __Internal.SendJoystickEffect(__arg0, data, size);
            return ___ret;
        }

        /// <summary>Close a joystick previously opened with SDL_OpenJoystick().</summary>
        /// <param name="joystick">The joystick device to close</param>
        /// <remarks>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_OpenJoystick</para>
        /// </remarks>
        public static void CloseJoystick(global::SDL3Sharp.Joystick joystick)
        {
            var __arg0 = joystick is null ? __IntPtr.Zero : joystick.__Instance;
            __Internal.CloseJoystick(__arg0);
        }

        /// <summary>Get the battery level of a joystick as SDL_JoystickPowerLevel.</summary>
        /// <param name="joystick">the SDL_Joystick to query</param>
        /// <remarks>
        /// <para>the current battery level as SDL_JoystickPowerLevel on success or</para>
        /// <para>`SDL_JOYSTICK_POWER_UNKNOWN` if it is unknown</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static global::SDL3Sharp.JoystickPowerLevel GetJoystickPowerLevel(global::SDL3Sharp.Joystick joystick)
        {
            var __arg0 = joystick is null ? __IntPtr.Zero : joystick.__Instance;
            var ___ret = __Internal.GetJoystickPowerLevel(__arg0);
            return ___ret;
        }
    }
}
