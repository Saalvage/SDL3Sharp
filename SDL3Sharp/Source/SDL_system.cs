// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required
#pragma warning disable CS9084 // Struct member returns 'this' or other instance members by reference

namespace SDL3Sharp
{
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate bool WindowsMessageHook(__IntPtr userdata, __IntPtr msg);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate bool X11EventHook(__IntPtr userdata, __IntPtr xevent);

    public unsafe partial class TagMSG
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.TagMSG> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.TagMSG>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.TagMSG managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.TagMSG managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static TagMSG __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new TagMSG(native.ToPointer(), skipVTables);
        }

        internal static TagMSG __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (TagMSG)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static TagMSG __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new TagMSG(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private TagMSG(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected TagMSG(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class XEvent
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.XEvent> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.XEvent>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.XEvent managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.XEvent managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static XEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new XEvent(native.ToPointer(), skipVTables);
        }

        internal static XEvent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (XEvent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static XEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new XEvent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private XEvent(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected XEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class SDL
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetWindowsMessageHook", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetWindowsMessageHook(__IntPtr callback, __IntPtr userdata);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_Direct3D9GetAdapterIndex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int Direct3D9GetAdapterIndex(uint displayID);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_DXGIGetOutputInfo", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool DXGIGetOutputInfo(uint displayID, int* adapterIndex, int* outputIndex);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetX11EventHook", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetX11EventHook(__IntPtr callback, __IntPtr userdata);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_IsTablet", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool IsTablet();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_OnApplicationWillTerminate", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void OnApplicationWillTerminate();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_OnApplicationDidReceiveMemoryWarning", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void OnApplicationDidReceiveMemoryWarning();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_OnApplicationWillResignActive", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void OnApplicationWillResignActive();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_OnApplicationDidEnterBackground", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void OnApplicationDidEnterBackground();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_OnApplicationWillEnterForeground", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void OnApplicationWillEnterForeground();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_OnApplicationDidBecomeActive", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void OnApplicationDidBecomeActive();
        }

        /// <summary>Set a callback for every Windows message, run before TranslateMessage().</summary>
        /// <param name="callback">The SDL_WindowsMessageHook function to call.</param>
        /// <param name="userdata">a pointer to pass to every iteration of `callback`</param>
        /// <remarks>
        /// <para>The callback may modify the message, and should return SDL_TRUE if the</para>
        /// <para>message should continue to be processed, or SDL_FALSE to prevent further</para>
        /// <para>processing.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static void SetWindowsMessageHook(global::SDL3Sharp.WindowsMessageHook callback, __IntPtr userdata)
        {
            var __arg0 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            __Internal.SetWindowsMessageHook(__arg0, userdata);
        }

        /// <summary>Get the D3D9 adapter index that matches the specified display.</summary>
        /// <param name="displayID">the instance of the display to query</param>
        /// <remarks>
        /// <para>The returned adapter index can be passed to `IDirect3D9::CreateDevice` and</para>
        /// <para>controls on which monitor a full screen application will appear.</para>
        /// <para>the D3D9 adapter index on success or a negative error code on</para>
        /// <para>failure; call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int Direct3D9GetAdapterIndex(uint displayID)
        {
            var ___ret = __Internal.Direct3D9GetAdapterIndex(displayID);
            return ___ret;
        }

        /// <summary>Get the DXGI Adapter and Output indices for the specified display.</summary>
        /// <param name="displayID">the instance of the display to query</param>
        /// <param name="adapterIndex">a pointer to be filled in with the adapter index</param>
        /// <param name="outputIndex">a pointer to be filled in with the output index</param>
        /// <remarks>
        /// <para>The DXGI Adapter and Output indices can be passed to `EnumAdapters` and</para>
        /// <para>`EnumOutputs` respectively to get the objects required to create a DX10 or</para>
        /// <para>DX11 device and swap chain.</para>
        /// <para>SDL_TRUE on success or SDL_FALSE on failure; call SDL_GetError()</para>
        /// <para>for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static bool DXGIGetOutputInfo(uint displayID, ref int adapterIndex, ref int outputIndex)
        {
            fixed (int* __adapterIndex1 = &adapterIndex)
            {
                var __arg1 = __adapterIndex1;
                fixed (int* __outputIndex2 = &outputIndex)
                {
                    var __arg2 = __outputIndex2;
                    var ___ret = __Internal.DXGIGetOutputInfo(displayID, __arg1, __arg2);
                    return ___ret;
                }
            }
        }

        /// <summary>Set a callback for every X11 event</summary>
        /// <param name="callback">The SDL_X11EventHook function to call.</param>
        /// <param name="userdata">a pointer to pass to every iteration of `callback`</param>
        /// <remarks>
        /// <para>The callback may modify the event, and should return SDL_TRUE if the event</para>
        /// <para>should continue to be processed, or SDL_FALSE to prevent further</para>
        /// <para>processing.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static void SetX11EventHook(global::SDL3Sharp.X11EventHook callback, __IntPtr userdata)
        {
            var __arg0 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            __Internal.SetX11EventHook(__arg0, userdata);
        }

        /// <summary>Query if the current device is a tablet.</summary>
        /// <remarks>
        /// <para>If SDL can't determine this, it will return SDL_FALSE.</para>
        /// <para>SDL_TRUE if the device is a tablet, SDL_FALSE otherwise.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static bool IsTablet()
        {
            var ___ret = __Internal.IsTablet();
            return ___ret;
        }

        public static void OnApplicationWillTerminate()
        {
            __Internal.OnApplicationWillTerminate();
        }

        public static void OnApplicationDidReceiveMemoryWarning()
        {
            __Internal.OnApplicationDidReceiveMemoryWarning();
        }

        public static void OnApplicationWillResignActive()
        {
            __Internal.OnApplicationWillResignActive();
        }

        public static void OnApplicationDidEnterBackground()
        {
            __Internal.OnApplicationDidEnterBackground();
        }

        public static void OnApplicationWillEnterForeground()
        {
            __Internal.OnApplicationWillEnterForeground();
        }

        public static void OnApplicationDidBecomeActive()
        {
            __Internal.OnApplicationDidBecomeActive();
        }
    }
}
