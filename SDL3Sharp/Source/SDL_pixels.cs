// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required
#pragma warning disable CS9084 // Struct member returns 'this' or other instance members by reference

namespace SDL3Sharp
{
    /// <summary>Pixel type.</summary>
    public enum PixelType
    {
        Unknown = 0,
        Index1 = 1,
        Index4 = 2,
        Index8 = 3,
        Packed8 = 4,
        Packed16 = 5,
        Packed32 = 6,
        Arrayu8 = 7,
        Arrayu16 = 8,
        Arrayu32 = 9,
        Arrayf16 = 10,
        Arrayf32 = 11,
        Index2 = 12
    }

    /// <summary>Bitmap pixel order, high bit -&gt; low bit.</summary>
    public enum BitmapOrder
    {
        None = 0,
        _4321 = 1,
        _1234 = 2
    }

    /// <summary>Packed component order, high bit -&gt; low bit.</summary>
    public enum PackedOrder
    {
        None = 0,
        Xrgb = 1,
        Rgbx = 2,
        Argb = 3,
        Rgba = 4,
        Xbgr = 5,
        Bgrx = 6,
        Abgr = 7,
        Bgra = 8
    }

    /// <summary>Array component order, low byte -&gt; high byte.</summary>
    public enum ArrayOrder
    {
        None = 0,
        Rgb = 1,
        Rgba = 2,
        Argb = 3,
        Bgr = 4,
        Bgra = 5,
        Abgr = 6
    }

    /// <summary>Packed component layout.</summary>
    public enum PackedLayout
    {
        None = 0,
        _332 = 1,
        _4444 = 2,
        _1555 = 3,
        _5551 = 4,
        _565 = 5,
        _8888 = 6,
        _2101010 = 7,
        _1010102 = 8
    }

    public enum PixelFormatEnum
    {
        Unknown = 0,
        Index1lsb = 286261504,
        Index1msb = 287310080,
        Index2lsb = 470811136,
        Index2msb = 471859712,
        Index4lsb = 303039488,
        Index4msb = 304088064,
        Index8 = 318769153,
        Rgb332 = 336660481,
        Xrgb4444 = 353504258,
        Rgb444 = 353504258,
        Xbgr4444 = 357698562,
        Bgr444 = 357698562,
        Xrgb1555 = 353570562,
        Rgb555 = 353570562,
        Xbgr1555 = 357764866,
        Bgr555 = 357764866,
        Argb4444 = 355602434,
        Rgba4444 = 356651010,
        Abgr4444 = 359796738,
        Bgra4444 = 360845314,
        Argb1555 = 355667970,
        Rgba5551 = 356782082,
        Abgr1555 = 359862274,
        Bgra5551 = 360976386,
        Rgb565 = 353701890,
        Bgr565 = 357896194,
        Rgb24 = 386930691,
        Bgr24 = 390076419,
        Xrgb8888 = 370546692,
        Rgbx8888 = 371595268,
        Xbgr8888 = 374740996,
        Bgrx8888 = 375789572,
        Argb8888 = 372645892,
        Rgba8888 = 373694468,
        Abgr8888 = 376840196,
        Bgra8888 = 377888772,
        Xrgb2101010 = 370614276,
        Xbgr2101010 = 374808580,
        Argb2101010 = 372711428,
        Abgr2101010 = 376905732,
        Rgb48 = 403714054,
        Bgr48 = 406859782,
        Rgba64 = 404766728,
        Argb64 = 405815304,
        Bgra64 = 407912456,
        Abgr64 = 408961032,
        Rgb48Float = 437268486,
        Bgr48Float = 440414214,
        Rgba64Float = 438321160,
        Argb64Float = 439369736,
        Bgra64Float = 441466888,
        Abgr64Float = 442515464,
        Rgb96Float = 454057996,
        Bgr96Float = 457203724,
        Rgba128Float = 455114768,
        Argb128Float = 456163344,
        Bgra128Float = 458260496,
        Abgr128Float = 459309072,
        Rgba32 = 376840196,
        Argb32 = 377888772,
        Bgra32 = 372645892,
        Abgr32 = 373694468,
        Rgbx32 = 374740996,
        Xrgb32 = 375789572,
        Bgrx32 = 370546692,
        Xbgr32 = 371595268,
        /// <summary>Planar mode: Y + V + U  (3 planes)</summary>
        Yv12 = 842094169,
        /// <summary>Planar mode: Y + U + V  (3 planes)</summary>
        Iyuv = 1448433993,
        /// <summary>Packed mode: Y0+U0+Y1+V0 (1 plane)</summary>
        Yuy2 = 844715353,
        /// <summary>Packed mode: U0+Y0+V0+Y1 (1 plane)</summary>
        Uyvy = 1498831189,
        /// <summary>Packed mode: Y0+V0+Y1+U0 (1 plane)</summary>
        Yvyu = 1431918169,
        /// <summary>Planar mode: Y + U/V interleaved  (2 planes)</summary>
        Nv12 = 842094158,
        /// <summary>Planar mode: Y + V/U interleaved  (2 planes)</summary>
        Nv21 = 825382478,
        /// <summary>Planar mode: Y + U/V interleaved  (2 planes)</summary>
        P010 = 808530000,
        /// <summary>Android video texture format</summary>
        ExternalOes = 542328143
    }

    /// <summary>The color type</summary>
    public enum ColorType
    {
        Unknown = 0,
        Rgb = 1,
        Ycbcr = 2
    }

    /// <summary>The color range, as described by https://www.itu.int/rec/R-REC-BT.2100-2-201807-I/en</summary>
    public enum ColorRange
    {
        Unknown = 0,
        /// <summary>Narrow range, e.g. 16-235 for 8-bit RGB and luma, and 16-240 for 8-bit chroma</summary>
        Limited = 1,
        /// <summary>Full range, e.g. 0-255 for 8-bit RGB and luma, and 1-255 for 8-bit chroma</summary>
        Full = 2
    }

    /// <summary>The color primaries, as described by https://www.itu.int/rec/T-REC-H.273-201612-S/en</summary>
    public enum ColorPrimaries
    {
        Unknown = 0,
        /// <summary>ITU-R BT.709-6</summary>
        Bt709 = 1,
        Unspecified = 2,
        /// <summary>ITU-R BT.470-6 System M</summary>
        Bt470m = 4,
        /// <summary>ITU-R BT.470-6 System B, G / ITU-R BT.601-7 625</summary>
        Bt470bg = 5,
        /// <summary>ITU-R BT.601-7 525</summary>
        Bt601 = 6,
        /// <summary>SMPTE 240M, functionally the same as SDL_COLOR_PRIMARIES_BT601</summary>
        Smpte240 = 7,
        /// <summary>Generic film (color filters using Illuminant C)</summary>
        GenericFilm = 8,
        /// <summary>ITU-R BT.2020-2 / ITU-R BT.2100-0</summary>
        Bt2020 = 9,
        /// <summary>SMPTE ST 428-1</summary>
        Xyz = 10,
        /// <summary>SMPTE RP 431-2</summary>
        Smpte431 = 11,
        /// <summary>SMPTE EG 432-1 / DCI P3</summary>
        Smpte432 = 12,
        /// <summary>EBU Tech. 3213-E</summary>
        Ebu3213 = 22,
        Custom = 31
    }

    /// <summary>The transfer characteristics, as described by https://www.itu.int/rec/T-REC-H.273-201612-S/en</summary>
    public enum TransferCharacteristics
    {
        Unknown = 0,
        /// <summary>Rec. ITU-R BT.709-6 / ITU-R BT1361</summary>
        Bt709 = 1,
        Unspecified = 2,
        /// <summary>ITU-R BT.470-6 System M / ITU-R BT1700 625 PAL&amp;SECAM</summary>
        Gamma22 = 4,
        /// <summary>ITU-R BT.470-6 System B, G</summary>
        Gamma28 = 5,
        /// <summary>SMPTE ST 170M / ITU-R BT.601-7 525 or 625</summary>
        Bt601 = 6,
        /// <summary>SMPTE ST 240M</summary>
        Smpte240 = 7,
        Linear = 8,
        Log100 = 9,
        Log100Sqrt10 = 10,
        /// <summary>IEC 61966-2-4</summary>
        Iec61966 = 11,
        /// <summary>ITU-R BT1361 Extended Colour Gamut</summary>
        Bt1361 = 12,
        /// <summary>IEC 61966-2-1 (sRGB or sYCC)</summary>
        Srgb = 13,
        /// <summary>ITU-R BT2020 for 10-bit system</summary>
        Bt202010bit = 14,
        /// <summary>ITU-R BT2020 for 12-bit system</summary>
        Bt202012bit = 15,
        /// <summary>SMPTE ST 2084 for 10-, 12-, 14- and 16-bit systems</summary>
        Pq = 16,
        /// <summary>SMPTE ST 428-1</summary>
        Smpte428 = 17,
        /// <summary>ARIB STD-B67, known as &quot;hybrid log-gamma&quot; (HLG)</summary>
        Hlg = 18,
        Custom = 31
    }

    /// <summary>The matrix coefficients, as described by https://www.itu.int/rec/T-REC-H.273-201612-S/en</summary>
    public enum MatrixCoefficients
    {
        Identity = 0,
        /// <summary>ITU-R BT.709-6</summary>
        Bt709 = 1,
        Unspecified = 2,
        /// <summary>US FCC</summary>
        Fcc = 4,
        /// <summary>ITU-R BT.470-6 System B, G / ITU-R BT.601-7 625, functionally the same as SDL_MATRIX_COEFFICIENTS_BT601</summary>
        Bt470bg = 5,
        /// <summary>ITU-R BT.601-7 525</summary>
        Bt601 = 6,
        /// <summary>SMPTE 240M</summary>
        Smpte240 = 7,
        Ycgco = 8,
        /// <summary>ITU-R BT.2020-2 non-constant luminance</summary>
        Bt2020Ncl = 9,
        /// <summary>ITU-R BT.2020-2 constant luminance</summary>
        Bt2020Cl = 10,
        /// <summary>SMPTE ST 2085</summary>
        Smpte2085 = 11,
        ChromaDerivedNcl = 12,
        ChromaDerivedCl = 13,
        /// <summary>ITU-R BT.2100-0 ICTCP</summary>
        Ictcp = 14,
        Custom = 31
    }

    /// <summary>The chroma sample location</summary>
    public enum ChromaLocation
    {
        /// <summary>RGB, no chroma sampling</summary>
        None = 0,
        /// <summary>In MPEG-2, MPEG-4, and AVC, Cb and Cr are taken on midpoint of the left-edge of the 2&#215;2 square. In other words, they have the same horizontal location as the top-left pixel, but is shifted one-half pixel down vertically.</summary>
        Left = 1,
        /// <summary>In JPEG/JFIF, H.261, and MPEG-1, Cb and Cr are taken at the center of 2&#215;2 the square. In other words, they are offset one-half pixel to the right and one-half pixel down compared to the top-left pixel.</summary>
        Center = 2,
        /// <summary>In HEVC for BT.2020 and BT.2100 content (in particular on Blu-rays), Cb and Cr are sampled at the same location as the group's top-left Y pixel (&quot;co-sited&quot;, &quot;co-located&quot;).</summary>
        Topleft = 3
    }

    public enum Colorspace
    {
        Unknown = 0,
        /// <summary>Equivalent to DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P709</summary>
        Srgb = 301991328,
        /// <summary>Equivalent to DXGI_COLOR_SPACE_RGB_FULL_G10_NONE_P709</summary>
        SrgbLinear = 301991168,
        /// <summary>Equivalent to DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020</summary>
        Hdr10 = 301999616,
        /// <summary>Equivalent to DXGI_COLOR_SPACE_YCBCR_FULL_G22_NONE_P709_X601</summary>
        Jpeg = 570426566,
        /// <summary>Equivalent to DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P601</summary>
        Bt601Limited = 554703046,
        /// <summary>Equivalent to DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P601</summary>
        Bt601Full = 571480262,
        /// <summary>Equivalent to DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P709</summary>
        Bt709Limited = 554697761,
        /// <summary>Equivalent to DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P709</summary>
        Bt709Full = 571474977,
        /// <summary>Equivalent to DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P2020</summary>
        Bt2020Limited = 554706441,
        /// <summary>Equivalent to DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P2020</summary>
        Bt2020Full = 571483657,
        RgbDefault = 301991328,
        YuvDefault = 570426566
    }

    /// <summary>Pixel type.</summary>
    /// <summary>Bitmap pixel order, high bit -&gt; low bit.</summary>
    /// <summary>Packed component order, high bit -&gt; low bit.</summary>
    /// <summary>Array component order, low byte -&gt; high byte.</summary>
    /// <summary>Packed component layout.</summary>
    /// <summary>The color type</summary>
    /// <summary>The color range, as described by https://www.itu.int/rec/R-REC-BT.2100-2-201807-I/en</summary>
    /// <summary>The color primaries, as described by https://www.itu.int/rec/T-REC-H.273-201612-S/en</summary>
    /// <summary>The transfer characteristics, as described by https://www.itu.int/rec/T-REC-H.273-201612-S/en</summary>
    /// <summary>The matrix coefficients, as described by https://www.itu.int/rec/T-REC-H.273-201612-S/en</summary>
    /// <summary>The chroma sample location</summary>
    /// <summary>
    /// <para>The bits of this structure can be directly reinterpreted as an integer-packed</para>
    /// <para>color which uses the SDL_PIXELFORMAT_RGBA32 format (SDL_PIXELFORMAT_ABGR8888</para>
    /// <para>on little-endian systems and SDL_PIXELFORMAT_RGBA8888 on big-endian systems).</para>
    /// </summary>
    /// <summary>
    /// <para>The bits of this structure can be directly reinterpreted as a float-packed</para>
    /// <para>color which uses the SDL_PIXELFORMAT_RGBA128_FLOAT format</para>
    /// </summary>
    /// <remarks>Everything in the pixel format structure is read-only.</remarks>
    /// <summary>
    /// <para>The bits of this structure can be directly reinterpreted as an integer-packed</para>
    /// <para>color which uses the SDL_PIXELFORMAT_RGBA32 format (SDL_PIXELFORMAT_ABGR8888</para>
    /// <para>on little-endian systems and SDL_PIXELFORMAT_RGBA8888 on big-endian systems).</para>
    /// </summary>
    public unsafe partial class Color : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4, Pack = 8)]
        public partial struct __Internal
        {
            internal byte r;
            internal byte g;
            internal byte b;
            internal byte a;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_Color@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.Color> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.Color>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.Color managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.Color managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Color __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Color(native.ToPointer(), skipVTables);
        }

        internal static Color __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Color)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Color __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Color(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Color(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Color(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public Color()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.Color.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public Color(global::SDL3Sharp.Color _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.Color.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.Color.__Internal*) __Instance) = *((global::SDL3Sharp.Color.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public byte R
        {
            get
            {
                return ((__Internal*)__Instance)->r;
            }

            set
            {
                ((__Internal*)__Instance)->r = value;
            }
        }

        public byte G
        {
            get
            {
                return ((__Internal*)__Instance)->g;
            }

            set
            {
                ((__Internal*)__Instance)->g = value;
            }
        }

        public byte B
        {
            get
            {
                return ((__Internal*)__Instance)->b;
            }

            set
            {
                ((__Internal*)__Instance)->b = value;
            }
        }

        public byte A
        {
            get
            {
                return ((__Internal*)__Instance)->a;
            }

            set
            {
                ((__Internal*)__Instance)->a = value;
            }
        }
    }

    /// <summary>
    /// <para>The bits of this structure can be directly reinterpreted as a float-packed</para>
    /// <para>color which uses the SDL_PIXELFORMAT_RGBA128_FLOAT format</para>
    /// </summary>
    public unsafe partial class FColor : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public partial struct __Internal
        {
            internal float r;
            internal float g;
            internal float b;
            internal float a;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_FColor@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.FColor> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.FColor>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.FColor managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.FColor managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static FColor __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FColor(native.ToPointer(), skipVTables);
        }

        internal static FColor __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (FColor)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static FColor __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FColor(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FColor(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected FColor(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FColor()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.FColor.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public FColor(global::SDL3Sharp.FColor _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.FColor.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.FColor.__Internal*) __Instance) = *((global::SDL3Sharp.FColor.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float R
        {
            get
            {
                return ((__Internal*)__Instance)->r;
            }

            set
            {
                ((__Internal*)__Instance)->r = value;
            }
        }

        public float G
        {
            get
            {
                return ((__Internal*)__Instance)->g;
            }

            set
            {
                ((__Internal*)__Instance)->g = value;
            }
        }

        public float B
        {
            get
            {
                return ((__Internal*)__Instance)->b;
            }

            set
            {
                ((__Internal*)__Instance)->b = value;
            }
        }

        public float A
        {
            get
            {
                return ((__Internal*)__Instance)->a;
            }

            set
            {
                ((__Internal*)__Instance)->a = value;
            }
        }
    }

    public unsafe partial class Palette : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public partial struct __Internal
        {
            internal int ncolors;
            internal __IntPtr colors;
            internal uint version;
            internal int refcount;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_Palette@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.Palette> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.Palette>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.Palette managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.Palette managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Palette __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Palette(native.ToPointer(), skipVTables);
        }

        internal static Palette __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Palette)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Palette __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Palette(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Palette(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Palette(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public Palette()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.Palette.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public Palette(global::SDL3Sharp.Palette _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.Palette.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.Palette.__Internal*) __Instance) = *((global::SDL3Sharp.Palette.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Ncolors
        {
            get
            {
                return ((__Internal*)__Instance)->ncolors;
            }

            set
            {
                ((__Internal*)__Instance)->ncolors = value;
            }
        }

        public global::SDL3Sharp.Color Colors
        {
            get
            {
                var __result0 = global::SDL3Sharp.Color.__GetOrCreateInstance(((__Internal*)__Instance)->colors, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->colors = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public uint Version
        {
            get
            {
                return ((__Internal*)__Instance)->version;
            }

            set
            {
                ((__Internal*)__Instance)->version = value;
            }
        }

        public int Refcount
        {
            get
            {
                return ((__Internal*)__Instance)->refcount;
            }

            set
            {
                ((__Internal*)__Instance)->refcount = value;
            }
        }
    }

    /// <remarks>Everything in the pixel format structure is read-only.</remarks>
    public unsafe partial class PixelFormat : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 56, Pack = 8)]
        public partial struct __Internal
        {
            internal global::SDL3Sharp.PixelFormatEnum format;
            internal __IntPtr palette;
            internal byte bits_per_pixel;
            internal byte bytes_per_pixel;
            internal fixed byte padding[2];
            internal uint Rmask;
            internal uint Gmask;
            internal uint Bmask;
            internal uint Amask;
            internal byte Rloss;
            internal byte Gloss;
            internal byte Bloss;
            internal byte Aloss;
            internal byte Rshift;
            internal byte Gshift;
            internal byte Bshift;
            internal byte Ashift;
            internal int refcount;
            internal __IntPtr next;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_PixelFormat@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.PixelFormat> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.PixelFormat>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.PixelFormat managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.PixelFormat managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static PixelFormat __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new PixelFormat(native.ToPointer(), skipVTables);
        }

        internal static PixelFormat __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (PixelFormat)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static PixelFormat __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new PixelFormat(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PixelFormat(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected PixelFormat(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public PixelFormat()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.PixelFormat.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public PixelFormat(global::SDL3Sharp.PixelFormat _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.PixelFormat.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.PixelFormat.__Internal*) __Instance) = *((global::SDL3Sharp.PixelFormat.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::SDL3Sharp.PixelFormatEnum Format
        {
            get
            {
                return ((__Internal*)__Instance)->format;
            }

            set
            {
                ((__Internal*)__Instance)->format = value;
            }
        }

        public global::SDL3Sharp.Palette Palette
        {
            get
            {
                var __result0 = global::SDL3Sharp.Palette.__GetOrCreateInstance(((__Internal*)__Instance)->palette, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->palette = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public byte BitsPerPixel
        {
            get
            {
                return ((__Internal*)__Instance)->bits_per_pixel;
            }

            set
            {
                ((__Internal*)__Instance)->bits_per_pixel = value;
            }
        }

        public byte BytesPerPixel
        {
            get
            {
                return ((__Internal*)__Instance)->bytes_per_pixel;
            }

            set
            {
                ((__Internal*)__Instance)->bytes_per_pixel = value;
            }
        }

        public byte[] Padding
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->padding, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->padding[i] = value[i];
                }
            }
        }

        public uint Rmask
        {
            get
            {
                return ((__Internal*)__Instance)->Rmask;
            }

            set
            {
                ((__Internal*)__Instance)->Rmask = value;
            }
        }

        public uint Gmask
        {
            get
            {
                return ((__Internal*)__Instance)->Gmask;
            }

            set
            {
                ((__Internal*)__Instance)->Gmask = value;
            }
        }

        public uint Bmask
        {
            get
            {
                return ((__Internal*)__Instance)->Bmask;
            }

            set
            {
                ((__Internal*)__Instance)->Bmask = value;
            }
        }

        public uint Amask
        {
            get
            {
                return ((__Internal*)__Instance)->Amask;
            }

            set
            {
                ((__Internal*)__Instance)->Amask = value;
            }
        }

        public byte Rloss
        {
            get
            {
                return ((__Internal*)__Instance)->Rloss;
            }

            set
            {
                ((__Internal*)__Instance)->Rloss = value;
            }
        }

        public byte Gloss
        {
            get
            {
                return ((__Internal*)__Instance)->Gloss;
            }

            set
            {
                ((__Internal*)__Instance)->Gloss = value;
            }
        }

        public byte Bloss
        {
            get
            {
                return ((__Internal*)__Instance)->Bloss;
            }

            set
            {
                ((__Internal*)__Instance)->Bloss = value;
            }
        }

        public byte Aloss
        {
            get
            {
                return ((__Internal*)__Instance)->Aloss;
            }

            set
            {
                ((__Internal*)__Instance)->Aloss = value;
            }
        }

        public byte Rshift
        {
            get
            {
                return ((__Internal*)__Instance)->Rshift;
            }

            set
            {
                ((__Internal*)__Instance)->Rshift = value;
            }
        }

        public byte Gshift
        {
            get
            {
                return ((__Internal*)__Instance)->Gshift;
            }

            set
            {
                ((__Internal*)__Instance)->Gshift = value;
            }
        }

        public byte Bshift
        {
            get
            {
                return ((__Internal*)__Instance)->Bshift;
            }

            set
            {
                ((__Internal*)__Instance)->Bshift = value;
            }
        }

        public byte Ashift
        {
            get
            {
                return ((__Internal*)__Instance)->Ashift;
            }

            set
            {
                ((__Internal*)__Instance)->Ashift = value;
            }
        }

        public int Refcount
        {
            get
            {
                return ((__Internal*)__Instance)->refcount;
            }

            set
            {
                ((__Internal*)__Instance)->refcount = value;
            }
        }

        public global::SDL3Sharp.PixelFormat Next
        {
            get
            {
                var __result0 = global::SDL3Sharp.PixelFormat.__GetOrCreateInstance(((__Internal*)__Instance)->next, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->next = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class SDL
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetPixelFormatName", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetPixelFormatName(global::SDL3Sharp.PixelFormatEnum format);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetMasksForPixelFormatEnum", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool GetMasksForPixelFormatEnum(global::SDL3Sharp.PixelFormatEnum format, int* bpp, uint* Rmask, uint* Gmask, uint* Bmask, uint* Amask);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetPixelFormatEnumForMasks", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::SDL3Sharp.PixelFormatEnum GetPixelFormatEnumForMasks(int bpp, uint Rmask, uint Gmask, uint Bmask, uint Amask);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_CreatePixelFormat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CreatePixelFormat(global::SDL3Sharp.PixelFormatEnum pixel_format);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_DestroyPixelFormat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void DestroyPixelFormat(__IntPtr format);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_CreatePalette", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CreatePalette(int ncolors);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetPixelFormatPalette", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetPixelFormatPalette(__IntPtr format, __IntPtr palette);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetPaletteColors", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetPaletteColors(__IntPtr palette, __IntPtr colors, int firstcolor, int ncolors);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_DestroyPalette", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void DestroyPalette(__IntPtr palette);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_MapRGB", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint MapRGB(__IntPtr format, byte r, byte g, byte b);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_MapRGBA", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint MapRGBA(__IntPtr format, byte r, byte g, byte b, byte a);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetRGB", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GetRGB(uint pixel, __IntPtr format, byte* r, byte* g, byte* b);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetRGBA", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GetRGBA(uint pixel, __IntPtr format, byte* r, byte* g, byte* b, byte* a);
        }

        /// <summary>Get the human readable name of a pixel format.</summary>
        /// <param name="format">the pixel format to query</param>
        /// <remarks>
        /// <para>the human readable name of the specified pixel format or</para>
        /// <para>`SDL_PIXELFORMAT_UNKNOWN` if the format isn't recognized.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static string GetPixelFormatName(global::SDL3Sharp.PixelFormatEnum format)
        {
            var ___ret = __Internal.GetPixelFormatName(format);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Convert one of the enumerated pixel formats to a bpp value and RGBA masks.</summary>
        /// <param name="format">one of the SDL_PixelFormatEnum values</param>
        /// <param name="bpp">a bits per pixel value; usually 15, 16, or 32</param>
        /// <param name="Rmask">a pointer filled in with the red mask for the format</param>
        /// <param name="Gmask">a pointer filled in with the green mask for the format</param>
        /// <param name="Bmask">a pointer filled in with the blue mask for the format</param>
        /// <param name="Amask">a pointer filled in with the alpha mask for the format</param>
        /// <remarks>
        /// <para>SDL_TRUE on success or SDL_FALSE if the conversion wasn't</para>
        /// <para>possible; call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetPixelFormatEnumForMasks</para>
        /// </remarks>
        public static bool GetMasksForPixelFormatEnum(global::SDL3Sharp.PixelFormatEnum format, ref int bpp, ref uint Rmask, ref uint Gmask, ref uint Bmask, ref uint Amask)
        {
            fixed (int* __bpp1 = &bpp)
            {
                var __arg1 = __bpp1;
                fixed (uint* __Rmask2 = &Rmask)
                {
                    var __arg2 = __Rmask2;
                    fixed (uint* __Gmask3 = &Gmask)
                    {
                        var __arg3 = __Gmask3;
                        fixed (uint* __Bmask4 = &Bmask)
                        {
                            var __arg4 = __Bmask4;
                            fixed (uint* __Amask5 = &Amask)
                            {
                                var __arg5 = __Amask5;
                                var ___ret = __Internal.GetMasksForPixelFormatEnum(format, __arg1, __arg2, __arg3, __arg4, __arg5);
                                return ___ret;
                            }
                        }
                    }
                }
            }
        }

        /// <summary>Convert a bpp value and RGBA masks to an enumerated pixel format.</summary>
        /// <param name="bpp">a bits per pixel value; usually 15, 16, or 32</param>
        /// <param name="Rmask">the red mask for the format</param>
        /// <param name="Gmask">the green mask for the format</param>
        /// <param name="Bmask">the blue mask for the format</param>
        /// <param name="Amask">the alpha mask for the format</param>
        /// <remarks>
        /// <para>This will return `SDL_PIXELFORMAT_UNKNOWN` if the conversion wasn't</para>
        /// <para>possible.</para>
        /// <para>the SDL_PixelFormatEnum value corresponding to the format masks,</para>
        /// <para>or SDL_PIXELFORMAT_UNKNOWN if there isn't a match.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetMasksForPixelFormatEnum</para>
        /// </remarks>
        public static global::SDL3Sharp.PixelFormatEnum GetPixelFormatEnumForMasks(int bpp, uint Rmask, uint Gmask, uint Bmask, uint Amask)
        {
            var ___ret = __Internal.GetPixelFormatEnumForMasks(bpp, Rmask, Gmask, Bmask, Amask);
            return ___ret;
        }

        /// <summary>Create an SDL_PixelFormat structure corresponding to a pixel format.</summary>
        /// <param name="pixel_format">one of the SDL_PixelFormatEnum values</param>
        /// <remarks>
        /// <para>Returned structure may come from a shared global cache (i.e. not newly</para>
        /// <para>allocated), and hence should not be modified, especially the palette. Weird</para>
        /// <para>errors such as `Blit combination not supported` may occur.</para>
        /// <para>the new SDL_PixelFormat structure or NULL on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_DestroyPixelFormat</para>
        /// </remarks>
        public static global::SDL3Sharp.PixelFormat CreatePixelFormat(global::SDL3Sharp.PixelFormatEnum pixel_format)
        {
            var ___ret = __Internal.CreatePixelFormat(pixel_format);
            var __result0 = global::SDL3Sharp.PixelFormat.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Free an SDL_PixelFormat structure allocated by SDL_CreatePixelFormat().</summary>
        /// <param name="format">the SDL_PixelFormat structure to free</param>
        /// <remarks>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreatePixelFormat</para>
        /// </remarks>
        public static void DestroyPixelFormat(global::SDL3Sharp.PixelFormat format)
        {
            var __arg0 = format is null ? __IntPtr.Zero : format.__Instance;
            __Internal.DestroyPixelFormat(__arg0);
        }

        /// <summary>Create a palette structure with the specified number of color entries.</summary>
        /// <param name="ncolors">represents the number of color entries in the color palette</param>
        /// <remarks>
        /// <para>The palette entries are initialized to white.</para>
        /// <para>a new SDL_Palette structure on success or NULL on failure (e.g. if</para>
        /// <para>there wasn't enough memory); call SDL_GetError() for more</para>
        /// <para>information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_DestroyPalette</para>
        /// </remarks>
        public static global::SDL3Sharp.Palette CreatePalette(int ncolors)
        {
            var ___ret = __Internal.CreatePalette(ncolors);
            var __result0 = global::SDL3Sharp.Palette.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Set the palette for a pixel format structure.</summary>
        /// <param name="format">the SDL_PixelFormat structure that will use the palette</param>
        /// <param name="palette">the SDL_Palette structure that will be used</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreatePalette</para>
        /// <para>SDL_DestroyPalette</para>
        /// </remarks>
        public static int SetPixelFormatPalette(global::SDL3Sharp.PixelFormat format, global::SDL3Sharp.Palette palette)
        {
            var __arg0 = format is null ? __IntPtr.Zero : format.__Instance;
            var __arg1 = palette is null ? __IntPtr.Zero : palette.__Instance;
            var ___ret = __Internal.SetPixelFormatPalette(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Set a range of colors in a palette.</summary>
        /// <param name="palette">the SDL_Palette structure to modify</param>
        /// <param name="colors">an array of SDL_Color structures to copy into the palette</param>
        /// <param name="firstcolor">the index of the first palette entry to modify</param>
        /// <param name="ncolors">the number of entries to modify</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreatePalette</para>
        /// <para>SDL_CreateSurface</para>
        /// </remarks>
        public static int SetPaletteColors(global::SDL3Sharp.Palette palette, global::SDL3Sharp.Color colors, int firstcolor, int ncolors)
        {
            var __arg0 = palette is null ? __IntPtr.Zero : palette.__Instance;
            var __arg1 = colors is null ? __IntPtr.Zero : colors.__Instance;
            var ___ret = __Internal.SetPaletteColors(__arg0, __arg1, firstcolor, ncolors);
            return ___ret;
        }

        /// <summary>Free a palette created with SDL_CreatePalette().</summary>
        /// <param name="palette">the SDL_Palette structure to be freed</param>
        /// <remarks>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreatePalette</para>
        /// </remarks>
        public static void DestroyPalette(global::SDL3Sharp.Palette palette)
        {
            var __arg0 = palette is null ? __IntPtr.Zero : palette.__Instance;
            __Internal.DestroyPalette(__arg0);
        }

        /// <summary>Map an RGB triple to an opaque pixel value for a given pixel format.</summary>
        /// <param name="format">an SDL_PixelFormat structure describing the pixel format</param>
        /// <param name="r">the red component of the pixel in the range 0-255</param>
        /// <param name="g">the green component of the pixel in the range 0-255</param>
        /// <param name="b">the blue component of the pixel in the range 0-255</param>
        /// <remarks>
        /// <para>This function maps the RGB color value to the specified pixel format and</para>
        /// <para>returns the pixel value best approximating the given RGB color value for</para>
        /// <para>the given pixel format.</para>
        /// <para>If the format has a palette (8-bit) the index of the closest matching color</para>
        /// <para>in the palette will be returned.</para>
        /// <para>If the specified pixel format has an alpha component it will be returned as</para>
        /// <para>all 1 bits (fully opaque).</para>
        /// <para>If the pixel format bpp (color depth) is less than 32-bpp then the unused</para>
        /// <para>upper bits of the return value can safely be ignored (e.g., with a 16-bpp</para>
        /// <para>format the return value can be assigned to a Uint16, and similarly a Uint8</para>
        /// <para>for an 8-bpp format).</para>
        /// <para>a pixel value</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetRGB</para>
        /// <para>SDL_GetRGBA</para>
        /// <para>SDL_MapRGBA</para>
        /// </remarks>
        public static uint MapRGB(global::SDL3Sharp.PixelFormat format, byte r, byte g, byte b)
        {
            var __arg0 = format is null ? __IntPtr.Zero : format.__Instance;
            var ___ret = __Internal.MapRGB(__arg0, r, g, b);
            return ___ret;
        }

        /// <summary>Map an RGBA quadruple to a pixel value for a given pixel format.</summary>
        /// <param name="format">
        /// <para>an SDL_PixelFormat structure describing the format of the</para>
        /// <para>pixel</para>
        /// </param>
        /// <param name="r">the red component of the pixel in the range 0-255</param>
        /// <param name="g">the green component of the pixel in the range 0-255</param>
        /// <param name="b">the blue component of the pixel in the range 0-255</param>
        /// <param name="a">the alpha component of the pixel in the range 0-255</param>
        /// <remarks>
        /// <para>This function maps the RGBA color value to the specified pixel format and</para>
        /// <para>returns the pixel value best approximating the given RGBA color value for</para>
        /// <para>the given pixel format.</para>
        /// <para>If the specified pixel format has no alpha component the alpha value will</para>
        /// <para>be ignored (as it will be in formats with a palette).</para>
        /// <para>If the format has a palette (8-bit) the index of the closest matching color</para>
        /// <para>in the palette will be returned.</para>
        /// <para>If the pixel format bpp (color depth) is less than 32-bpp then the unused</para>
        /// <para>upper bits of the return value can safely be ignored (e.g., with a 16-bpp</para>
        /// <para>format the return value can be assigned to a Uint16, and similarly a Uint8</para>
        /// <para>for an 8-bpp format).</para>
        /// <para>a pixel value</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetRGB</para>
        /// <para>SDL_GetRGBA</para>
        /// <para>SDL_MapRGB</para>
        /// </remarks>
        public static uint MapRGBA(global::SDL3Sharp.PixelFormat format, byte r, byte g, byte b, byte a)
        {
            var __arg0 = format is null ? __IntPtr.Zero : format.__Instance;
            var ___ret = __Internal.MapRGBA(__arg0, r, g, b, a);
            return ___ret;
        }

        /// <summary>Get RGB values from a pixel in the specified format.</summary>
        /// <param name="pixel">a pixel value</param>
        /// <param name="format">
        /// <para>an SDL_PixelFormat structure describing the format of the</para>
        /// <para>pixel</para>
        /// </param>
        /// <param name="r">a pointer filled in with the red component</param>
        /// <param name="g">a pointer filled in with the green component</param>
        /// <param name="b">a pointer filled in with the blue component</param>
        /// <remarks>
        /// <para>This function uses the entire 8-bit [0..255] range when converting color</para>
        /// <para>components from pixel formats with less than 8-bits per RGB component</para>
        /// <para>(e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,</para>
        /// <para>0xff, 0xff] not [0xf8, 0xfc, 0xf8]).</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetRGBA</para>
        /// <para>SDL_MapRGB</para>
        /// <para>SDL_MapRGBA</para>
        /// </remarks>
        public static void GetRGB(uint pixel, global::SDL3Sharp.PixelFormat format, byte* r, byte* g, byte* b)
        {
            var __arg1 = format is null ? __IntPtr.Zero : format.__Instance;
            __Internal.GetRGB(pixel, __arg1, r, g, b);
        }

        /// <summary>Get RGBA values from a pixel in the specified format.</summary>
        /// <param name="pixel">a pixel value</param>
        /// <param name="format">
        /// <para>an SDL_PixelFormat structure describing the format of the</para>
        /// <para>pixel</para>
        /// </param>
        /// <param name="r">a pointer filled in with the red component</param>
        /// <param name="g">a pointer filled in with the green component</param>
        /// <param name="b">a pointer filled in with the blue component</param>
        /// <param name="a">a pointer filled in with the alpha component</param>
        /// <remarks>
        /// <para>This function uses the entire 8-bit [0..255] range when converting color</para>
        /// <para>components from pixel formats with less than 8-bits per RGB component</para>
        /// <para>(e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,</para>
        /// <para>0xff, 0xff] not [0xf8, 0xfc, 0xf8]).</para>
        /// <para>If the surface has no alpha component, the alpha will be returned as 0xff</para>
        /// <para>(100% opaque).</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetRGB</para>
        /// <para>SDL_MapRGB</para>
        /// <para>SDL_MapRGBA</para>
        /// </remarks>
        public static void GetRGBA(uint pixel, global::SDL3Sharp.PixelFormat format, byte* r, byte* g, byte* b, byte* a)
        {
            var __arg1 = format is null ? __IntPtr.Zero : format.__Instance;
            __Internal.GetRGBA(pixel, __arg1, r, g, b, a);
        }
    }
}
