// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required
#pragma warning disable CS9084 // Struct member returns 'this' or other instance members by reference

namespace SDL3Sharp
{
    /// <summary>The structure that defines a point (integer)</summary>
    /// <remarks>
    /// <para>SDL_GetRectEnclosingPoints</para>
    /// <para>SDL_PointInRect</para>
    /// </remarks>
    /// <summary>The structure that defines a point (floating point)</summary>
    /// <remarks>
    /// <para>SDL_GetRectEnclosingPointsFloat</para>
    /// <para>SDL_PointInRectFloat</para>
    /// </remarks>
    /// <summary>A rectangle, with the origin at the upper left (integer).</summary>
    /// <remarks>
    /// <para>SDL_RectEmpty</para>
    /// <para>SDL_RectsEqual</para>
    /// <para>SDL_HasRectIntersection</para>
    /// <para>SDL_GetRectIntersection</para>
    /// <para>SDL_GetRectAndLineIntersection</para>
    /// <para>SDL_GetRectUnion</para>
    /// <para>SDL_GetRectEnclosingPoints</para>
    /// </remarks>
    /// <summary>A rectangle, with the origin at the upper left (floating point).</summary>
    /// <remarks>
    /// <para>SDL_RectEmptyFloat</para>
    /// <para>SDL_RectsEqualFloat</para>
    /// <para>SDL_RectsEqualEpsilon</para>
    /// <para>SDL_HasRectIntersectionFloat</para>
    /// <para>SDL_GetRectIntersectionFloat</para>
    /// <para>SDL_GetRectAndLineIntersectionFloat</para>
    /// <para>SDL_GetRectUnionFloat</para>
    /// <para>SDL_GetRectEnclosingPointsFloat</para>
    /// <para>SDL_PointInRectFloat</para>
    /// </remarks>
    /// <summary>The structure that defines a point (integer)</summary>
    /// <remarks>
    /// <para>SDL_GetRectEnclosingPoints</para>
    /// <para>SDL_PointInRect</para>
    /// </remarks>
    public unsafe partial struct Point
    {
        [StructLayout(LayoutKind.Sequential, Size = 8, Pack = 8)]
        public partial struct __Internal
        {
            internal int x;
            internal int y;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_Point@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        private Point.__Internal __instance;
        internal ref Point.__Internal __Instance => ref __instance;

        internal static Point __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new Point(native.ToPointer(), skipVTables);
        }

        internal static Point __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Point(native, skipVTables);
        }

        private Point(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private Point(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::SDL3Sharp.Point.__Internal*) native;
        }

        public Point(global::SDL3Sharp.Point _0)
            : this()
        {
            var ____arg0 = _0.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
            }
        }

        public int X
        {
            get
            {
                return __instance.x;
            }

            set
            {
                __instance.x = value;
            }
        }

        public int Y
        {
            get
            {
                return __instance.y;
            }

            set
            {
                __instance.y = value;
            }
        }
    }

    /// <summary>The structure that defines a point (floating point)</summary>
    /// <remarks>
    /// <para>SDL_GetRectEnclosingPointsFloat</para>
    /// <para>SDL_PointInRectFloat</para>
    /// </remarks>
    public unsafe partial class FPoint : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8, Pack = 8)]
        public partial struct __Internal
        {
            internal float x;
            internal float y;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_FPoint@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.FPoint> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.FPoint>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.FPoint managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.FPoint managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static FPoint __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FPoint(native.ToPointer(), skipVTables);
        }

        internal static FPoint __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (FPoint)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static FPoint __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FPoint(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FPoint(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected FPoint(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FPoint()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.FPoint.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public FPoint(global::SDL3Sharp.FPoint _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.FPoint.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.FPoint.__Internal*) __Instance) = *((global::SDL3Sharp.FPoint.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float X
        {
            get
            {
                return ((__Internal*)__Instance)->x;
            }

            set
            {
                ((__Internal*)__Instance)->x = value;
            }
        }

        public float Y
        {
            get
            {
                return ((__Internal*)__Instance)->y;
            }

            set
            {
                ((__Internal*)__Instance)->y = value;
            }
        }
    }

    /// <summary>A rectangle, with the origin at the upper left (integer).</summary>
    /// <remarks>
    /// <para>SDL_RectEmpty</para>
    /// <para>SDL_RectsEqual</para>
    /// <para>SDL_HasRectIntersection</para>
    /// <para>SDL_GetRectIntersection</para>
    /// <para>SDL_GetRectAndLineIntersection</para>
    /// <para>SDL_GetRectUnion</para>
    /// <para>SDL_GetRectEnclosingPoints</para>
    /// </remarks>
    public unsafe partial class Rect : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public partial struct __Internal
        {
            internal int x;
            internal int y;
            internal int w;
            internal int h;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_Rect@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.Rect> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.Rect>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.Rect managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.Rect managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Rect __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Rect(native.ToPointer(), skipVTables);
        }

        internal static Rect __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Rect)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Rect __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Rect(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Rect(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Rect(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public Rect()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.Rect.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public Rect(global::SDL3Sharp.Rect _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.Rect.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.Rect.__Internal*) __Instance) = *((global::SDL3Sharp.Rect.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int X
        {
            get
            {
                return ((__Internal*)__Instance)->x;
            }

            set
            {
                ((__Internal*)__Instance)->x = value;
            }
        }

        public int Y
        {
            get
            {
                return ((__Internal*)__Instance)->y;
            }

            set
            {
                ((__Internal*)__Instance)->y = value;
            }
        }

        public int W
        {
            get
            {
                return ((__Internal*)__Instance)->w;
            }

            set
            {
                ((__Internal*)__Instance)->w = value;
            }
        }

        public int H
        {
            get
            {
                return ((__Internal*)__Instance)->h;
            }

            set
            {
                ((__Internal*)__Instance)->h = value;
            }
        }
    }

    /// <summary>A rectangle, with the origin at the upper left (floating point).</summary>
    /// <remarks>
    /// <para>SDL_RectEmptyFloat</para>
    /// <para>SDL_RectsEqualFloat</para>
    /// <para>SDL_RectsEqualEpsilon</para>
    /// <para>SDL_HasRectIntersectionFloat</para>
    /// <para>SDL_GetRectIntersectionFloat</para>
    /// <para>SDL_GetRectAndLineIntersectionFloat</para>
    /// <para>SDL_GetRectUnionFloat</para>
    /// <para>SDL_GetRectEnclosingPointsFloat</para>
    /// <para>SDL_PointInRectFloat</para>
    /// </remarks>
    public unsafe partial class FRect : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public partial struct __Internal
        {
            internal float x;
            internal float y;
            internal float w;
            internal float h;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_FRect@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.FRect> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.FRect>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.FRect managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.FRect managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static FRect __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FRect(native.ToPointer(), skipVTables);
        }

        internal static FRect __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (FRect)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static FRect __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FRect(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FRect(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected FRect(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public FRect()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.FRect.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public FRect(global::SDL3Sharp.FRect _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.FRect.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.FRect.__Internal*) __Instance) = *((global::SDL3Sharp.FRect.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float X
        {
            get
            {
                return ((__Internal*)__Instance)->x;
            }

            set
            {
                ((__Internal*)__Instance)->x = value;
            }
        }

        public float Y
        {
            get
            {
                return ((__Internal*)__Instance)->y;
            }

            set
            {
                ((__Internal*)__Instance)->y = value;
            }
        }

        public float W
        {
            get
            {
                return ((__Internal*)__Instance)->w;
            }

            set
            {
                ((__Internal*)__Instance)->w = value;
            }
        }

        public float H
        {
            get
            {
                return ((__Internal*)__Instance)->h;
            }

            set
            {
                ((__Internal*)__Instance)->h = value;
            }
        }
    }

    public unsafe partial class SDL
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_PointInRect", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool PointInRect(__IntPtr p, __IntPtr r);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_RectEmpty", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool RectEmpty(__IntPtr r);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_RectsEqual", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool RectsEqual(__IntPtr a, __IntPtr b);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_HasRectIntersection", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool HasRectIntersection(__IntPtr A, __IntPtr B);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetRectIntersection", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool GetRectIntersection(__IntPtr A, __IntPtr B, __IntPtr result);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetRectUnion", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetRectUnion(__IntPtr A, __IntPtr B, __IntPtr result);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetRectEnclosingPoints", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool GetRectEnclosingPoints(__IntPtr points, int count, __IntPtr clip, __IntPtr result);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetRectAndLineIntersection", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool GetRectAndLineIntersection(__IntPtr rect, int* X1, int* Y1, int* X2, int* Y2);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_PointInRectFloat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool PointInRectFloat(__IntPtr p, __IntPtr r);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_RectEmptyFloat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool RectEmptyFloat(__IntPtr r);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_RectsEqualEpsilon", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool RectsEqualEpsilon(__IntPtr a, __IntPtr b, float epsilon);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_RectsEqualFloat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool RectsEqualFloat(__IntPtr a, __IntPtr b);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_HasRectIntersectionFloat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool HasRectIntersectionFloat(__IntPtr A, __IntPtr B);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetRectIntersectionFloat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool GetRectIntersectionFloat(__IntPtr A, __IntPtr B, __IntPtr result);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetRectUnionFloat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetRectUnionFloat(__IntPtr A, __IntPtr B, __IntPtr result);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetRectEnclosingPointsFloat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool GetRectEnclosingPointsFloat(__IntPtr points, int count, __IntPtr clip, __IntPtr result);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetRectAndLineIntersectionFloat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool GetRectAndLineIntersectionFloat(__IntPtr rect, float* X1, float* Y1, float* X2, float* Y2);
        }

        /// <summary>Returns true if point resides inside a rectangle.</summary>
        public static bool PointInRect(global::SDL3Sharp.Point p, global::SDL3Sharp.Rect r)
        {
            var ____arg0 = p.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            var __arg1 = r is null ? __IntPtr.Zero : r.__Instance;
            var ___ret = __Internal.PointInRect(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Returns true if the rectangle has no area.</summary>
        public static bool RectEmpty(global::SDL3Sharp.Rect r)
        {
            var __arg0 = r is null ? __IntPtr.Zero : r.__Instance;
            var ___ret = __Internal.RectEmpty(__arg0);
            return ___ret;
        }

        /// <summary>Returns true if the two rectangles are equal.</summary>
        public static bool RectsEqual(global::SDL3Sharp.Rect a, global::SDL3Sharp.Rect b)
        {
            var __arg0 = a is null ? __IntPtr.Zero : a.__Instance;
            var __arg1 = b is null ? __IntPtr.Zero : b.__Instance;
            var ___ret = __Internal.RectsEqual(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Determine whether two rectangles intersect.</summary>
        /// <param name="A">an SDL_Rect structure representing the first rectangle</param>
        /// <param name="B">an SDL_Rect structure representing the second rectangle</param>
        /// <remarks>
        /// <para>If either pointer is NULL the function will return SDL_FALSE.</para>
        /// <para>SDL_TRUE if there is an intersection, SDL_FALSE otherwise.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetRectIntersection</para>
        /// </remarks>
        public static bool HasRectIntersection(global::SDL3Sharp.Rect A, global::SDL3Sharp.Rect B)
        {
            var __arg0 = A is null ? __IntPtr.Zero : A.__Instance;
            var __arg1 = B is null ? __IntPtr.Zero : B.__Instance;
            var ___ret = __Internal.HasRectIntersection(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Calculate the intersection of two rectangles.</summary>
        /// <param name="A">an SDL_Rect structure representing the first rectangle</param>
        /// <param name="B">an SDL_Rect structure representing the second rectangle</param>
        /// <param name="result">
        /// <para>an SDL_Rect structure filled in with the intersection of</para>
        /// <para>rectangles `A` and `B`</para>
        /// </param>
        /// <remarks>
        /// <para>If `result` is NULL then this function will return SDL_FALSE.</para>
        /// <para>SDL_TRUE if there is an intersection, SDL_FALSE otherwise.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_HasRectIntersection</para>
        /// </remarks>
        public static bool GetRectIntersection(global::SDL3Sharp.Rect A, global::SDL3Sharp.Rect B, global::SDL3Sharp.Rect result)
        {
            var __arg0 = A is null ? __IntPtr.Zero : A.__Instance;
            var __arg1 = B is null ? __IntPtr.Zero : B.__Instance;
            var __arg2 = result is null ? __IntPtr.Zero : result.__Instance;
            var ___ret = __Internal.GetRectIntersection(__arg0, __arg1, __arg2);
            return ___ret;
        }

        /// <summary>Calculate the union of two rectangles.</summary>
        /// <param name="A">an SDL_Rect structure representing the first rectangle</param>
        /// <param name="B">an SDL_Rect structure representing the second rectangle</param>
        /// <param name="result">
        /// <para>an SDL_Rect structure filled in with the union of rectangles</para>
        /// <para>`A` and `B`</para>
        /// </param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int GetRectUnion(global::SDL3Sharp.Rect A, global::SDL3Sharp.Rect B, global::SDL3Sharp.Rect result)
        {
            var __arg0 = A is null ? __IntPtr.Zero : A.__Instance;
            var __arg1 = B is null ? __IntPtr.Zero : B.__Instance;
            var __arg2 = result is null ? __IntPtr.Zero : result.__Instance;
            var ___ret = __Internal.GetRectUnion(__arg0, __arg1, __arg2);
            return ___ret;
        }

        /// <summary>Calculate a minimal rectangle enclosing a set of points.</summary>
        /// <param name="points">
        /// <para>an array of SDL_Point structures representing points to be</para>
        /// <para>enclosed</para>
        /// </param>
        /// <param name="count">the number of structures in the `points` array</param>
        /// <param name="clip">an SDL_Rect used for clipping or NULL to enclose all points</param>
        /// <param name="result">
        /// <para>an SDL_Rect structure filled in with the minimal enclosing</para>
        /// <para>rectangle</para>
        /// </param>
        /// <remarks>
        /// <para>If `clip` is not NULL then only points inside of the clipping rectangle are</para>
        /// <para>considered.</para>
        /// <para>SDL_TRUE if any points were enclosed or SDL_FALSE if all the</para>
        /// <para>points were outside of the clipping rectangle.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static bool GetRectEnclosingPoints(global::SDL3Sharp.Point points, int count, global::SDL3Sharp.Rect clip, global::SDL3Sharp.Rect result)
        {
            var ____arg0 = points.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            var __arg2 = clip is null ? __IntPtr.Zero : clip.__Instance;
            var __arg3 = result is null ? __IntPtr.Zero : result.__Instance;
            var ___ret = __Internal.GetRectEnclosingPoints(__arg0, count, __arg2, __arg3);
            return ___ret;
        }

        /// <summary>Calculate the intersection of a rectangle and line segment.</summary>
        /// <param name="rect">an SDL_Rect structure representing the rectangle to intersect</param>
        /// <param name="X1">a pointer to the starting X-coordinate of the line</param>
        /// <param name="Y1">a pointer to the starting Y-coordinate of the line</param>
        /// <param name="X2">a pointer to the ending X-coordinate of the line</param>
        /// <param name="Y2">a pointer to the ending Y-coordinate of the line</param>
        /// <remarks>
        /// <para>This function is used to clip a line segment to a rectangle. A line segment</para>
        /// <para>contained entirely within the rectangle or that does not intersect will</para>
        /// <para>remain unchanged. A line segment that crosses the rectangle at either or</para>
        /// <para>both ends will be clipped to the boundary of the rectangle and the new</para>
        /// <para>coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.</para>
        /// <para>SDL_TRUE if there is an intersection, SDL_FALSE otherwise.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static bool GetRectAndLineIntersection(global::SDL3Sharp.Rect rect, ref int X1, ref int Y1, ref int X2, ref int Y2)
        {
            var __arg0 = rect is null ? __IntPtr.Zero : rect.__Instance;
            fixed (int* __X11 = &X1)
            {
                var __arg1 = __X11;
                fixed (int* __Y12 = &Y1)
                {
                    var __arg2 = __Y12;
                    fixed (int* __X23 = &X2)
                    {
                        var __arg3 = __X23;
                        fixed (int* __Y24 = &Y2)
                        {
                            var __arg4 = __Y24;
                            var ___ret = __Internal.GetRectAndLineIntersection(__arg0, __arg1, __arg2, __arg3, __arg4);
                            return ___ret;
                        }
                    }
                }
            }
        }

        /// <summary>Returns true if point resides inside a rectangle.</summary>
        public static bool PointInRectFloat(global::SDL3Sharp.FPoint p, global::SDL3Sharp.FRect r)
        {
            var __arg0 = p is null ? __IntPtr.Zero : p.__Instance;
            var __arg1 = r is null ? __IntPtr.Zero : r.__Instance;
            var ___ret = __Internal.PointInRectFloat(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Returns true if the rectangle has no area.</summary>
        /// <remarks>This function is available since SDL 3.0.0.</remarks>
        public static bool RectEmptyFloat(global::SDL3Sharp.FRect r)
        {
            var __arg0 = r is null ? __IntPtr.Zero : r.__Instance;
            var ___ret = __Internal.RectEmptyFloat(__arg0);
            return ___ret;
        }

        /// <summary>Returns true if the two rectangles are equal, within some given epsilon.</summary>
        /// <remarks>This function is available since SDL 3.0.0.</remarks>
        public static bool RectsEqualEpsilon(global::SDL3Sharp.FRect a, global::SDL3Sharp.FRect b, float epsilon)
        {
            var __arg0 = a is null ? __IntPtr.Zero : a.__Instance;
            var __arg1 = b is null ? __IntPtr.Zero : b.__Instance;
            var ___ret = __Internal.RectsEqualEpsilon(__arg0, __arg1, epsilon);
            return ___ret;
        }

        /// <summary>Returns true if the two rectangles are equal, using a default epsilon.</summary>
        /// <remarks>This function is available since SDL 3.0.0.</remarks>
        public static bool RectsEqualFloat(global::SDL3Sharp.FRect a, global::SDL3Sharp.FRect b)
        {
            var __arg0 = a is null ? __IntPtr.Zero : a.__Instance;
            var __arg1 = b is null ? __IntPtr.Zero : b.__Instance;
            var ___ret = __Internal.RectsEqualFloat(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Determine whether two rectangles intersect with float precision.</summary>
        /// <param name="A">an SDL_FRect structure representing the first rectangle</param>
        /// <param name="B">an SDL_FRect structure representing the second rectangle</param>
        /// <remarks>
        /// <para>If either pointer is NULL the function will return SDL_FALSE.</para>
        /// <para>SDL_TRUE if there is an intersection, SDL_FALSE otherwise.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetRectIntersection</para>
        /// </remarks>
        public static bool HasRectIntersectionFloat(global::SDL3Sharp.FRect A, global::SDL3Sharp.FRect B)
        {
            var __arg0 = A is null ? __IntPtr.Zero : A.__Instance;
            var __arg1 = B is null ? __IntPtr.Zero : B.__Instance;
            var ___ret = __Internal.HasRectIntersectionFloat(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Calculate the intersection of two rectangles with float precision.</summary>
        /// <param name="A">an SDL_FRect structure representing the first rectangle</param>
        /// <param name="B">an SDL_FRect structure representing the second rectangle</param>
        /// <param name="result">
        /// <para>an SDL_FRect structure filled in with the intersection of</para>
        /// <para>rectangles `A` and `B`</para>
        /// </param>
        /// <remarks>
        /// <para>If `result` is NULL then this function will return SDL_FALSE.</para>
        /// <para>SDL_TRUE if there is an intersection, SDL_FALSE otherwise.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_HasRectIntersectionFloat</para>
        /// </remarks>
        public static bool GetRectIntersectionFloat(global::SDL3Sharp.FRect A, global::SDL3Sharp.FRect B, global::SDL3Sharp.FRect result)
        {
            var __arg0 = A is null ? __IntPtr.Zero : A.__Instance;
            var __arg1 = B is null ? __IntPtr.Zero : B.__Instance;
            var __arg2 = result is null ? __IntPtr.Zero : result.__Instance;
            var ___ret = __Internal.GetRectIntersectionFloat(__arg0, __arg1, __arg2);
            return ___ret;
        }

        /// <summary>Calculate the union of two rectangles with float precision.</summary>
        /// <param name="A">an SDL_FRect structure representing the first rectangle</param>
        /// <param name="B">an SDL_FRect structure representing the second rectangle</param>
        /// <param name="result">
        /// <para>an SDL_FRect structure filled in with the union of rectangles</para>
        /// <para>`A` and `B`</para>
        /// </param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int GetRectUnionFloat(global::SDL3Sharp.FRect A, global::SDL3Sharp.FRect B, global::SDL3Sharp.FRect result)
        {
            var __arg0 = A is null ? __IntPtr.Zero : A.__Instance;
            var __arg1 = B is null ? __IntPtr.Zero : B.__Instance;
            var __arg2 = result is null ? __IntPtr.Zero : result.__Instance;
            var ___ret = __Internal.GetRectUnionFloat(__arg0, __arg1, __arg2);
            return ___ret;
        }

        /// <summary>
        /// <para>Calculate a minimal rectangle enclosing a set of points with float</para>
        /// <para>precision.</para>
        /// </summary>
        /// <param name="points">
        /// <para>an array of SDL_FPoint structures representing points to be</para>
        /// <para>enclosed</para>
        /// </param>
        /// <param name="count">the number of structures in the `points` array</param>
        /// <param name="clip">an SDL_FRect used for clipping or NULL to enclose all points</param>
        /// <param name="result">
        /// <para>an SDL_FRect structure filled in with the minimal enclosing</para>
        /// <para>rectangle</para>
        /// </param>
        /// <remarks>
        /// <para>If `clip` is not NULL then only points inside of the clipping rectangle are</para>
        /// <para>considered.</para>
        /// <para>SDL_TRUE if any points were enclosed or SDL_FALSE if all the</para>
        /// <para>points were outside of the clipping rectangle.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static bool GetRectEnclosingPointsFloat(global::SDL3Sharp.FPoint points, int count, global::SDL3Sharp.FRect clip, global::SDL3Sharp.FRect result)
        {
            var __arg0 = points is null ? __IntPtr.Zero : points.__Instance;
            var __arg2 = clip is null ? __IntPtr.Zero : clip.__Instance;
            var __arg3 = result is null ? __IntPtr.Zero : result.__Instance;
            var ___ret = __Internal.GetRectEnclosingPointsFloat(__arg0, count, __arg2, __arg3);
            return ___ret;
        }

        /// <summary>
        /// <para>Calculate the intersection of a rectangle and line segment with float</para>
        /// <para>precision.</para>
        /// </summary>
        /// <param name="rect">an SDL_FRect structure representing the rectangle to intersect</param>
        /// <param name="X1">a pointer to the starting X-coordinate of the line</param>
        /// <param name="Y1">a pointer to the starting Y-coordinate of the line</param>
        /// <param name="X2">a pointer to the ending X-coordinate of the line</param>
        /// <param name="Y2">a pointer to the ending Y-coordinate of the line</param>
        /// <remarks>
        /// <para>This function is used to clip a line segment to a rectangle. A line segment</para>
        /// <para>contained entirely within the rectangle or that does not intersect will</para>
        /// <para>remain unchanged. A line segment that crosses the rectangle at either or</para>
        /// <para>both ends will be clipped to the boundary of the rectangle and the new</para>
        /// <para>coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.</para>
        /// <para>SDL_TRUE if there is an intersection, SDL_FALSE otherwise.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static bool GetRectAndLineIntersectionFloat(global::SDL3Sharp.FRect rect, ref float X1, ref float Y1, ref float X2, ref float Y2)
        {
            var __arg0 = rect is null ? __IntPtr.Zero : rect.__Instance;
            fixed (float* __X11 = &X1)
            {
                var __arg1 = __X11;
                fixed (float* __Y12 = &Y1)
                {
                    var __arg2 = __Y12;
                    fixed (float* __X23 = &X2)
                    {
                        var __arg3 = __X23;
                        fixed (float* __Y24 = &Y2)
                        {
                            var __arg4 = __Y24;
                            var ___ret = __Internal.GetRectAndLineIntersectionFloat(__arg0, __arg1, __arg2, __arg3, __arg4);
                            return ___ret;
                        }
                    }
                }
            }
        }
    }
}
