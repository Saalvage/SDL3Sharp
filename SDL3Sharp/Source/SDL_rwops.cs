// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required
#pragma warning disable CS9084 // Struct member returns 'this' or other instance members by reference

namespace SDL3Sharp
{
    /// <summary>This is the read/write operation structure -- very basic.</summary>
    /// <summary>This is the read/write operation structure -- very basic.</summary>
    public unsafe partial class RWops : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 96, Pack = 8)]
        public partial struct __Internal
        {
            internal __IntPtr size;
            internal __IntPtr seek;
            internal __IntPtr read;
            internal __IntPtr write;
            internal __IntPtr close;
            internal uint type;
            internal uint status;
            internal uint props;
            internal global::SDL3Sharp.RWops.Hidden.__Internal hidden;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_RWops@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public unsafe partial struct Hidden
        {
            [StructLayout(LayoutKind.Explicit, Size = 40, Pack = 8)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::SDL3Sharp.RWops.Hidden.Windowsio.__Internal windowsio;

                [FieldOffset(0)]
                internal global::SDL3Sharp.RWops.Hidden.Stdio.__Internal stdio;

                [FieldOffset(0)]
                internal global::SDL3Sharp.RWops.Hidden.Mem.__Internal mem;

                [FieldOffset(0)]
                internal global::SDL3Sharp.RWops.Hidden.Unknown.__Internal unknown;

                [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0<unnamed-type-hidden>@SDL_RWops@@QEAA@AEBT01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            public unsafe partial class Windowsio : IDisposable
            {
                [StructLayout(LayoutKind.Sequential, Size = 40, Pack = 8)]
                public partial struct __Internal
                {
                    internal bool append;
                    internal __IntPtr h;
                    internal global::SDL3Sharp.RWops.Hidden.Windowsio.Buffer.__Internal buffer;

                    [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0<unnamed-type-windowsio>@<unnamed-type-hidden>@SDL_RWops@@QEAA@AEBU012@@Z", CallingConvention = __CallingConvention.Cdecl)]
                    internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
                }

                public unsafe partial class Buffer : IDisposable
                {
                    [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
                    public partial struct __Internal
                    {
                        internal __IntPtr data;
                        internal ulong size;
                        internal ulong left;

                        [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0<unnamed-type-buffer>@<unnamed-type-windowsio>@<unnamed-type-hidden>@SDL_RWops@@QEAA@AEBU0123@@Z", CallingConvention = __CallingConvention.Cdecl)]
                        internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
                    }

                    public __IntPtr __Instance { get; protected set; }

                    internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.RWops.Hidden.Windowsio.Buffer> NativeToManagedMap =
                        new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.RWops.Hidden.Windowsio.Buffer>();

                    internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.RWops.Hidden.Windowsio.Buffer managed)
                    {
                        NativeToManagedMap[native] = managed;
                    }

                    internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.RWops.Hidden.Windowsio.Buffer managed)
                    {
    
                        return NativeToManagedMap.TryGetValue(native, out managed);
                    }

                    protected bool __ownsNativeInstance;

                    internal static Buffer __CreateInstance(__IntPtr native, bool skipVTables = false)
                    {
                        if (native == __IntPtr.Zero)
                            return null;
                        return new Buffer(native.ToPointer(), skipVTables);
                    }

                    internal static Buffer __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                    {
                        if (native == __IntPtr.Zero)
                            return null;
                        if (__TryGetNativeToManagedMapping(native, out var managed))
                            return (Buffer)managed;
                        var result = __CreateInstance(native, skipVTables);
                        if (saveInstance)
                            __RecordNativeToManagedMapping(native, result);
                        return result;
                    }

                    internal static Buffer __CreateInstance(__Internal native, bool skipVTables = false)
                    {
                        return new Buffer(native, skipVTables);
                    }

                    private static void* __CopyValue(__Internal native)
                    {
                        var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                        *(__Internal*) ret = native;
                        return ret.ToPointer();
                    }

                    private Buffer(__Internal native, bool skipVTables = false)
                        : this(__CopyValue(native), skipVTables)
                    {
                        __ownsNativeInstance = true;
                        __RecordNativeToManagedMapping(__Instance, this);
                    }

                    protected Buffer(void* native, bool skipVTables = false)
                    {
                        if (native == null)
                            return;
                        __Instance = new __IntPtr(native);
                    }

                    public Buffer()
                    {
                        __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.RWops.Hidden.Windowsio.Buffer.__Internal));
                        __ownsNativeInstance = true;
                        __RecordNativeToManagedMapping(__Instance, this);
                    }

                    public Buffer(global::SDL3Sharp.RWops.Hidden.Windowsio.Buffer _0)
                    {
                        __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.RWops.Hidden.Windowsio.Buffer.__Internal));
                        __ownsNativeInstance = true;
                        __RecordNativeToManagedMapping(__Instance, this);
                        *((global::SDL3Sharp.RWops.Hidden.Windowsio.Buffer.__Internal*) __Instance) = *((global::SDL3Sharp.RWops.Hidden.Windowsio.Buffer.__Internal*) _0.__Instance);
                    }

                    public void Dispose()
                    {
                        Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
                    }

                    partial void DisposePartial(bool disposing);

                    internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
                    {
                        if (__Instance == IntPtr.Zero)
                            return;
                        NativeToManagedMap.TryRemove(__Instance, out _);
                        DisposePartial(disposing);
                        if (__ownsNativeInstance)
                            Marshal.FreeHGlobal(__Instance);
                        __Instance = IntPtr.Zero;
                    }

                    public __IntPtr Data
                    {
                        get
                        {
                            return ((__Internal*)__Instance)->data;
                        }

                        set
                        {
                            ((__Internal*)__Instance)->data = (__IntPtr) value;
                        }
                    }

                    public ulong Size
                    {
                        get
                        {
                            return ((__Internal*)__Instance)->size;
                        }

                        set
                        {
                            ((__Internal*)__Instance)->size = value;
                        }
                    }

                    public ulong Left
                    {
                        get
                        {
                            return ((__Internal*)__Instance)->left;
                        }

                        set
                        {
                            ((__Internal*)__Instance)->left = value;
                        }
                    }
                }

                public __IntPtr __Instance { get; protected set; }

                internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.RWops.Hidden.Windowsio> NativeToManagedMap =
                    new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.RWops.Hidden.Windowsio>();

                internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.RWops.Hidden.Windowsio managed)
                {
                    NativeToManagedMap[native] = managed;
                }

                internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.RWops.Hidden.Windowsio managed)
                {
    
                    return NativeToManagedMap.TryGetValue(native, out managed);
                }

                protected bool __ownsNativeInstance;

                internal static Windowsio __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    return new Windowsio(native.ToPointer(), skipVTables);
                }

                internal static Windowsio __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (__TryGetNativeToManagedMapping(native, out var managed))
                        return (Windowsio)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        __RecordNativeToManagedMapping(native, result);
                    return result;
                }

                internal static Windowsio __CreateInstance(__Internal native, bool skipVTables = false)
                {
                    return new Windowsio(native, skipVTables);
                }

                private static void* __CopyValue(__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                    *(__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private Windowsio(__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                protected Windowsio(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new __IntPtr(native);
                }

                public Windowsio()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.RWops.Hidden.Windowsio.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                public Windowsio(global::SDL3Sharp.RWops.Hidden.Windowsio _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.RWops.Hidden.Windowsio.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    *((global::SDL3Sharp.RWops.Hidden.Windowsio.__Internal*) __Instance) = *((global::SDL3Sharp.RWops.Hidden.Windowsio.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
                }

                partial void DisposePartial(bool disposing);

                internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    NativeToManagedMap.TryRemove(__Instance, out _);
                    DisposePartial(disposing);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public bool Append
                {
                    get
                    {
                        return ((__Internal*)__Instance)->append;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->append = value;
                    }
                }

                public __IntPtr H
                {
                    get
                    {
                        return ((__Internal*)__Instance)->h;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->h = (__IntPtr) value;
                    }
                }

                public global::SDL3Sharp.RWops.Hidden.Windowsio.Buffer buffer
                {
                    get
                    {
                        return global::SDL3Sharp.RWops.Hidden.Windowsio.Buffer.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->buffer));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((__Internal*)__Instance)->buffer = *(global::SDL3Sharp.RWops.Hidden.Windowsio.Buffer.__Internal*) value.__Instance;
                    }
                }
            }

            public unsafe partial class Stdio : IDisposable
            {
                [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
                public partial struct __Internal
                {
                    internal bool autoclose;
                    internal __IntPtr fp;

                    [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0<unnamed-type-stdio>@<unnamed-type-hidden>@SDL_RWops@@QEAA@AEBU012@@Z", CallingConvention = __CallingConvention.Cdecl)]
                    internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
                }

                public __IntPtr __Instance { get; protected set; }

                internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.RWops.Hidden.Stdio> NativeToManagedMap =
                    new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.RWops.Hidden.Stdio>();

                internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.RWops.Hidden.Stdio managed)
                {
                    NativeToManagedMap[native] = managed;
                }

                internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.RWops.Hidden.Stdio managed)
                {
    
                    return NativeToManagedMap.TryGetValue(native, out managed);
                }

                protected bool __ownsNativeInstance;

                internal static Stdio __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    return new Stdio(native.ToPointer(), skipVTables);
                }

                internal static Stdio __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (__TryGetNativeToManagedMapping(native, out var managed))
                        return (Stdio)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        __RecordNativeToManagedMapping(native, result);
                    return result;
                }

                internal static Stdio __CreateInstance(__Internal native, bool skipVTables = false)
                {
                    return new Stdio(native, skipVTables);
                }

                private static void* __CopyValue(__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                    *(__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private Stdio(__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                protected Stdio(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new __IntPtr(native);
                }

                public Stdio()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.RWops.Hidden.Stdio.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                public Stdio(global::SDL3Sharp.RWops.Hidden.Stdio _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.RWops.Hidden.Stdio.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    *((global::SDL3Sharp.RWops.Hidden.Stdio.__Internal*) __Instance) = *((global::SDL3Sharp.RWops.Hidden.Stdio.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
                }

                partial void DisposePartial(bool disposing);

                internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    NativeToManagedMap.TryRemove(__Instance, out _);
                    DisposePartial(disposing);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public bool Autoclose
                {
                    get
                    {
                        return ((__Internal*)__Instance)->autoclose;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->autoclose = value;
                    }
                }

                public __IntPtr Fp
                {
                    get
                    {
                        return ((__Internal*)__Instance)->fp;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->fp = (__IntPtr) value;
                    }
                }
            }

            public unsafe partial class Mem : IDisposable
            {
                [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
                public partial struct __Internal
                {
                    internal __IntPtr @base;
                    internal __IntPtr here;
                    internal __IntPtr stop;

                    [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0<unnamed-type-mem>@<unnamed-type-hidden>@SDL_RWops@@QEAA@AEBU012@@Z", CallingConvention = __CallingConvention.Cdecl)]
                    internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
                }

                public __IntPtr __Instance { get; protected set; }

                internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.RWops.Hidden.Mem> NativeToManagedMap =
                    new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.RWops.Hidden.Mem>();

                internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.RWops.Hidden.Mem managed)
                {
                    NativeToManagedMap[native] = managed;
                }

                internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.RWops.Hidden.Mem managed)
                {
    
                    return NativeToManagedMap.TryGetValue(native, out managed);
                }

                protected bool __ownsNativeInstance;

                internal static Mem __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    return new Mem(native.ToPointer(), skipVTables);
                }

                internal static Mem __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (__TryGetNativeToManagedMapping(native, out var managed))
                        return (Mem)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        __RecordNativeToManagedMapping(native, result);
                    return result;
                }

                internal static Mem __CreateInstance(__Internal native, bool skipVTables = false)
                {
                    return new Mem(native, skipVTables);
                }

                private static void* __CopyValue(__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                    *(__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private Mem(__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                protected Mem(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new __IntPtr(native);
                }

                public Mem()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.RWops.Hidden.Mem.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                public Mem(global::SDL3Sharp.RWops.Hidden.Mem _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.RWops.Hidden.Mem.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    *((global::SDL3Sharp.RWops.Hidden.Mem.__Internal*) __Instance) = *((global::SDL3Sharp.RWops.Hidden.Mem.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
                }

                partial void DisposePartial(bool disposing);

                internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    NativeToManagedMap.TryRemove(__Instance, out _);
                    DisposePartial(disposing);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public byte* Base
                {
                    get
                    {
                        return (byte*) ((__Internal*)__Instance)->@base;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->@base = (__IntPtr) value;
                    }
                }

                public byte* Here
                {
                    get
                    {
                        return (byte*) ((__Internal*)__Instance)->here;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->here = (__IntPtr) value;
                    }
                }

                public byte* Stop
                {
                    get
                    {
                        return (byte*) ((__Internal*)__Instance)->stop;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->stop = (__IntPtr) value;
                    }
                }
            }

            public unsafe partial class Unknown : IDisposable
            {
                [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
                public partial struct __Internal
                {
                    internal __IntPtr data1;
                    internal __IntPtr data2;

                    [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0<unnamed-type-unknown>@<unnamed-type-hidden>@SDL_RWops@@QEAA@AEBU012@@Z", CallingConvention = __CallingConvention.Cdecl)]
                    internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
                }

                public __IntPtr __Instance { get; protected set; }

                internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.RWops.Hidden.Unknown> NativeToManagedMap =
                    new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.RWops.Hidden.Unknown>();

                internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.RWops.Hidden.Unknown managed)
                {
                    NativeToManagedMap[native] = managed;
                }

                internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.RWops.Hidden.Unknown managed)
                {
    
                    return NativeToManagedMap.TryGetValue(native, out managed);
                }

                protected bool __ownsNativeInstance;

                internal static Unknown __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    return new Unknown(native.ToPointer(), skipVTables);
                }

                internal static Unknown __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (__TryGetNativeToManagedMapping(native, out var managed))
                        return (Unknown)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        __RecordNativeToManagedMapping(native, result);
                    return result;
                }

                internal static Unknown __CreateInstance(__Internal native, bool skipVTables = false)
                {
                    return new Unknown(native, skipVTables);
                }

                private static void* __CopyValue(__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                    *(__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private Unknown(__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                protected Unknown(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new __IntPtr(native);
                }

                public Unknown()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.RWops.Hidden.Unknown.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                public Unknown(global::SDL3Sharp.RWops.Hidden.Unknown _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.RWops.Hidden.Unknown.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    *((global::SDL3Sharp.RWops.Hidden.Unknown.__Internal*) __Instance) = *((global::SDL3Sharp.RWops.Hidden.Unknown.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
                }

                partial void DisposePartial(bool disposing);

                internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    NativeToManagedMap.TryRemove(__Instance, out _);
                    DisposePartial(disposing);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public __IntPtr Data1
                {
                    get
                    {
                        return ((__Internal*)__Instance)->data1;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->data1 = (__IntPtr) value;
                    }
                }

                public __IntPtr Data2
                {
                    get
                    {
                        return ((__Internal*)__Instance)->data2;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->data2 = (__IntPtr) value;
                    }
                }
            }

            private Hidden.__Internal __instance;
            internal ref Hidden.__Internal __Instance => ref __instance;

            internal static Hidden __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new Hidden(native.ToPointer(), skipVTables);
            }

            internal static Hidden __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Hidden(native, skipVTables);
            }

            private Hidden(__Internal native, bool skipVTables = false)
                : this()
            {
                __instance = native;
            }

            private Hidden(void* native, bool skipVTables = false) : this()
            {
                __instance = *(global::SDL3Sharp.RWops.Hidden.__Internal*) native;
            }

            public Hidden(global::SDL3Sharp.RWops.Hidden _0)
                : this()
            {
                var ____arg0 = _0.__Instance;
                var __arg0 = new __IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
                }
            }

            public global::SDL3Sharp.RWops.Hidden.Windowsio windowsio
            {
                get
                {
                    return global::SDL3Sharp.RWops.Hidden.Windowsio.__CreateInstance(__instance.windowsio);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.windowsio = *(global::SDL3Sharp.RWops.Hidden.Windowsio.__Internal*) value.__Instance;
                }
            }

            public global::SDL3Sharp.RWops.Hidden.Stdio stdio
            {
                get
                {
                    return global::SDL3Sharp.RWops.Hidden.Stdio.__CreateInstance(__instance.stdio);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.stdio = *(global::SDL3Sharp.RWops.Hidden.Stdio.__Internal*) value.__Instance;
                }
            }

            public global::SDL3Sharp.RWops.Hidden.Mem mem
            {
                get
                {
                    return global::SDL3Sharp.RWops.Hidden.Mem.__CreateInstance(__instance.mem);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.mem = *(global::SDL3Sharp.RWops.Hidden.Mem.__Internal*) value.__Instance;
                }
            }

            public global::SDL3Sharp.RWops.Hidden.Unknown unknown
            {
                get
                {
                    return global::SDL3Sharp.RWops.Hidden.Unknown.__CreateInstance(__instance.unknown);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.unknown = *(global::SDL3Sharp.RWops.Hidden.Unknown.__Internal*) value.__Instance;
                }
            }
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.RWops> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.RWops>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.RWops managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.RWops managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static RWops __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new RWops(native.ToPointer(), skipVTables);
        }

        internal static RWops __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (RWops)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static RWops __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RWops(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RWops(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected RWops(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RWops()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.RWops.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public RWops(global::SDL3Sharp.RWops _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.RWops.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.RWops.__Internal*) __Instance) = *((global::SDL3Sharp.RWops.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Return the number of bytes in this rwops</summary>
        /// <returns>the total size of the data stream, or -1 on error.</returns>
        public global::SDL3Sharp.Delegates.Func_long___IntPtr Size
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->size;
                return __ptr0 == IntPtr.Zero? null : (global::SDL3Sharp.Delegates.Func_long___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::SDL3Sharp.Delegates.Func_long___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->size = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>
        /// <para>Seek torelative toone of stdio's whence values:</para>
        /// <para>SDL_RW_SEEK_SET, SDL_RW_SEEK_CUR, SDL_RW_SEEK_END</para>
        /// </summary>
        /// <returns>the final offset in the data stream, or -1 on error.</returns>
        public global::SDL3Sharp.Delegates.Func_long___IntPtr_long_int Seek
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->seek;
                return __ptr0 == IntPtr.Zero? null : (global::SDL3Sharp.Delegates.Func_long___IntPtr_long_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::SDL3Sharp.Delegates.Func_long___IntPtr_long_int));
            }

            set
            {
                ((__Internal*)__Instance)->seek = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>
        /// <para>Read up tobytes from the data stream to the area pointed</para>
        /// <para>at by</para>
        /// </summary>
        /// <returns>the number of bytes read</returns>
        public global::SDL3Sharp.Delegates.Func_ulong___IntPtr___IntPtr_ulong Read
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->read;
                return __ptr0 == IntPtr.Zero? null : (global::SDL3Sharp.Delegates.Func_ulong___IntPtr___IntPtr_ulong) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::SDL3Sharp.Delegates.Func_ulong___IntPtr___IntPtr_ulong));
            }

            set
            {
                ((__Internal*)__Instance)->read = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Write exactlybytes from the area pointed at byto data stream.</summary>
        /// <returns>the number of bytes written</returns>
        public global::SDL3Sharp.Delegates.Func_ulong___IntPtr___IntPtr_ulong Write
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->write;
                return __ptr0 == IntPtr.Zero? null : (global::SDL3Sharp.Delegates.Func_ulong___IntPtr___IntPtr_ulong) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::SDL3Sharp.Delegates.Func_ulong___IntPtr___IntPtr_ulong));
            }

            set
            {
                ((__Internal*)__Instance)->write = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Close and free an allocated SDL_RWops structure.</summary>
        /// <returns>0 if successful or -1 on write error when flushing data.</returns>
        public global::SDL3Sharp.Delegates.Func_int___IntPtr Close
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->close;
                return __ptr0 == IntPtr.Zero? null : (global::SDL3Sharp.Delegates.Func_int___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::SDL3Sharp.Delegates.Func_int___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->close = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public uint Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public uint Status
        {
            get
            {
                return ((__Internal*)__Instance)->status;
            }

            set
            {
                ((__Internal*)__Instance)->status = value;
            }
        }

        public uint Props
        {
            get
            {
                return ((__Internal*)__Instance)->props;
            }

            set
            {
                ((__Internal*)__Instance)->props = value;
            }
        }

        public global::SDL3Sharp.RWops.Hidden hidden
        {
            get
            {
                return global::SDL3Sharp.RWops.Hidden.__CreateInstance(((__Internal*)__Instance)->hidden);
            }

            set
            {
                ((__Internal*)__Instance)->hidden = value.__Instance;
            }
        }
    }

    public unsafe partial class SDL
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_RWFromFile", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr RWFromFile([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string file, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string mode);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_RWFromMem", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr RWFromMem(__IntPtr mem, ulong size);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_RWFromConstMem", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr RWFromConstMem(__IntPtr mem, ulong size);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_CreateRW", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CreateRW();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_DestroyRW", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void DestroyRW(__IntPtr context);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetRWProperties", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint GetRWProperties(__IntPtr context);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_RWsize", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern long RWsize(__IntPtr context);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_RWseek", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern long RWseek(__IntPtr context, long offset, int whence);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_RWtell", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern long RWtell(__IntPtr context);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_RWread", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong RWread(__IntPtr context, __IntPtr ptr, ulong size);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_RWwrite", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong RWwrite(__IntPtr context, __IntPtr ptr, ulong size);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_RWprintf", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong RWprintf(__IntPtr context, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_RWclose", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int RWclose(__IntPtr context);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_LoadFile_RW", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LoadFileRW(__IntPtr src, ulong* datasize, bool freesrc);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_LoadFile", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr LoadFile([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string file, ulong* datasize);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_ReadU8", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool ReadU8(__IntPtr src, byte* value);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_ReadU16LE", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool ReadU16LE(__IntPtr src, ushort* value);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_ReadS16LE", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool ReadS16LE(__IntPtr src, short* value);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_ReadU16BE", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool ReadU16BE(__IntPtr src, ushort* value);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_ReadS16BE", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool ReadS16BE(__IntPtr src, short* value);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_ReadU32LE", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool ReadU32LE(__IntPtr src, uint* value);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_ReadS32LE", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool ReadS32LE(__IntPtr src, int* value);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_ReadU32BE", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool ReadU32BE(__IntPtr src, uint* value);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_ReadS32BE", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool ReadS32BE(__IntPtr src, int* value);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_ReadU64LE", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool ReadU64LE(__IntPtr src, ulong* value);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_ReadS64LE", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool ReadS64LE(__IntPtr src, long* value);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_ReadU64BE", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool ReadU64BE(__IntPtr src, ulong* value);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_ReadS64BE", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool ReadS64BE(__IntPtr src, long* value);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_WriteU8", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool WriteU8(__IntPtr dst, byte value);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_WriteU16LE", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool WriteU16LE(__IntPtr dst, ushort value);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_WriteS16LE", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool WriteS16LE(__IntPtr dst, short value);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_WriteU16BE", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool WriteU16BE(__IntPtr dst, ushort value);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_WriteS16BE", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool WriteS16BE(__IntPtr dst, short value);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_WriteU32LE", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool WriteU32LE(__IntPtr dst, uint value);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_WriteS32LE", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool WriteS32LE(__IntPtr dst, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_WriteU32BE", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool WriteU32BE(__IntPtr dst, uint value);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_WriteS32BE", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool WriteS32BE(__IntPtr dst, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_WriteU64LE", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool WriteU64LE(__IntPtr dst, ulong value);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_WriteS64LE", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool WriteS64LE(__IntPtr dst, long value);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_WriteU64BE", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool WriteU64BE(__IntPtr dst, ulong value);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_WriteS64BE", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool WriteS64BE(__IntPtr dst, long value);
        }

        /// <summary>
        /// <para>Use this function to create a new SDL_RWops structure for reading from</para>
        /// <para>and/or writing to a named file.</para>
        /// </summary>
        /// <param name="file">a UTF-8 string representing the filename to open</param>
        /// <param name="mode">
        /// <para>an ASCII string representing the mode to be used for opening</para>
        /// <para>the file.</para>
        /// </param>
        /// <remarks>
        /// <para>The `mode` string is treated roughly the same as in a call to the C</para>
        /// <para>library's fopen(), even if SDL doesn't happen to use fopen() behind the</para>
        /// <para>scenes.</para>
        /// <para>Available `mode` strings:</para>
        /// <para>- &quot;r&quot;: Open a file for reading. The file must exist.</para>
        /// <para>- &quot;w&quot;: Create an empty file for writing. If a file with the same name</para>
        /// <para>already exists its content is erased and the file is treated as a new</para>
        /// <para>empty file.</para>
        /// <para>- &quot;a&quot;: Append to a file. Writing operations append data at the end of the</para>
        /// <para>file. The file is created if it does not exist.</para>
        /// <para>- &quot;r+&quot;: Open a file for update both reading and writing. The file must</para>
        /// <para>exist.</para>
        /// <para>- &quot;w+&quot;: Create an empty file for both reading and writing. If a file with</para>
        /// <para>the same name already exists its content is erased and the file is</para>
        /// <para>treated as a new empty file.</para>
        /// <para>- &quot;a+&quot;: Open a file for reading and appending. All writing operations are</para>
        /// <para>performed at the end of the file, protecting the previous content to be</para>
        /// <para>overwritten. You can reposition (fseek, rewind) the internal pointer to</para>
        /// <para>anywhere in the file for reading, but writing operations will move it</para>
        /// <para>back to the end of file. The file is created if it does not exist.</para>
        /// <para>**NOTE**: In order to open a file as a binary file, a &quot;b&quot; character has to</para>
        /// <para>be included in the `mode` string. This additional &quot;b&quot; character can either</para>
        /// <para>be appended at the end of the string (thus making the following compound</para>
        /// <para>modes: &quot;rb&quot;, &quot;wb&quot;, &quot;ab&quot;, &quot;r+b&quot;, &quot;w+b&quot;, &quot;a+b&quot;) or be inserted between the</para>
        /// <para>letter and the &quot;+&quot; sign for the mixed modes (&quot;rb+&quot;, &quot;wb+&quot;, &quot;ab+&quot;).</para>
        /// <para>Additional characters may follow the sequence, although they should have no</para>
        /// <para>effect. For example, &quot;t&quot; is sometimes appended to make explicit the file is</para>
        /// <para>a text file.</para>
        /// <para>This function supports Unicode filenames, but they must be encoded in UTF-8</para>
        /// <para>format, regardless of the underlying operating system.</para>
        /// <para>As a fallback, SDL_RWFromFile() will transparently open a matching filename</para>
        /// <para>in an Android app's `assets`.</para>
        /// <para>Closing the SDL_RWops will close the file handle SDL is holding internally.</para>
        /// <para>a pointer to the SDL_RWops structure that is created, or NULL on</para>
        /// <para>failure; call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_RWclose</para>
        /// <para>SDL_RWFromConstMem</para>
        /// <para>SDL_RWFromMem</para>
        /// <para>SDL_RWread</para>
        /// <para>SDL_RWseek</para>
        /// <para>SDL_RWtell</para>
        /// <para>SDL_RWwrite</para>
        /// </remarks>
        public static global::SDL3Sharp.RWops RWFromFile(string file, string mode)
        {
            var ___ret = __Internal.RWFromFile(file, mode);
            var __result0 = global::SDL3Sharp.RWops.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Use this function to prepare a read-write memory buffer for use with</para>
        /// <para>SDL_RWops.</para>
        /// </summary>
        /// <param name="mem">a pointer to a buffer to feed an SDL_RWops stream</param>
        /// <param name="size">the buffer size, in bytes</param>
        /// <remarks>
        /// <para>This function sets up an SDL_RWops struct based on a memory area of a</para>
        /// <para>certain size, for both read and write access.</para>
        /// <para>This memory buffer is not copied by the RWops; the pointer you provide must</para>
        /// <para>remain valid until you close the stream. Closing the stream will not free</para>
        /// <para>the original buffer.</para>
        /// <para>If you need to make sure the RWops never writes to the memory buffer, you</para>
        /// <para>should use SDL_RWFromConstMem() with a read-only buffer of memory instead.</para>
        /// <para>a pointer to a new SDL_RWops structure, or NULL if it fails; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_RWclose</para>
        /// <para>SDL_RWFromConstMem</para>
        /// <para>SDL_RWFromFile</para>
        /// <para>SDL_RWFromMem</para>
        /// <para>SDL_RWread</para>
        /// <para>SDL_RWseek</para>
        /// <para>SDL_RWtell</para>
        /// <para>SDL_RWwrite</para>
        /// </remarks>
        public static global::SDL3Sharp.RWops RWFromMem(__IntPtr mem, ulong size)
        {
            var ___ret = __Internal.RWFromMem(mem, size);
            var __result0 = global::SDL3Sharp.RWops.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Use this function to prepare a read-only memory buffer for use with RWops.</summary>
        /// <param name="mem">a pointer to a read-only buffer to feed an SDL_RWops stream</param>
        /// <param name="size">the buffer size, in bytes</param>
        /// <remarks>
        /// <para>This function sets up an SDL_RWops struct based on a memory area of a</para>
        /// <para>certain size. It assumes the memory area is not writable.</para>
        /// <para>Attempting to write to this RWops stream will report an error without</para>
        /// <para>writing to the memory buffer.</para>
        /// <para>This memory buffer is not copied by the RWops; the pointer you provide must</para>
        /// <para>remain valid until you close the stream. Closing the stream will not free</para>
        /// <para>the original buffer.</para>
        /// <para>If you need to write to a memory buffer, you should use SDL_RWFromMem()</para>
        /// <para>with a writable buffer of memory instead.</para>
        /// <para>a pointer to a new SDL_RWops structure, or NULL if it fails; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_RWclose</para>
        /// <para>SDL_RWFromConstMem</para>
        /// <para>SDL_RWFromFile</para>
        /// <para>SDL_RWFromMem</para>
        /// <para>SDL_RWread</para>
        /// <para>SDL_RWseek</para>
        /// <para>SDL_RWtell</para>
        /// </remarks>
        public static global::SDL3Sharp.RWops RWFromConstMem(__IntPtr mem, ulong size)
        {
            var ___ret = __Internal.RWFromConstMem(mem, size);
            var __result0 = global::SDL3Sharp.RWops.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Use this function to allocate an empty, unpopulated SDL_RWops structure.</summary>
        /// <remarks>
        /// <para>Applications do not need to use this function unless they are providing</para>
        /// <para>their own SDL_RWops implementation. If you just need an SDL_RWops to</para>
        /// <para>read/write a common data source, you should use the built-in</para>
        /// <para>implementations in SDL, like SDL_RWFromFile() or SDL_RWFromMem(), etc.</para>
        /// <para>You must free the returned pointer with SDL_DestroyRW(). Depending on your</para>
        /// <para>operating system and compiler, there may be a difference between the</para>
        /// <para>malloc() and free() your program uses and the versions SDL calls</para>
        /// <para>internally. Trying to mix the two can cause crashing such as segmentation</para>
        /// <para>faults. Since all SDL_RWops must free themselves when their **close**</para>
        /// <para>method is called, all SDL_RWops must be allocated through this function, so</para>
        /// <para>they can all be freed correctly with SDL_DestroyRW().</para>
        /// <para>a pointer to the allocated memory on success, or NULL on failure;</para>
        /// <para>call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_DestroyRW</para>
        /// </remarks>
        public static global::SDL3Sharp.RWops CreateRW()
        {
            var ___ret = __Internal.CreateRW();
            var __result0 = global::SDL3Sharp.RWops.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Use this function to free an SDL_RWops structure allocated by</para>
        /// <para>SDL_CreateRW().</para>
        /// </summary>
        /// <param name="context">the SDL_RWops structure to be freed</param>
        /// <remarks>
        /// <para>Applications do not need to use this function unless they are providing</para>
        /// <para>their own SDL_RWops implementation. If you just need an SDL_RWops to</para>
        /// <para>read/write a common data source, you should use the built-in</para>
        /// <para>implementations in SDL, like SDL_RWFromFile() or SDL_RWFromMem(), etc, and</para>
        /// <para>call the **close** method on those SDL_RWops pointers when you are done</para>
        /// <para>with them.</para>
        /// <para>Only use SDL_DestroyRW() on pointers returned by SDL_CreateRW(). The</para>
        /// <para>pointer is invalid as soon as this function returns. Any extra memory</para>
        /// <para>allocated during creation of the SDL_RWops is not freed by SDL_DestroyRW();</para>
        /// <para>the programmer must be responsible for managing that memory in their</para>
        /// <para>**close** method.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateRW</para>
        /// </remarks>
        public static void DestroyRW(global::SDL3Sharp.RWops context)
        {
            var __arg0 = context is null ? __IntPtr.Zero : context.__Instance;
            __Internal.DestroyRW(__arg0);
        }

        /// <summary>Get the properties associated with an SDL_RWops.</summary>
        /// <param name="context">a pointer to an SDL_RWops structure</param>
        /// <remarks>
        /// <para>a valid property ID on success or 0 on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetProperty</para>
        /// <para>SDL_SetProperty</para>
        /// </remarks>
        public static uint GetRWProperties(global::SDL3Sharp.RWops context)
        {
            var __arg0 = context is null ? __IntPtr.Zero : context.__Instance;
            var ___ret = __Internal.GetRWProperties(__arg0);
            return ___ret;
        }

        /// <summary>Use this function to get the size of the data stream in an SDL_RWops.</summary>
        /// <param name="context">the SDL_RWops to get the size of the data stream from</param>
        /// <remarks>
        /// <para>the size of the data stream in the SDL_RWops on success or a</para>
        /// <para>negative error code on failure; call SDL_GetError() for more</para>
        /// <para>information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static long RWsize(global::SDL3Sharp.RWops context)
        {
            var __arg0 = context is null ? __IntPtr.Zero : context.__Instance;
            var ___ret = __Internal.RWsize(__arg0);
            return ___ret;
        }

        /// <summary>Seek within an SDL_RWops data stream.</summary>
        /// <param name="context">a pointer to an SDL_RWops structure</param>
        /// <param name="offset">
        /// <para>an offset in bytes, relative to **whence** location; can be</para>
        /// <para>negative</para>
        /// </param>
        /// <param name="whence">
        /// <para>any of `SDL_RW_SEEK_SET`, `SDL_RW_SEEK_CUR`,</para>
        /// <para>`SDL_RW_SEEK_END`</para>
        /// </param>
        /// <remarks>
        /// <para>This function seeks to byte `offset`, relative to `whence`.</para>
        /// <para>`whence` may be any of the following values:</para>
        /// <para>- `SDL_RW_SEEK_SET`: seek from the beginning of data</para>
        /// <para>- `SDL_RW_SEEK_CUR`: seek relative to current read point</para>
        /// <para>- `SDL_RW_SEEK_END`: seek relative to the end of data</para>
        /// <para>If this stream can not seek, it will return -1.</para>
        /// <para>SDL_RWseek() is actually a wrapper function that calls the SDL_RWops's</para>
        /// <para>`seek` method appropriately, to simplify application development.</para>
        /// <para>the final offset in the data stream after the seek or a negative</para>
        /// <para>error code on failure; call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_RWclose</para>
        /// <para>SDL_RWFromConstMem</para>
        /// <para>SDL_RWFromFile</para>
        /// <para>SDL_RWFromMem</para>
        /// <para>SDL_RWread</para>
        /// <para>SDL_RWtell</para>
        /// <para>SDL_RWwrite</para>
        /// </remarks>
        public static long RWseek(global::SDL3Sharp.RWops context, long offset, int whence)
        {
            var __arg0 = context is null ? __IntPtr.Zero : context.__Instance;
            var ___ret = __Internal.RWseek(__arg0, offset, whence);
            return ___ret;
        }

        /// <summary>Determine the current read/write offset in an SDL_RWops data stream.</summary>
        /// <param name="context">
        /// <para>an SDL_RWops data stream object from which to get the</para>
        /// <para>current offset</para>
        /// </param>
        /// <remarks>
        /// <para>SDL_RWtell is actually a wrapper function that calls the SDL_RWops's `seek`</para>
        /// <para>method, with an offset of 0 bytes from `SDL_RW_SEEK_CUR`, to simplify</para>
        /// <para>application development.</para>
        /// <para>the current offset in the stream, or -1 if the information can not</para>
        /// <para>be determined.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_RWclose</para>
        /// <para>SDL_RWFromConstMem</para>
        /// <para>SDL_RWFromFile</para>
        /// <para>SDL_RWFromMem</para>
        /// <para>SDL_RWread</para>
        /// <para>SDL_RWseek</para>
        /// <para>SDL_RWwrite</para>
        /// </remarks>
        public static long RWtell(global::SDL3Sharp.RWops context)
        {
            var __arg0 = context is null ? __IntPtr.Zero : context.__Instance;
            var ___ret = __Internal.RWtell(__arg0);
            return ___ret;
        }

        /// <summary>Read from a data source.</summary>
        /// <param name="context">a pointer to an SDL_RWops structure</param>
        /// <param name="ptr">a pointer to a buffer to read data into</param>
        /// <param name="size">the number of bytes to read from the data source.</param>
        /// <remarks>
        /// <para>This function reads up `size` bytes from the data source to the area</para>
        /// <para>pointed at by `ptr`. This function may read less bytes than requested. It</para>
        /// <para>will return zero when the data stream is completely read, or -1 on error.</para>
        /// <para>For streams that support non-blocking operation, if nothing was read</para>
        /// <para>because it would require blocking, this function returns -2 to distinguish</para>
        /// <para>that this is not an error or end-of-file, and the caller can try again</para>
        /// <para>later.</para>
        /// <para>SDL_RWread() is actually a function wrapper that calls the SDL_RWops's</para>
        /// <para>`read` method appropriately, to simplify application development.</para>
        /// <para>the number of bytes read, or 0 on end of file or other error.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_RWclose</para>
        /// <para>SDL_RWFromConstMem</para>
        /// <para>SDL_RWFromFile</para>
        /// <para>SDL_RWFromMem</para>
        /// <para>SDL_RWseek</para>
        /// <para>SDL_RWwrite</para>
        /// </remarks>
        public static ulong RWread(global::SDL3Sharp.RWops context, __IntPtr ptr, ulong size)
        {
            var __arg0 = context is null ? __IntPtr.Zero : context.__Instance;
            var ___ret = __Internal.RWread(__arg0, ptr, size);
            return ___ret;
        }

        /// <summary>Write to an SDL_RWops data stream.</summary>
        /// <param name="context">a pointer to an SDL_RWops structure</param>
        /// <param name="ptr">a pointer to a buffer containing data to write</param>
        /// <param name="size">the number of bytes to write</param>
        /// <remarks>
        /// <para>This function writes exactly `size` bytes from the area pointed at by `ptr`</para>
        /// <para>to the stream. If this fails for any reason, it'll return less than `size`</para>
        /// <para>to demonstrate how far the write progressed. On success, it returns `num`.</para>
        /// <para>On error, this function still attempts to write as much as possible, so it</para>
        /// <para>might return a positive value less than the requested write size. If the</para>
        /// <para>function failed to write anything and there was an actual error, it will</para>
        /// <para>return -1. For streams that support non-blocking operation, if nothing was</para>
        /// <para>written because it would require blocking, this function returns -2 to</para>
        /// <para>distinguish that this is not an error and the caller can try again later.</para>
        /// <para>SDL_RWwrite is actually a function wrapper that calls the SDL_RWops's</para>
        /// <para>`write` method appropriately, to simplify application development.</para>
        /// <para>It is an error to specify a negative `size`, but this parameter is signed</para>
        /// <para>so you definitely cannot overflow the return value on a successful run with</para>
        /// <para>enormous amounts of data.</para>
        /// <para>the number of bytes written, which will be less than `num` on</para>
        /// <para>error; call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_RWclose</para>
        /// <para>SDL_RWFromConstMem</para>
        /// <para>SDL_RWFromFile</para>
        /// <para>SDL_RWFromMem</para>
        /// <para>SDL_RWprint</para>
        /// <para>SDL_RWread</para>
        /// <para>SDL_RWseek</para>
        /// </remarks>
        public static ulong RWwrite(global::SDL3Sharp.RWops context, __IntPtr ptr, ulong size)
        {
            var __arg0 = context is null ? __IntPtr.Zero : context.__Instance;
            var ___ret = __Internal.RWwrite(__arg0, ptr, size);
            return ___ret;
        }

        /// <summary>Print to an SDL_RWops data stream.</summary>
        /// <param name="context">a pointer to an SDL_RWops structure</param>
        /// <param name="fmt">a printf() style format string</param>
        /// <param name="...">
        /// <para>additional parameters matching % tokens in the `fmt` string, if</para>
        /// <para>any</para>
        /// </param>
        /// <remarks>
        /// <para>This function does formatted printing to the stream.</para>
        /// <para>the number of bytes written, or 0 on error; call SDL_GetError()</para>
        /// <para>for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_RWclose</para>
        /// <para>SDL_RWFromConstMem</para>
        /// <para>SDL_RWFromFile</para>
        /// <para>SDL_RWFromMem</para>
        /// <para>SDL_RWread</para>
        /// <para>SDL_RWseek</para>
        /// <para>SDL_RWwrite</para>
        /// </remarks>
        public static ulong RWprintf(global::SDL3Sharp.RWops context, string fmt)
        {
            var __arg0 = context is null ? __IntPtr.Zero : context.__Instance;
            var ___ret = __Internal.RWprintf(__arg0, fmt);
            return ___ret;
        }

        /// <summary>Close and free an allocated SDL_RWops structure.</summary>
        /// <param name="context">SDL_RWops structure to close</param>
        /// <remarks>
        /// <para>SDL_RWclose() closes and cleans up the SDL_RWops stream. It releases any</para>
        /// <para>resources used by the stream and frees the SDL_RWops itself with</para>
        /// <para>SDL_DestroyRW(). This returns 0 on success, or -1 if the stream failed to</para>
        /// <para>flush to its output (e.g. to disk).</para>
        /// <para>Note that if this fails to flush the stream to disk, this function reports</para>
        /// <para>an error, but the SDL_RWops is still invalid once this function returns.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_RWFromConstMem</para>
        /// <para>SDL_RWFromFile</para>
        /// <para>SDL_RWFromMem</para>
        /// <para>SDL_RWread</para>
        /// <para>SDL_RWseek</para>
        /// <para>SDL_RWwrite</para>
        /// </remarks>
        public static int RWclose(global::SDL3Sharp.RWops context)
        {
            var __arg0 = context is null ? __IntPtr.Zero : context.__Instance;
            var ___ret = __Internal.RWclose(__arg0);
            return ___ret;
        }

        /// <summary>Load all the data from an SDL data stream.</summary>
        /// <param name="src">the SDL_RWops to read all available data from</param>
        /// <param name="datasize">if not NULL, will store the number of bytes read</param>
        /// <param name="freesrc">
        /// <para>if SDL_TRUE, calls SDL_RWclose() on `src` before returning,</para>
        /// <para>even in the case of an error</para>
        /// </param>
        /// <remarks>
        /// <para>The data is allocated with a zero byte at the end (null terminated) for</para>
        /// <para>convenience. This extra byte is not included in the value reported via</para>
        /// <para>`datasize`.</para>
        /// <para>The data should be freed with SDL_free().</para>
        /// <para>the data, or NULL if there was an error.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static __IntPtr LoadFileRW(global::SDL3Sharp.RWops src, ref ulong datasize, bool freesrc)
        {
            var __arg0 = src is null ? __IntPtr.Zero : src.__Instance;
            fixed (ulong* __datasize1 = &datasize)
            {
                var __arg1 = __datasize1;
                var ___ret = __Internal.LoadFileRW(__arg0, __arg1, freesrc);
                return ___ret;
            }
        }

        /// <summary>Load all the data from a file path.</summary>
        /// <param name="file">the path to read all available data from</param>
        /// <param name="datasize">if not NULL, will store the number of bytes read</param>
        /// <remarks>
        /// <para>The data is allocated with a zero byte at the end (null terminated) for</para>
        /// <para>convenience. This extra byte is not included in the value reported via</para>
        /// <para>`datasize`.</para>
        /// <para>The data should be freed with SDL_free().</para>
        /// <para>the data, or NULL if there was an error.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static __IntPtr LoadFile(string file, ref ulong datasize)
        {
            fixed (ulong* __datasize1 = &datasize)
            {
                var __arg1 = __datasize1;
                var ___ret = __Internal.LoadFile(file, __arg1);
                return ___ret;
            }
        }

        /// <summary>Use this function to read a byte from an SDL_RWops.</summary>
        /// <param name="src">the SDL_RWops to read from</param>
        /// <param name="value">a pointer filled in with the data read</param>
        /// <remarks>
        /// <para>SDL_TRUE on success or SDL_FALSE on failure; call SDL_GetError()</para>
        /// <para>for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static bool ReadU8(global::SDL3Sharp.RWops src, byte* value)
        {
            var __arg0 = src is null ? __IntPtr.Zero : src.__Instance;
            var ___ret = __Internal.ReadU8(__arg0, value);
            return ___ret;
        }

        /// <summary>
        /// <para>Use this function to read 16 bits of little-endian data from an SDL_RWops</para>
        /// <para>and return in native format.</para>
        /// </summary>
        /// <param name="src">the stream from which to read data</param>
        /// <param name="value">a pointer filled in with the data read</param>
        /// <remarks>
        /// <para>SDL byteswaps the data only if necessary, so the data returned will be in</para>
        /// <para>the native byte order.</para>
        /// <para>SDL_TRUE on successful write, SDL_FALSE on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static bool ReadU16LE(global::SDL3Sharp.RWops src, ref ushort value)
        {
            var __arg0 = src is null ? __IntPtr.Zero : src.__Instance;
            fixed (ushort* __value1 = &value)
            {
                var __arg1 = __value1;
                var ___ret = __Internal.ReadU16LE(__arg0, __arg1);
                return ___ret;
            }
        }

        /// <summary>
        /// <para>Use this function to read 16 bits of little-endian data from an SDL_RWops</para>
        /// <para>and return in native format.</para>
        /// </summary>
        /// <param name="src">the stream from which to read data</param>
        /// <param name="value">a pointer filled in with the data read</param>
        /// <remarks>
        /// <para>SDL byteswaps the data only if necessary, so the data returned will be in</para>
        /// <para>the native byte order.</para>
        /// <para>SDL_TRUE on successful write, SDL_FALSE on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static bool ReadS16LE(global::SDL3Sharp.RWops src, ref short value)
        {
            var __arg0 = src is null ? __IntPtr.Zero : src.__Instance;
            fixed (short* __value1 = &value)
            {
                var __arg1 = __value1;
                var ___ret = __Internal.ReadS16LE(__arg0, __arg1);
                return ___ret;
            }
        }

        /// <summary>
        /// <para>Use this function to read 16 bits of big-endian data from an SDL_RWops and</para>
        /// <para>return in native format.</para>
        /// </summary>
        /// <param name="src">the stream from which to read data</param>
        /// <param name="value">a pointer filled in with the data read</param>
        /// <remarks>
        /// <para>SDL byteswaps the data only if necessary, so the data returned will be in</para>
        /// <para>the native byte order.</para>
        /// <para>SDL_TRUE on successful write, SDL_FALSE on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static bool ReadU16BE(global::SDL3Sharp.RWops src, ref ushort value)
        {
            var __arg0 = src is null ? __IntPtr.Zero : src.__Instance;
            fixed (ushort* __value1 = &value)
            {
                var __arg1 = __value1;
                var ___ret = __Internal.ReadU16BE(__arg0, __arg1);
                return ___ret;
            }
        }

        /// <summary>
        /// <para>Use this function to read 16 bits of big-endian data from an SDL_RWops and</para>
        /// <para>return in native format.</para>
        /// </summary>
        /// <param name="src">the stream from which to read data</param>
        /// <param name="value">a pointer filled in with the data read</param>
        /// <remarks>
        /// <para>SDL byteswaps the data only if necessary, so the data returned will be in</para>
        /// <para>the native byte order.</para>
        /// <para>SDL_TRUE on successful write, SDL_FALSE on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static bool ReadS16BE(global::SDL3Sharp.RWops src, ref short value)
        {
            var __arg0 = src is null ? __IntPtr.Zero : src.__Instance;
            fixed (short* __value1 = &value)
            {
                var __arg1 = __value1;
                var ___ret = __Internal.ReadS16BE(__arg0, __arg1);
                return ___ret;
            }
        }

        /// <summary>
        /// <para>Use this function to read 32 bits of little-endian data from an SDL_RWops</para>
        /// <para>and return in native format.</para>
        /// </summary>
        /// <param name="src">the stream from which to read data</param>
        /// <param name="value">a pointer filled in with the data read</param>
        /// <remarks>
        /// <para>SDL byteswaps the data only if necessary, so the data returned will be in</para>
        /// <para>the native byte order.</para>
        /// <para>SDL_TRUE on successful write, SDL_FALSE on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static bool ReadU32LE(global::SDL3Sharp.RWops src, ref uint value)
        {
            var __arg0 = src is null ? __IntPtr.Zero : src.__Instance;
            fixed (uint* __value1 = &value)
            {
                var __arg1 = __value1;
                var ___ret = __Internal.ReadU32LE(__arg0, __arg1);
                return ___ret;
            }
        }

        /// <summary>
        /// <para>Use this function to read 32 bits of little-endian data from an SDL_RWops</para>
        /// <para>and return in native format.</para>
        /// </summary>
        /// <param name="src">the stream from which to read data</param>
        /// <param name="value">a pointer filled in with the data read</param>
        /// <remarks>
        /// <para>SDL byteswaps the data only if necessary, so the data returned will be in</para>
        /// <para>the native byte order.</para>
        /// <para>SDL_TRUE on successful write, SDL_FALSE on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static bool ReadS32LE(global::SDL3Sharp.RWops src, ref int value)
        {
            var __arg0 = src is null ? __IntPtr.Zero : src.__Instance;
            fixed (int* __value1 = &value)
            {
                var __arg1 = __value1;
                var ___ret = __Internal.ReadS32LE(__arg0, __arg1);
                return ___ret;
            }
        }

        /// <summary>
        /// <para>Use this function to read 32 bits of big-endian data from an SDL_RWops and</para>
        /// <para>return in native format.</para>
        /// </summary>
        /// <param name="src">the stream from which to read data</param>
        /// <param name="value">a pointer filled in with the data read</param>
        /// <remarks>
        /// <para>SDL byteswaps the data only if necessary, so the data returned will be in</para>
        /// <para>the native byte order.</para>
        /// <para>SDL_TRUE on successful write, SDL_FALSE on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static bool ReadU32BE(global::SDL3Sharp.RWops src, ref uint value)
        {
            var __arg0 = src is null ? __IntPtr.Zero : src.__Instance;
            fixed (uint* __value1 = &value)
            {
                var __arg1 = __value1;
                var ___ret = __Internal.ReadU32BE(__arg0, __arg1);
                return ___ret;
            }
        }

        /// <summary>
        /// <para>Use this function to read 32 bits of big-endian data from an SDL_RWops and</para>
        /// <para>return in native format.</para>
        /// </summary>
        /// <param name="src">the stream from which to read data</param>
        /// <param name="value">a pointer filled in with the data read</param>
        /// <remarks>
        /// <para>SDL byteswaps the data only if necessary, so the data returned will be in</para>
        /// <para>the native byte order.</para>
        /// <para>SDL_TRUE on successful write, SDL_FALSE on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static bool ReadS32BE(global::SDL3Sharp.RWops src, ref int value)
        {
            var __arg0 = src is null ? __IntPtr.Zero : src.__Instance;
            fixed (int* __value1 = &value)
            {
                var __arg1 = __value1;
                var ___ret = __Internal.ReadS32BE(__arg0, __arg1);
                return ___ret;
            }
        }

        /// <summary>
        /// <para>Use this function to read 64 bits of little-endian data from an SDL_RWops</para>
        /// <para>and return in native format.</para>
        /// </summary>
        /// <param name="src">the stream from which to read data</param>
        /// <param name="value">a pointer filled in with the data read</param>
        /// <remarks>
        /// <para>SDL byteswaps the data only if necessary, so the data returned will be in</para>
        /// <para>the native byte order.</para>
        /// <para>SDL_TRUE on successful write, SDL_FALSE on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static bool ReadU64LE(global::SDL3Sharp.RWops src, ref ulong value)
        {
            var __arg0 = src is null ? __IntPtr.Zero : src.__Instance;
            fixed (ulong* __value1 = &value)
            {
                var __arg1 = __value1;
                var ___ret = __Internal.ReadU64LE(__arg0, __arg1);
                return ___ret;
            }
        }

        /// <summary>
        /// <para>Use this function to read 64 bits of little-endian data from an SDL_RWops</para>
        /// <para>and return in native format.</para>
        /// </summary>
        /// <param name="src">the stream from which to read data</param>
        /// <param name="value">a pointer filled in with the data read</param>
        /// <remarks>
        /// <para>SDL byteswaps the data only if necessary, so the data returned will be in</para>
        /// <para>the native byte order.</para>
        /// <para>SDL_TRUE on successful write, SDL_FALSE on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static bool ReadS64LE(global::SDL3Sharp.RWops src, ref long value)
        {
            var __arg0 = src is null ? __IntPtr.Zero : src.__Instance;
            fixed (long* __value1 = &value)
            {
                var __arg1 = __value1;
                var ___ret = __Internal.ReadS64LE(__arg0, __arg1);
                return ___ret;
            }
        }

        /// <summary>
        /// <para>Use this function to read 64 bits of big-endian data from an SDL_RWops and</para>
        /// <para>return in native format.</para>
        /// </summary>
        /// <param name="src">the stream from which to read data</param>
        /// <param name="value">a pointer filled in with the data read</param>
        /// <remarks>
        /// <para>SDL byteswaps the data only if necessary, so the data returned will be in</para>
        /// <para>the native byte order.</para>
        /// <para>SDL_TRUE on successful write, SDL_FALSE on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static bool ReadU64BE(global::SDL3Sharp.RWops src, ref ulong value)
        {
            var __arg0 = src is null ? __IntPtr.Zero : src.__Instance;
            fixed (ulong* __value1 = &value)
            {
                var __arg1 = __value1;
                var ___ret = __Internal.ReadU64BE(__arg0, __arg1);
                return ___ret;
            }
        }

        /// <summary>
        /// <para>Use this function to read 64 bits of big-endian data from an SDL_RWops and</para>
        /// <para>return in native format.</para>
        /// </summary>
        /// <param name="src">the stream from which to read data</param>
        /// <param name="value">a pointer filled in with the data read</param>
        /// <remarks>
        /// <para>SDL byteswaps the data only if necessary, so the data returned will be in</para>
        /// <para>the native byte order.</para>
        /// <para>SDL_TRUE on successful write, SDL_FALSE on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static bool ReadS64BE(global::SDL3Sharp.RWops src, ref long value)
        {
            var __arg0 = src is null ? __IntPtr.Zero : src.__Instance;
            fixed (long* __value1 = &value)
            {
                var __arg1 = __value1;
                var ___ret = __Internal.ReadS64BE(__arg0, __arg1);
                return ___ret;
            }
        }

        /// <summary>Use this function to write a byte to an SDL_RWops.</summary>
        /// <param name="dst">the SDL_RWops to write to</param>
        /// <param name="value">the byte value to write</param>
        /// <remarks>
        /// <para>SDL_TRUE on successful write, SDL_FALSE on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static bool WriteU8(global::SDL3Sharp.RWops dst, byte value)
        {
            var __arg0 = dst is null ? __IntPtr.Zero : dst.__Instance;
            var ___ret = __Internal.WriteU8(__arg0, value);
            return ___ret;
        }

        /// <summary>
        /// <para>Use this function to write 16 bits in native format to an SDL_RWops as</para>
        /// <para>little-endian data.</para>
        /// </summary>
        /// <param name="dst">the stream to which data will be written</param>
        /// <param name="value">the data to be written, in native format</param>
        /// <remarks>
        /// <para>SDL byteswaps the data only if necessary, so the application always</para>
        /// <para>specifies native format, and the data written will be in little-endian</para>
        /// <para>format.</para>
        /// <para>SDL_TRUE on successful write, SDL_FALSE on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static bool WriteU16LE(global::SDL3Sharp.RWops dst, ushort value)
        {
            var __arg0 = dst is null ? __IntPtr.Zero : dst.__Instance;
            var ___ret = __Internal.WriteU16LE(__arg0, value);
            return ___ret;
        }

        /// <summary>
        /// <para>Use this function to write 16 bits in native format to an SDL_RWops as</para>
        /// <para>little-endian data.</para>
        /// </summary>
        /// <param name="dst">the stream to which data will be written</param>
        /// <param name="value">the data to be written, in native format</param>
        /// <remarks>
        /// <para>SDL byteswaps the data only if necessary, so the application always</para>
        /// <para>specifies native format, and the data written will be in little-endian</para>
        /// <para>format.</para>
        /// <para>SDL_TRUE on successful write, SDL_FALSE on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static bool WriteS16LE(global::SDL3Sharp.RWops dst, short value)
        {
            var __arg0 = dst is null ? __IntPtr.Zero : dst.__Instance;
            var ___ret = __Internal.WriteS16LE(__arg0, value);
            return ___ret;
        }

        /// <summary>
        /// <para>Use this function to write 16 bits in native format to an SDL_RWops as</para>
        /// <para>big-endian data.</para>
        /// </summary>
        /// <param name="dst">the stream to which data will be written</param>
        /// <param name="value">the data to be written, in native format</param>
        /// <remarks>
        /// <para>SDL byteswaps the data only if necessary, so the application always</para>
        /// <para>specifies native format, and the data written will be in big-endian format.</para>
        /// <para>SDL_TRUE on successful write, SDL_FALSE on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static bool WriteU16BE(global::SDL3Sharp.RWops dst, ushort value)
        {
            var __arg0 = dst is null ? __IntPtr.Zero : dst.__Instance;
            var ___ret = __Internal.WriteU16BE(__arg0, value);
            return ___ret;
        }

        /// <summary>
        /// <para>Use this function to write 16 bits in native format to an SDL_RWops as</para>
        /// <para>big-endian data.</para>
        /// </summary>
        /// <param name="dst">the stream to which data will be written</param>
        /// <param name="value">the data to be written, in native format</param>
        /// <remarks>
        /// <para>SDL byteswaps the data only if necessary, so the application always</para>
        /// <para>specifies native format, and the data written will be in big-endian format.</para>
        /// <para>SDL_TRUE on successful write, SDL_FALSE on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static bool WriteS16BE(global::SDL3Sharp.RWops dst, short value)
        {
            var __arg0 = dst is null ? __IntPtr.Zero : dst.__Instance;
            var ___ret = __Internal.WriteS16BE(__arg0, value);
            return ___ret;
        }

        /// <summary>
        /// <para>Use this function to write 32 bits in native format to an SDL_RWops as</para>
        /// <para>little-endian data.</para>
        /// </summary>
        /// <param name="dst">the stream to which data will be written</param>
        /// <param name="value">the data to be written, in native format</param>
        /// <remarks>
        /// <para>SDL byteswaps the data only if necessary, so the application always</para>
        /// <para>specifies native format, and the data written will be in little-endian</para>
        /// <para>format.</para>
        /// <para>SDL_TRUE on successful write, SDL_FALSE on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static bool WriteU32LE(global::SDL3Sharp.RWops dst, uint value)
        {
            var __arg0 = dst is null ? __IntPtr.Zero : dst.__Instance;
            var ___ret = __Internal.WriteU32LE(__arg0, value);
            return ___ret;
        }

        /// <summary>
        /// <para>Use this function to write 32 bits in native format to an SDL_RWops as</para>
        /// <para>little-endian data.</para>
        /// </summary>
        /// <param name="dst">the stream to which data will be written</param>
        /// <param name="value">the data to be written, in native format</param>
        /// <remarks>
        /// <para>SDL byteswaps the data only if necessary, so the application always</para>
        /// <para>specifies native format, and the data written will be in little-endian</para>
        /// <para>format.</para>
        /// <para>SDL_TRUE on successful write, SDL_FALSE on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static bool WriteS32LE(global::SDL3Sharp.RWops dst, int value)
        {
            var __arg0 = dst is null ? __IntPtr.Zero : dst.__Instance;
            var ___ret = __Internal.WriteS32LE(__arg0, value);
            return ___ret;
        }

        /// <summary>
        /// <para>Use this function to write 32 bits in native format to an SDL_RWops as</para>
        /// <para>big-endian data.</para>
        /// </summary>
        /// <param name="dst">the stream to which data will be written</param>
        /// <param name="value">the data to be written, in native format</param>
        /// <remarks>
        /// <para>SDL byteswaps the data only if necessary, so the application always</para>
        /// <para>specifies native format, and the data written will be in big-endian format.</para>
        /// <para>SDL_TRUE on successful write, SDL_FALSE on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static bool WriteU32BE(global::SDL3Sharp.RWops dst, uint value)
        {
            var __arg0 = dst is null ? __IntPtr.Zero : dst.__Instance;
            var ___ret = __Internal.WriteU32BE(__arg0, value);
            return ___ret;
        }

        /// <summary>
        /// <para>Use this function to write 32 bits in native format to an SDL_RWops as</para>
        /// <para>big-endian data.</para>
        /// </summary>
        /// <param name="dst">the stream to which data will be written</param>
        /// <param name="value">the data to be written, in native format</param>
        /// <remarks>
        /// <para>SDL byteswaps the data only if necessary, so the application always</para>
        /// <para>specifies native format, and the data written will be in big-endian format.</para>
        /// <para>SDL_TRUE on successful write, SDL_FALSE on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static bool WriteS32BE(global::SDL3Sharp.RWops dst, int value)
        {
            var __arg0 = dst is null ? __IntPtr.Zero : dst.__Instance;
            var ___ret = __Internal.WriteS32BE(__arg0, value);
            return ___ret;
        }

        /// <summary>
        /// <para>Use this function to write 64 bits in native format to an SDL_RWops as</para>
        /// <para>little-endian data.</para>
        /// </summary>
        /// <param name="dst">the stream to which data will be written</param>
        /// <param name="value">the data to be written, in native format</param>
        /// <remarks>
        /// <para>SDL byteswaps the data only if necessary, so the application always</para>
        /// <para>specifies native format, and the data written will be in little-endian</para>
        /// <para>format.</para>
        /// <para>SDL_TRUE on successful write, SDL_FALSE on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static bool WriteU64LE(global::SDL3Sharp.RWops dst, ulong value)
        {
            var __arg0 = dst is null ? __IntPtr.Zero : dst.__Instance;
            var ___ret = __Internal.WriteU64LE(__arg0, value);
            return ___ret;
        }

        /// <summary>
        /// <para>Use this function to write 64 bits in native format to an SDL_RWops as</para>
        /// <para>little-endian data.</para>
        /// </summary>
        /// <param name="dst">the stream to which data will be written</param>
        /// <param name="value">the data to be written, in native format</param>
        /// <remarks>
        /// <para>SDL byteswaps the data only if necessary, so the application always</para>
        /// <para>specifies native format, and the data written will be in little-endian</para>
        /// <para>format.</para>
        /// <para>SDL_TRUE on successful write, SDL_FALSE on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static bool WriteS64LE(global::SDL3Sharp.RWops dst, long value)
        {
            var __arg0 = dst is null ? __IntPtr.Zero : dst.__Instance;
            var ___ret = __Internal.WriteS64LE(__arg0, value);
            return ___ret;
        }

        /// <summary>
        /// <para>Use this function to write 64 bits in native format to an SDL_RWops as</para>
        /// <para>big-endian data.</para>
        /// </summary>
        /// <param name="dst">the stream to which data will be written</param>
        /// <param name="value">the data to be written, in native format</param>
        /// <remarks>
        /// <para>SDL byteswaps the data only if necessary, so the application always</para>
        /// <para>specifies native format, and the data written will be in big-endian format.</para>
        /// <para>SDL_TRUE on successful write, SDL_FALSE on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static bool WriteU64BE(global::SDL3Sharp.RWops dst, ulong value)
        {
            var __arg0 = dst is null ? __IntPtr.Zero : dst.__Instance;
            var ___ret = __Internal.WriteU64BE(__arg0, value);
            return ___ret;
        }

        /// <summary>
        /// <para>Use this function to write 64 bits in native format to an SDL_RWops as</para>
        /// <para>big-endian data.</para>
        /// </summary>
        /// <param name="dst">the stream to which data will be written</param>
        /// <param name="value">the data to be written, in native format</param>
        /// <remarks>
        /// <para>SDL byteswaps the data only if necessary, so the application always</para>
        /// <para>specifies native format, and the data written will be in big-endian format.</para>
        /// <para>SDL_TRUE on successful write, SDL_FALSE on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static bool WriteS64BE(global::SDL3Sharp.RWops dst, long value)
        {
            var __arg0 = dst is null ? __IntPtr.Zero : dst.__Instance;
            var ___ret = __Internal.WriteS64BE(__arg0, value);
            return ___ret;
        }
    }
}
