// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required
#pragma warning disable CS9084 // Struct member returns 'this' or other instance members by reference

namespace SDL3Sharp
{
    /// <summary>Structure that represents a haptic direction.</summary>
    /// <remarks>
    /// <para>This is the direction where the force comes from,</para>
    /// <para>instead of the direction in which the force is exerted.</para>
    /// <para>Directions can be specified by:</para>
    /// <para>- ::SDL_HAPTIC_POLAR : Specified by polar coordinates.</para>
    /// <para>- ::SDL_HAPTIC_CARTESIAN : Specified by cartesian coordinates.</para>
    /// <para>- ::SDL_HAPTIC_SPHERICAL : Specified by spherical coordinates.</para>
    /// <para>Cardinal directions of the haptic device are relative to the positioning</para>
    /// <para>of the device.  North is considered to be away from the user.</para>
    /// <para>The following diagram represents the cardinal directions:</para>
    /// <para>If type is ::SDL_HAPTIC_POLAR, direction is encoded by hundredths of a</para>
    /// <para>degree starting north and turning clockwise.  ::SDL_HAPTIC_POLAR only uses</para>
    /// <para>the firstparameter.  The cardinal directions would be:</para>
    /// <para>- North: 0 (0 degrees)</para>
    /// <para>- East: 9000 (90 degrees)</para>
    /// <para>- South: 18000 (180 degrees)</para>
    /// <para>- West: 27000 (270 degrees)</para>
    /// <para>If type is ::SDL_HAPTIC_CARTESIAN, direction is encoded by three positions</para>
    /// <para>(X axis, Y axis and Z axis (with 3 axes)).  ::SDL_HAPTIC_CARTESIAN uses</para>
    /// <para>the first threeparameters.  The cardinal directions would be:</para>
    /// <para>- North:  0,-1, 0</para>
    /// <para>- East:   1, 0, 0</para>
    /// <para>- South:  0, 1, 0</para>
    /// <para>- West:  -1, 0, 0</para>
    /// <para>The Z axis represents the height of the effect if supported, otherwise</para>
    /// <para>it's unused.  In cartesian encoding (1, 2) would be the same as (2, 4), you</para>
    /// <para>can use any multiple you want, only the direction matters.</para>
    /// <para>If type is ::SDL_HAPTIC_SPHERICAL, direction is encoded by two rotations.</para>
    /// <para>The first twoparameters are used.  Theparameters are as</para>
    /// <para>follows (all values are in hundredths of degrees):</para>
    /// <para>- Degrees from (1, 0) rotated towards (0, 1).</para>
    /// <para>- Degrees towards (0, 0, 1) (device needs at least 3 axes).</para>
    /// <para>Example of force coming from the south with all encodings (force coming</para>
    /// <para>from the south means the user will have to pull the stick to counteract):</para>
    /// <para>SDL_HAPTIC_POLAR</para>
    /// <para>SDL_HAPTIC_CARTESIAN</para>
    /// <para>SDL_HAPTIC_SPHERICAL</para>
    /// <para>SDL_HAPTIC_STEERING_AXIS</para>
    /// <para>SDL_HapticEffect</para>
    /// <para>SDL_GetNumHapticAxes</para>
    /// </remarks>
    /// <summary>A structure containing a template for a Constant effect.</summary>
    /// <remarks>
    /// <para>This struct is exclusively for the ::SDL_HAPTIC_CONSTANT effect.</para>
    /// <para>A constant effect applies a constant force in the specified direction</para>
    /// <para>to the joystick.</para>
    /// <para>SDL_HAPTIC_CONSTANT</para>
    /// <para>SDL_HapticEffect</para>
    /// </remarks>
    /// <summary>A structure containing a template for a Periodic effect.</summary>
    /// <remarks>
    /// <para>The struct handles the following effects:</para>
    /// <para>- ::SDL_HAPTIC_SINE</para>
    /// <para>- ::SDL_HAPTIC_SQUARE</para>
    /// <para>- ::SDL_HAPTIC_TRIANGLE</para>
    /// <para>- ::SDL_HAPTIC_SAWTOOTHUP</para>
    /// <para>- ::SDL_HAPTIC_SAWTOOTHDOWN</para>
    /// <para>A periodic effect consists in a wave-shaped effect that repeats itself</para>
    /// <para>over time.  The type determines the shape of the wave and the parameters</para>
    /// <para>determine the dimensions of the wave.</para>
    /// <para>Phase is given by hundredth of a degree meaning that giving the phase a value</para>
    /// <para>of 9000 will displace it 25% of its period.  Here are sample values:</para>
    /// <para>-     0: No phase displacement.</para>
    /// <para>-  9000: Displaced 25% of its period.</para>
    /// <para>- 18000: Displaced 50% of its period.</para>
    /// <para>- 27000: Displaced 75% of its period.</para>
    /// <para>- 36000: Displaced 100% of its period, same as 0, but 0 is preferred.</para>
    /// <para>Examples:</para>
    /// <para>SDL_HAPTIC_SINE</para>
    /// <para>SDL_HAPTIC_SQUARE</para>
    /// <para>SDL_HAPTIC_TRIANGLE</para>
    /// <para>SDL_HAPTIC_SAWTOOTHUP</para>
    /// <para>SDL_HAPTIC_SAWTOOTHDOWN</para>
    /// <para>SDL_HapticEffect</para>
    /// </remarks>
    /// <summary>A structure containing a template for a Condition effect.</summary>
    /// <remarks>
    /// <para>The struct handles the following effects:</para>
    /// <para>- ::SDL_HAPTIC_SPRING: Effect based on axes position.</para>
    /// <para>- ::SDL_HAPTIC_DAMPER: Effect based on axes velocity.</para>
    /// <para>- ::SDL_HAPTIC_INERTIA: Effect based on axes acceleration.</para>
    /// <para>- ::SDL_HAPTIC_FRICTION: Effect based on axes movement.</para>
    /// <para>Direction is handled by condition internals instead of a direction member.</para>
    /// <para>The condition effect specific members have three parameters.  The first</para>
    /// <para>refers to the X axis, the second refers to the Y axis and the third</para>
    /// <para>refers to the Z axis.  The right terms refer to the positive side of the</para>
    /// <para>axis and the left terms refer to the negative side of the axis.  Please</para>
    /// <para>refer to the ::SDL_HapticDirection diagram for which side is positive and</para>
    /// <para>which is negative.</para>
    /// <para>SDL_HapticDirection</para>
    /// <para>SDL_HAPTIC_SPRING</para>
    /// <para>SDL_HAPTIC_DAMPER</para>
    /// <para>SDL_HAPTIC_INERTIA</para>
    /// <para>SDL_HAPTIC_FRICTION</para>
    /// <para>SDL_HapticEffect</para>
    /// </remarks>
    /// <summary>A structure containing a template for a Ramp effect.</summary>
    /// <remarks>
    /// <para>This struct is exclusively for the ::SDL_HAPTIC_RAMP effect.</para>
    /// <para>The ramp effect starts at start strength and ends at end strength.</para>
    /// <para>It augments in linear fashion.  If you use attack and fade with a ramp</para>
    /// <para>the effects get added to the ramp effect making the effect become</para>
    /// <para>quadratic instead of linear.</para>
    /// <para>SDL_HAPTIC_RAMP</para>
    /// <para>SDL_HapticEffect</para>
    /// </remarks>
    /// <summary>A structure containing a template for a Left/Right effect.</summary>
    /// <remarks>
    /// <para>This struct is exclusively for the ::SDL_HAPTIC_LEFTRIGHT effect.</para>
    /// <para>The Left/Right effect is used to explicitly control the large and small</para>
    /// <para>motors, commonly found in modern game controllers. The small (right) motor</para>
    /// <para>is high frequency, and the large (left) motor is low frequency.</para>
    /// <para>SDL_HAPTIC_LEFTRIGHT</para>
    /// <para>SDL_HapticEffect</para>
    /// </remarks>
    /// <summary>A structure containing a template for the ::SDL_HAPTIC_CUSTOM effect.</summary>
    /// <remarks>
    /// <para>This struct is exclusively for the ::SDL_HAPTIC_CUSTOM effect.</para>
    /// <para>A custom force feedback effect is much like a periodic effect, where the</para>
    /// <para>application can define its exact shape.  You will have to allocate the</para>
    /// <para>data yourself.  Data should consist of channels * samples Uint16 samples.</para>
    /// <para>If channels is one, the effect is rotated using the defined direction.</para>
    /// <para>Otherwise it uses the samples in data for the different axes.</para>
    /// <para>SDL_HAPTIC_CUSTOM</para>
    /// <para>SDL_HapticEffect</para>
    /// </remarks>
    /// <summary>The generic template for any haptic effect.</summary>
    /// <remarks>
    /// <para>All values max at 32767 (0x7FFF).  Signed values also can be negative.</para>
    /// <para>Time values unless specified otherwise are in milliseconds.</para>
    /// <para>You can also pass ::SDL_HAPTIC_INFINITY to length instead of a 0-32767</para>
    /// <para>value.  Neither delay, interval, attack_length nor fade_length support</para>
    /// <para>::SDL_HAPTIC_INFINITY.  Fade will also not be used since effect never ends.</para>
    /// <para>Additionally, the ::SDL_HAPTIC_RAMP effect does not support a duration of</para>
    /// <para>::SDL_HAPTIC_INFINITY.</para>
    /// <para>Button triggers may not be supported on all devices, it is advised to not</para>
    /// <para>use them if possible.  Buttons start at index 1 instead of index 0 like</para>
    /// <para>the joystick.</para>
    /// <para>If both attack_length and fade_level are 0, the envelope is not used,</para>
    /// <para>otherwise both values are used.</para>
    /// <para>Common parts:</para>
    /// <para>Here we have an example of a constant effect evolution in time:</para>
    /// <para>Note either the attack_level or the fade_level may be above the actual</para>
    /// <para>effect level.</para>
    /// <para>SDL_HapticConstant</para>
    /// <para>SDL_HapticPeriodic</para>
    /// <para>SDL_HapticCondition</para>
    /// <para>SDL_HapticRamp</para>
    /// <para>SDL_HapticLeftRight</para>
    /// <para>SDL_HapticCustom</para>
    /// </remarks>
    /// <summary>This is a unique ID for a haptic device for the time it is connected to the system, and is never reused for the lifetime of the application. If the haptic device is disconnected and reconnected, it will get a new ID.</summary>
    /// <remarks>The ID value starts at 1 and increments from there. The value 0 is an invalid ID.</remarks>
    /// <summary>The haptic structure used to identify an SDL haptic.</summary>
    /// <remarks>
    /// <para>SDL_OpenHaptic</para>
    /// <para>SDL_OpenHapticFromJoystick</para>
    /// <para>SDL_CloseHaptic</para>
    /// </remarks>
    public unsafe partial class Haptic
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.Haptic> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.Haptic>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.Haptic managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.Haptic managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Haptic __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Haptic(native.ToPointer(), skipVTables);
        }

        internal static Haptic __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Haptic)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Haptic __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Haptic(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Haptic(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Haptic(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    /// <summary>Structure that represents a haptic direction.</summary>
    /// <remarks>
    /// <para>This is the direction where the force comes from,</para>
    /// <para>instead of the direction in which the force is exerted.</para>
    /// <para>Directions can be specified by:</para>
    /// <para>- ::SDL_HAPTIC_POLAR : Specified by polar coordinates.</para>
    /// <para>- ::SDL_HAPTIC_CARTESIAN : Specified by cartesian coordinates.</para>
    /// <para>- ::SDL_HAPTIC_SPHERICAL : Specified by spherical coordinates.</para>
    /// <para>Cardinal directions of the haptic device are relative to the positioning</para>
    /// <para>of the device.  North is considered to be away from the user.</para>
    /// <para>The following diagram represents the cardinal directions:</para>
    /// <para>If type is ::SDL_HAPTIC_POLAR, direction is encoded by hundredths of a</para>
    /// <para>degree starting north and turning clockwise.  ::SDL_HAPTIC_POLAR only uses</para>
    /// <para>the firstparameter.  The cardinal directions would be:</para>
    /// <para>- North: 0 (0 degrees)</para>
    /// <para>- East: 9000 (90 degrees)</para>
    /// <para>- South: 18000 (180 degrees)</para>
    /// <para>- West: 27000 (270 degrees)</para>
    /// <para>If type is ::SDL_HAPTIC_CARTESIAN, direction is encoded by three positions</para>
    /// <para>(X axis, Y axis and Z axis (with 3 axes)).  ::SDL_HAPTIC_CARTESIAN uses</para>
    /// <para>the first threeparameters.  The cardinal directions would be:</para>
    /// <para>- North:  0,-1, 0</para>
    /// <para>- East:   1, 0, 0</para>
    /// <para>- South:  0, 1, 0</para>
    /// <para>- West:  -1, 0, 0</para>
    /// <para>The Z axis represents the height of the effect if supported, otherwise</para>
    /// <para>it's unused.  In cartesian encoding (1, 2) would be the same as (2, 4), you</para>
    /// <para>can use any multiple you want, only the direction matters.</para>
    /// <para>If type is ::SDL_HAPTIC_SPHERICAL, direction is encoded by two rotations.</para>
    /// <para>The first twoparameters are used.  Theparameters are as</para>
    /// <para>follows (all values are in hundredths of degrees):</para>
    /// <para>- Degrees from (1, 0) rotated towards (0, 1).</para>
    /// <para>- Degrees towards (0, 0, 1) (device needs at least 3 axes).</para>
    /// <para>Example of force coming from the south with all encodings (force coming</para>
    /// <para>from the south means the user will have to pull the stick to counteract):</para>
    /// <para>SDL_HAPTIC_POLAR</para>
    /// <para>SDL_HAPTIC_CARTESIAN</para>
    /// <para>SDL_HAPTIC_SPHERICAL</para>
    /// <para>SDL_HAPTIC_STEERING_AXIS</para>
    /// <para>SDL_HapticEffect</para>
    /// <para>SDL_GetNumHapticAxes</para>
    /// </remarks>
    public unsafe partial class HapticDirection : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16, Pack = 8)]
        public partial struct __Internal
        {
            internal byte type;
            internal fixed int dir[3];

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_HapticDirection@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.HapticDirection> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.HapticDirection>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.HapticDirection managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.HapticDirection managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static HapticDirection __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new HapticDirection(native.ToPointer(), skipVTables);
        }

        internal static HapticDirection __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (HapticDirection)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static HapticDirection __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new HapticDirection(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private HapticDirection(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected HapticDirection(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public HapticDirection()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.HapticDirection.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public HapticDirection(global::SDL3Sharp.HapticDirection _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.HapticDirection.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.HapticDirection.__Internal*) __Instance) = *((global::SDL3Sharp.HapticDirection.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>The type of encoding.</summary>
        public byte Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        /// <summary>The encoded direction.</summary>
        public int[] Dir
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->dir, 3);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 3; i++)
                        ((__Internal*)__Instance)->dir[i] = value[i];
                }
            }
        }
    }

    /// <summary>A structure containing a template for a Constant effect.</summary>
    /// <remarks>
    /// <para>This struct is exclusively for the ::SDL_HAPTIC_CONSTANT effect.</para>
    /// <para>A constant effect applies a constant force in the specified direction</para>
    /// <para>to the joystick.</para>
    /// <para>SDL_HAPTIC_CONSTANT</para>
    /// <para>SDL_HapticEffect</para>
    /// </remarks>
    public unsafe partial class HapticConstant : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 40, Pack = 8)]
        public partial struct __Internal
        {
            internal ushort type;
            internal global::SDL3Sharp.HapticDirection.__Internal direction;
            internal uint length;
            internal ushort delay;
            internal ushort button;
            internal ushort interval;
            internal short level;
            internal ushort attack_length;
            internal ushort attack_level;
            internal ushort fade_length;
            internal ushort fade_level;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_HapticConstant@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.HapticConstant> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.HapticConstant>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.HapticConstant managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.HapticConstant managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static HapticConstant __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new HapticConstant(native.ToPointer(), skipVTables);
        }

        internal static HapticConstant __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (HapticConstant)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static HapticConstant __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new HapticConstant(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private HapticConstant(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected HapticConstant(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public HapticConstant()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.HapticConstant.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public HapticConstant(global::SDL3Sharp.HapticConstant _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.HapticConstant.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.HapticConstant.__Internal*) __Instance) = *((global::SDL3Sharp.HapticConstant.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>::SDL_HAPTIC_CONSTANT</summary>
        public ushort Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        /// <summary>Direction of the effect.</summary>
        public global::SDL3Sharp.HapticDirection Direction
        {
            get
            {
                return global::SDL3Sharp.HapticDirection.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->direction));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->direction = *(global::SDL3Sharp.HapticDirection.__Internal*) value.__Instance;
            }
        }

        /// <summary>Duration of the effect.</summary>
        public uint Length
        {
            get
            {
                return ((__Internal*)__Instance)->length;
            }

            set
            {
                ((__Internal*)__Instance)->length = value;
            }
        }

        /// <summary>Delay before starting the effect.</summary>
        public ushort Delay
        {
            get
            {
                return ((__Internal*)__Instance)->delay;
            }

            set
            {
                ((__Internal*)__Instance)->delay = value;
            }
        }

        /// <summary>Button that triggers the effect.</summary>
        public ushort Button
        {
            get
            {
                return ((__Internal*)__Instance)->button;
            }

            set
            {
                ((__Internal*)__Instance)->button = value;
            }
        }

        /// <summary>How soon it can be triggered again after button.</summary>
        public ushort Interval
        {
            get
            {
                return ((__Internal*)__Instance)->interval;
            }

            set
            {
                ((__Internal*)__Instance)->interval = value;
            }
        }

        /// <summary>Strength of the constant effect.</summary>
        public short Level
        {
            get
            {
                return ((__Internal*)__Instance)->level;
            }

            set
            {
                ((__Internal*)__Instance)->level = value;
            }
        }

        /// <summary>Duration of the attack.</summary>
        public ushort AttackLength
        {
            get
            {
                return ((__Internal*)__Instance)->attack_length;
            }

            set
            {
                ((__Internal*)__Instance)->attack_length = value;
            }
        }

        /// <summary>Level at the start of the attack.</summary>
        public ushort AttackLevel
        {
            get
            {
                return ((__Internal*)__Instance)->attack_level;
            }

            set
            {
                ((__Internal*)__Instance)->attack_level = value;
            }
        }

        /// <summary>Duration of the fade.</summary>
        public ushort FadeLength
        {
            get
            {
                return ((__Internal*)__Instance)->fade_length;
            }

            set
            {
                ((__Internal*)__Instance)->fade_length = value;
            }
        }

        /// <summary>Level at the end of the fade.</summary>
        public ushort FadeLevel
        {
            get
            {
                return ((__Internal*)__Instance)->fade_level;
            }

            set
            {
                ((__Internal*)__Instance)->fade_level = value;
            }
        }
    }

    /// <summary>A structure containing a template for a Periodic effect.</summary>
    /// <remarks>
    /// <para>The struct handles the following effects:</para>
    /// <para>- ::SDL_HAPTIC_SINE</para>
    /// <para>- ::SDL_HAPTIC_SQUARE</para>
    /// <para>- ::SDL_HAPTIC_TRIANGLE</para>
    /// <para>- ::SDL_HAPTIC_SAWTOOTHUP</para>
    /// <para>- ::SDL_HAPTIC_SAWTOOTHDOWN</para>
    /// <para>A periodic effect consists in a wave-shaped effect that repeats itself</para>
    /// <para>over time.  The type determines the shape of the wave and the parameters</para>
    /// <para>determine the dimensions of the wave.</para>
    /// <para>Phase is given by hundredth of a degree meaning that giving the phase a value</para>
    /// <para>of 9000 will displace it 25% of its period.  Here are sample values:</para>
    /// <para>-     0: No phase displacement.</para>
    /// <para>-  9000: Displaced 25% of its period.</para>
    /// <para>- 18000: Displaced 50% of its period.</para>
    /// <para>- 27000: Displaced 75% of its period.</para>
    /// <para>- 36000: Displaced 100% of its period, same as 0, but 0 is preferred.</para>
    /// <para>Examples:</para>
    /// <para>SDL_HAPTIC_SINE</para>
    /// <para>SDL_HAPTIC_SQUARE</para>
    /// <para>SDL_HAPTIC_TRIANGLE</para>
    /// <para>SDL_HAPTIC_SAWTOOTHUP</para>
    /// <para>SDL_HAPTIC_SAWTOOTHDOWN</para>
    /// <para>SDL_HapticEffect</para>
    /// </remarks>
    public unsafe partial class HapticPeriodic : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 48, Pack = 8)]
        public partial struct __Internal
        {
            internal ushort type;
            internal global::SDL3Sharp.HapticDirection.__Internal direction;
            internal uint length;
            internal ushort delay;
            internal ushort button;
            internal ushort interval;
            internal ushort period;
            internal short magnitude;
            internal short offset;
            internal ushort phase;
            internal ushort attack_length;
            internal ushort attack_level;
            internal ushort fade_length;
            internal ushort fade_level;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_HapticPeriodic@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.HapticPeriodic> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.HapticPeriodic>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.HapticPeriodic managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.HapticPeriodic managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static HapticPeriodic __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new HapticPeriodic(native.ToPointer(), skipVTables);
        }

        internal static HapticPeriodic __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (HapticPeriodic)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static HapticPeriodic __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new HapticPeriodic(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private HapticPeriodic(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected HapticPeriodic(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public HapticPeriodic()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.HapticPeriodic.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public HapticPeriodic(global::SDL3Sharp.HapticPeriodic _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.HapticPeriodic.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.HapticPeriodic.__Internal*) __Instance) = *((global::SDL3Sharp.HapticPeriodic.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>::SDL_HAPTIC_SINE, ::SDL_HAPTIC_SQUARE</para>
        /// <para>::SDL_HAPTIC_TRIANGLE, ::SDL_HAPTIC_SAWTOOTHUP or</para>
        /// <para>::SDL_HAPTIC_SAWTOOTHDOWN</para>
        /// </summary>
        public ushort Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        /// <summary>Direction of the effect.</summary>
        public global::SDL3Sharp.HapticDirection Direction
        {
            get
            {
                return global::SDL3Sharp.HapticDirection.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->direction));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->direction = *(global::SDL3Sharp.HapticDirection.__Internal*) value.__Instance;
            }
        }

        /// <summary>Duration of the effect.</summary>
        public uint Length
        {
            get
            {
                return ((__Internal*)__Instance)->length;
            }

            set
            {
                ((__Internal*)__Instance)->length = value;
            }
        }

        /// <summary>Delay before starting the effect.</summary>
        public ushort Delay
        {
            get
            {
                return ((__Internal*)__Instance)->delay;
            }

            set
            {
                ((__Internal*)__Instance)->delay = value;
            }
        }

        /// <summary>Button that triggers the effect.</summary>
        public ushort Button
        {
            get
            {
                return ((__Internal*)__Instance)->button;
            }

            set
            {
                ((__Internal*)__Instance)->button = value;
            }
        }

        /// <summary>How soon it can be triggered again after button.</summary>
        public ushort Interval
        {
            get
            {
                return ((__Internal*)__Instance)->interval;
            }

            set
            {
                ((__Internal*)__Instance)->interval = value;
            }
        }

        /// <summary>Period of the wave.</summary>
        public ushort Period
        {
            get
            {
                return ((__Internal*)__Instance)->period;
            }

            set
            {
                ((__Internal*)__Instance)->period = value;
            }
        }

        /// <summary>Peak value; if negative, equivalent to 180 degrees extra phase shift.</summary>
        public short Magnitude
        {
            get
            {
                return ((__Internal*)__Instance)->magnitude;
            }

            set
            {
                ((__Internal*)__Instance)->magnitude = value;
            }
        }

        /// <summary>Mean value of the wave.</summary>
        public short Offset
        {
            get
            {
                return ((__Internal*)__Instance)->offset;
            }

            set
            {
                ((__Internal*)__Instance)->offset = value;
            }
        }

        /// <summary>Positive phase shift given by hundredth of a degree.</summary>
        public ushort Phase
        {
            get
            {
                return ((__Internal*)__Instance)->phase;
            }

            set
            {
                ((__Internal*)__Instance)->phase = value;
            }
        }

        /// <summary>Duration of the attack.</summary>
        public ushort AttackLength
        {
            get
            {
                return ((__Internal*)__Instance)->attack_length;
            }

            set
            {
                ((__Internal*)__Instance)->attack_length = value;
            }
        }

        /// <summary>Level at the start of the attack.</summary>
        public ushort AttackLevel
        {
            get
            {
                return ((__Internal*)__Instance)->attack_level;
            }

            set
            {
                ((__Internal*)__Instance)->attack_level = value;
            }
        }

        /// <summary>Duration of the fade.</summary>
        public ushort FadeLength
        {
            get
            {
                return ((__Internal*)__Instance)->fade_length;
            }

            set
            {
                ((__Internal*)__Instance)->fade_length = value;
            }
        }

        /// <summary>Level at the end of the fade.</summary>
        public ushort FadeLevel
        {
            get
            {
                return ((__Internal*)__Instance)->fade_level;
            }

            set
            {
                ((__Internal*)__Instance)->fade_level = value;
            }
        }
    }

    /// <summary>A structure containing a template for a Condition effect.</summary>
    /// <remarks>
    /// <para>The struct handles the following effects:</para>
    /// <para>- ::SDL_HAPTIC_SPRING: Effect based on axes position.</para>
    /// <para>- ::SDL_HAPTIC_DAMPER: Effect based on axes velocity.</para>
    /// <para>- ::SDL_HAPTIC_INERTIA: Effect based on axes acceleration.</para>
    /// <para>- ::SDL_HAPTIC_FRICTION: Effect based on axes movement.</para>
    /// <para>Direction is handled by condition internals instead of a direction member.</para>
    /// <para>The condition effect specific members have three parameters.  The first</para>
    /// <para>refers to the X axis, the second refers to the Y axis and the third</para>
    /// <para>refers to the Z axis.  The right terms refer to the positive side of the</para>
    /// <para>axis and the left terms refer to the negative side of the axis.  Please</para>
    /// <para>refer to the ::SDL_HapticDirection diagram for which side is positive and</para>
    /// <para>which is negative.</para>
    /// <para>SDL_HapticDirection</para>
    /// <para>SDL_HAPTIC_SPRING</para>
    /// <para>SDL_HAPTIC_DAMPER</para>
    /// <para>SDL_HAPTIC_INERTIA</para>
    /// <para>SDL_HAPTIC_FRICTION</para>
    /// <para>SDL_HapticEffect</para>
    /// </remarks>
    public unsafe partial class HapticCondition : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 68, Pack = 8)]
        public partial struct __Internal
        {
            internal ushort type;
            internal global::SDL3Sharp.HapticDirection.__Internal direction;
            internal uint length;
            internal ushort delay;
            internal ushort button;
            internal ushort interval;
            internal fixed ushort right_sat[3];
            internal fixed ushort left_sat[3];
            internal fixed short right_coeff[3];
            internal fixed short left_coeff[3];
            internal fixed ushort deadband[3];
            internal fixed short center[3];

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_HapticCondition@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.HapticCondition> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.HapticCondition>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.HapticCondition managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.HapticCondition managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static HapticCondition __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new HapticCondition(native.ToPointer(), skipVTables);
        }

        internal static HapticCondition __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (HapticCondition)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static HapticCondition __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new HapticCondition(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private HapticCondition(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected HapticCondition(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public HapticCondition()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.HapticCondition.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public HapticCondition(global::SDL3Sharp.HapticCondition _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.HapticCondition.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.HapticCondition.__Internal*) __Instance) = *((global::SDL3Sharp.HapticCondition.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>::SDL_HAPTIC_SPRING, ::SDL_HAPTIC_DAMPER,</para>
        /// <para>::SDL_HAPTIC_INERTIA or ::SDL_HAPTIC_FRICTION</para>
        /// </summary>
        public ushort Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        /// <summary>Direction of the effect - Not used ATM.</summary>
        public global::SDL3Sharp.HapticDirection Direction
        {
            get
            {
                return global::SDL3Sharp.HapticDirection.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->direction));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->direction = *(global::SDL3Sharp.HapticDirection.__Internal*) value.__Instance;
            }
        }

        /// <summary>Duration of the effect.</summary>
        public uint Length
        {
            get
            {
                return ((__Internal*)__Instance)->length;
            }

            set
            {
                ((__Internal*)__Instance)->length = value;
            }
        }

        /// <summary>Delay before starting the effect.</summary>
        public ushort Delay
        {
            get
            {
                return ((__Internal*)__Instance)->delay;
            }

            set
            {
                ((__Internal*)__Instance)->delay = value;
            }
        }

        /// <summary>Button that triggers the effect.</summary>
        public ushort Button
        {
            get
            {
                return ((__Internal*)__Instance)->button;
            }

            set
            {
                ((__Internal*)__Instance)->button = value;
            }
        }

        /// <summary>How soon it can be triggered again after button.</summary>
        public ushort Interval
        {
            get
            {
                return ((__Internal*)__Instance)->interval;
            }

            set
            {
                ((__Internal*)__Instance)->interval = value;
            }
        }

        /// <summary>Level when joystick is to the positive side; max 0xFFFF.</summary>
        public ushort[] RightSat
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<ushort>(((__Internal*)__Instance)->right_sat, 3);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 3; i++)
                        ((__Internal*)__Instance)->right_sat[i] = value[i];
                }
            }
        }

        /// <summary>Level when joystick is to the negative side; max 0xFFFF.</summary>
        public ushort[] LeftSat
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<ushort>(((__Internal*)__Instance)->left_sat, 3);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 3; i++)
                        ((__Internal*)__Instance)->left_sat[i] = value[i];
                }
            }
        }

        /// <summary>How fast to increase the force towards the positive side.</summary>
        public short[] RightCoeff
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<short>(((__Internal*)__Instance)->right_coeff, 3);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 3; i++)
                        ((__Internal*)__Instance)->right_coeff[i] = value[i];
                }
            }
        }

        /// <summary>How fast to increase the force towards the negative side.</summary>
        public short[] LeftCoeff
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<short>(((__Internal*)__Instance)->left_coeff, 3);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 3; i++)
                        ((__Internal*)__Instance)->left_coeff[i] = value[i];
                }
            }
        }

        /// <summary>Size of the dead zone; max 0xFFFF: whole axis-range when 0-centered.</summary>
        public ushort[] Deadband
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<ushort>(((__Internal*)__Instance)->deadband, 3);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 3; i++)
                        ((__Internal*)__Instance)->deadband[i] = value[i];
                }
            }
        }

        /// <summary>Position of the dead zone.</summary>
        public short[] Center
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<short>(((__Internal*)__Instance)->center, 3);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 3; i++)
                        ((__Internal*)__Instance)->center[i] = value[i];
                }
            }
        }
    }

    /// <summary>A structure containing a template for a Ramp effect.</summary>
    /// <remarks>
    /// <para>This struct is exclusively for the ::SDL_HAPTIC_RAMP effect.</para>
    /// <para>The ramp effect starts at start strength and ends at end strength.</para>
    /// <para>It augments in linear fashion.  If you use attack and fade with a ramp</para>
    /// <para>the effects get added to the ramp effect making the effect become</para>
    /// <para>quadratic instead of linear.</para>
    /// <para>SDL_HAPTIC_RAMP</para>
    /// <para>SDL_HapticEffect</para>
    /// </remarks>
    public unsafe partial class HapticRamp : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 44, Pack = 8)]
        public partial struct __Internal
        {
            internal ushort type;
            internal global::SDL3Sharp.HapticDirection.__Internal direction;
            internal uint length;
            internal ushort delay;
            internal ushort button;
            internal ushort interval;
            internal short start;
            internal short end;
            internal ushort attack_length;
            internal ushort attack_level;
            internal ushort fade_length;
            internal ushort fade_level;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_HapticRamp@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.HapticRamp> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.HapticRamp>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.HapticRamp managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.HapticRamp managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static HapticRamp __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new HapticRamp(native.ToPointer(), skipVTables);
        }

        internal static HapticRamp __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (HapticRamp)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static HapticRamp __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new HapticRamp(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private HapticRamp(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected HapticRamp(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public HapticRamp()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.HapticRamp.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public HapticRamp(global::SDL3Sharp.HapticRamp _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.HapticRamp.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.HapticRamp.__Internal*) __Instance) = *((global::SDL3Sharp.HapticRamp.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>::SDL_HAPTIC_RAMP</summary>
        public ushort Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        /// <summary>Direction of the effect.</summary>
        public global::SDL3Sharp.HapticDirection Direction
        {
            get
            {
                return global::SDL3Sharp.HapticDirection.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->direction));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->direction = *(global::SDL3Sharp.HapticDirection.__Internal*) value.__Instance;
            }
        }

        /// <summary>Duration of the effect.</summary>
        public uint Length
        {
            get
            {
                return ((__Internal*)__Instance)->length;
            }

            set
            {
                ((__Internal*)__Instance)->length = value;
            }
        }

        /// <summary>Delay before starting the effect.</summary>
        public ushort Delay
        {
            get
            {
                return ((__Internal*)__Instance)->delay;
            }

            set
            {
                ((__Internal*)__Instance)->delay = value;
            }
        }

        /// <summary>Button that triggers the effect.</summary>
        public ushort Button
        {
            get
            {
                return ((__Internal*)__Instance)->button;
            }

            set
            {
                ((__Internal*)__Instance)->button = value;
            }
        }

        /// <summary>How soon it can be triggered again after button.</summary>
        public ushort Interval
        {
            get
            {
                return ((__Internal*)__Instance)->interval;
            }

            set
            {
                ((__Internal*)__Instance)->interval = value;
            }
        }

        /// <summary>Beginning strength level.</summary>
        public short Start
        {
            get
            {
                return ((__Internal*)__Instance)->start;
            }

            set
            {
                ((__Internal*)__Instance)->start = value;
            }
        }

        /// <summary>Ending strength level.</summary>
        public short End
        {
            get
            {
                return ((__Internal*)__Instance)->end;
            }

            set
            {
                ((__Internal*)__Instance)->end = value;
            }
        }

        /// <summary>Duration of the attack.</summary>
        public ushort AttackLength
        {
            get
            {
                return ((__Internal*)__Instance)->attack_length;
            }

            set
            {
                ((__Internal*)__Instance)->attack_length = value;
            }
        }

        /// <summary>Level at the start of the attack.</summary>
        public ushort AttackLevel
        {
            get
            {
                return ((__Internal*)__Instance)->attack_level;
            }

            set
            {
                ((__Internal*)__Instance)->attack_level = value;
            }
        }

        /// <summary>Duration of the fade.</summary>
        public ushort FadeLength
        {
            get
            {
                return ((__Internal*)__Instance)->fade_length;
            }

            set
            {
                ((__Internal*)__Instance)->fade_length = value;
            }
        }

        /// <summary>Level at the end of the fade.</summary>
        public ushort FadeLevel
        {
            get
            {
                return ((__Internal*)__Instance)->fade_level;
            }

            set
            {
                ((__Internal*)__Instance)->fade_level = value;
            }
        }
    }

    /// <summary>A structure containing a template for a Left/Right effect.</summary>
    /// <remarks>
    /// <para>This struct is exclusively for the ::SDL_HAPTIC_LEFTRIGHT effect.</para>
    /// <para>The Left/Right effect is used to explicitly control the large and small</para>
    /// <para>motors, commonly found in modern game controllers. The small (right) motor</para>
    /// <para>is high frequency, and the large (left) motor is low frequency.</para>
    /// <para>SDL_HAPTIC_LEFTRIGHT</para>
    /// <para>SDL_HapticEffect</para>
    /// </remarks>
    public unsafe partial class HapticLeftRight : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12, Pack = 8)]
        public partial struct __Internal
        {
            internal ushort type;
            internal uint length;
            internal ushort large_magnitude;
            internal ushort small_magnitude;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_HapticLeftRight@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.HapticLeftRight> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.HapticLeftRight>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.HapticLeftRight managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.HapticLeftRight managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static HapticLeftRight __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new HapticLeftRight(native.ToPointer(), skipVTables);
        }

        internal static HapticLeftRight __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (HapticLeftRight)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static HapticLeftRight __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new HapticLeftRight(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private HapticLeftRight(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected HapticLeftRight(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public HapticLeftRight()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.HapticLeftRight.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public HapticLeftRight(global::SDL3Sharp.HapticLeftRight _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.HapticLeftRight.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.HapticLeftRight.__Internal*) __Instance) = *((global::SDL3Sharp.HapticLeftRight.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>::SDL_HAPTIC_LEFTRIGHT</summary>
        public ushort Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        /// <summary>Duration of the effect in milliseconds.</summary>
        public uint Length
        {
            get
            {
                return ((__Internal*)__Instance)->length;
            }

            set
            {
                ((__Internal*)__Instance)->length = value;
            }
        }

        /// <summary>Control of the large controller motor.</summary>
        public ushort LargeMagnitude
        {
            get
            {
                return ((__Internal*)__Instance)->large_magnitude;
            }

            set
            {
                ((__Internal*)__Instance)->large_magnitude = value;
            }
        }

        /// <summary>Control of the small controller motor.</summary>
        public ushort SmallMagnitude
        {
            get
            {
                return ((__Internal*)__Instance)->small_magnitude;
            }

            set
            {
                ((__Internal*)__Instance)->small_magnitude = value;
            }
        }
    }

    /// <summary>A structure containing a template for the ::SDL_HAPTIC_CUSTOM effect.</summary>
    /// <remarks>
    /// <para>This struct is exclusively for the ::SDL_HAPTIC_CUSTOM effect.</para>
    /// <para>A custom force feedback effect is much like a periodic effect, where the</para>
    /// <para>application can define its exact shape.  You will have to allocate the</para>
    /// <para>data yourself.  Data should consist of channels * samples Uint16 samples.</para>
    /// <para>If channels is one, the effect is rotated using the defined direction.</para>
    /// <para>Otherwise it uses the samples in data for the different axes.</para>
    /// <para>SDL_HAPTIC_CUSTOM</para>
    /// <para>SDL_HapticEffect</para>
    /// </remarks>
    public unsafe partial class HapticCustom : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 56, Pack = 8)]
        public partial struct __Internal
        {
            internal ushort type;
            internal global::SDL3Sharp.HapticDirection.__Internal direction;
            internal uint length;
            internal ushort delay;
            internal ushort button;
            internal ushort interval;
            internal byte channels;
            internal ushort period;
            internal ushort samples;
            internal __IntPtr data;
            internal ushort attack_length;
            internal ushort attack_level;
            internal ushort fade_length;
            internal ushort fade_level;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_HapticCustom@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.HapticCustom> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.HapticCustom>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.HapticCustom managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.HapticCustom managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static HapticCustom __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new HapticCustom(native.ToPointer(), skipVTables);
        }

        internal static HapticCustom __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (HapticCustom)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static HapticCustom __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new HapticCustom(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private HapticCustom(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected HapticCustom(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public HapticCustom()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.HapticCustom.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public HapticCustom(global::SDL3Sharp.HapticCustom _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.HapticCustom.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.HapticCustom.__Internal*) __Instance) = *((global::SDL3Sharp.HapticCustom.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>::SDL_HAPTIC_CUSTOM</summary>
        public ushort Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        /// <summary>Direction of the effect.</summary>
        public global::SDL3Sharp.HapticDirection Direction
        {
            get
            {
                return global::SDL3Sharp.HapticDirection.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->direction));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->direction = *(global::SDL3Sharp.HapticDirection.__Internal*) value.__Instance;
            }
        }

        /// <summary>Duration of the effect.</summary>
        public uint Length
        {
            get
            {
                return ((__Internal*)__Instance)->length;
            }

            set
            {
                ((__Internal*)__Instance)->length = value;
            }
        }

        /// <summary>Delay before starting the effect.</summary>
        public ushort Delay
        {
            get
            {
                return ((__Internal*)__Instance)->delay;
            }

            set
            {
                ((__Internal*)__Instance)->delay = value;
            }
        }

        /// <summary>Button that triggers the effect.</summary>
        public ushort Button
        {
            get
            {
                return ((__Internal*)__Instance)->button;
            }

            set
            {
                ((__Internal*)__Instance)->button = value;
            }
        }

        /// <summary>How soon it can be triggered again after button.</summary>
        public ushort Interval
        {
            get
            {
                return ((__Internal*)__Instance)->interval;
            }

            set
            {
                ((__Internal*)__Instance)->interval = value;
            }
        }

        /// <summary>Axes to use, minimum of one.</summary>
        public byte Channels
        {
            get
            {
                return ((__Internal*)__Instance)->channels;
            }

            set
            {
                ((__Internal*)__Instance)->channels = value;
            }
        }

        /// <summary>Sample periods.</summary>
        public ushort Period
        {
            get
            {
                return ((__Internal*)__Instance)->period;
            }

            set
            {
                ((__Internal*)__Instance)->period = value;
            }
        }

        /// <summary>Amount of samples.</summary>
        public ushort Samples
        {
            get
            {
                return ((__Internal*)__Instance)->samples;
            }

            set
            {
                ((__Internal*)__Instance)->samples = value;
            }
        }

        /// <summary>Should contain channels*samples items.</summary>
        public ushort* Data
        {
            get
            {
                return (ushort*) ((__Internal*)__Instance)->data;
            }

            set
            {
                ((__Internal*)__Instance)->data = (__IntPtr) value;
            }
        }

        /// <summary>Duration of the attack.</summary>
        public ushort AttackLength
        {
            get
            {
                return ((__Internal*)__Instance)->attack_length;
            }

            set
            {
                ((__Internal*)__Instance)->attack_length = value;
            }
        }

        /// <summary>Level at the start of the attack.</summary>
        public ushort AttackLevel
        {
            get
            {
                return ((__Internal*)__Instance)->attack_level;
            }

            set
            {
                ((__Internal*)__Instance)->attack_level = value;
            }
        }

        /// <summary>Duration of the fade.</summary>
        public ushort FadeLength
        {
            get
            {
                return ((__Internal*)__Instance)->fade_length;
            }

            set
            {
                ((__Internal*)__Instance)->fade_length = value;
            }
        }

        /// <summary>Level at the end of the fade.</summary>
        public ushort FadeLevel
        {
            get
            {
                return ((__Internal*)__Instance)->fade_level;
            }

            set
            {
                ((__Internal*)__Instance)->fade_level = value;
            }
        }
    }

    /// <summary>The generic template for any haptic effect.</summary>
    /// <remarks>
    /// <para>All values max at 32767 (0x7FFF).  Signed values also can be negative.</para>
    /// <para>Time values unless specified otherwise are in milliseconds.</para>
    /// <para>You can also pass ::SDL_HAPTIC_INFINITY to length instead of a 0-32767</para>
    /// <para>value.  Neither delay, interval, attack_length nor fade_length support</para>
    /// <para>::SDL_HAPTIC_INFINITY.  Fade will also not be used since effect never ends.</para>
    /// <para>Additionally, the ::SDL_HAPTIC_RAMP effect does not support a duration of</para>
    /// <para>::SDL_HAPTIC_INFINITY.</para>
    /// <para>Button triggers may not be supported on all devices, it is advised to not</para>
    /// <para>use them if possible.  Buttons start at index 1 instead of index 0 like</para>
    /// <para>the joystick.</para>
    /// <para>If both attack_length and fade_level are 0, the envelope is not used,</para>
    /// <para>otherwise both values are used.</para>
    /// <para>Common parts:</para>
    /// <para>Here we have an example of a constant effect evolution in time:</para>
    /// <para>Note either the attack_level or the fade_level may be above the actual</para>
    /// <para>effect level.</para>
    /// <para>SDL_HapticConstant</para>
    /// <para>SDL_HapticPeriodic</para>
    /// <para>SDL_HapticCondition</para>
    /// <para>SDL_HapticRamp</para>
    /// <para>SDL_HapticLeftRight</para>
    /// <para>SDL_HapticCustom</para>
    /// </remarks>
    public unsafe partial struct HapticEffect
    {
        [StructLayout(LayoutKind.Explicit, Size = 72, Pack = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal ushort type;

            [FieldOffset(0)]
            internal global::SDL3Sharp.HapticConstant.__Internal constant;

            [FieldOffset(0)]
            internal global::SDL3Sharp.HapticPeriodic.__Internal periodic;

            [FieldOffset(0)]
            internal global::SDL3Sharp.HapticCondition.__Internal condition;

            [FieldOffset(0)]
            internal global::SDL3Sharp.HapticRamp.__Internal ramp;

            [FieldOffset(0)]
            internal global::SDL3Sharp.HapticLeftRight.__Internal leftright;

            [FieldOffset(0)]
            internal global::SDL3Sharp.HapticCustom.__Internal custom;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_HapticEffect@@QEAA@AEBT0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        private HapticEffect.__Internal __instance;
        internal ref HapticEffect.__Internal __Instance => ref __instance;

        internal static HapticEffect __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new HapticEffect(native.ToPointer(), skipVTables);
        }

        internal static HapticEffect __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new HapticEffect(native, skipVTables);
        }

        private HapticEffect(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private HapticEffect(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::SDL3Sharp.HapticEffect.__Internal*) native;
        }

        public HapticEffect(global::SDL3Sharp.HapticEffect _0)
            : this()
        {
            var ____arg0 = _0.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
            }
        }

        /// <summary>Effect type.</summary>
        public ushort Type
        {
            get
            {
                return __instance.type;
            }

            set
            {
                __instance.type = value;
            }
        }

        /// <summary>Constant effect.</summary>
        public global::SDL3Sharp.HapticConstant Constant
        {
            get
            {
                return global::SDL3Sharp.HapticConstant.__CreateInstance(__instance.constant);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.constant = *(global::SDL3Sharp.HapticConstant.__Internal*) value.__Instance;
            }
        }

        /// <summary>Periodic effect.</summary>
        public global::SDL3Sharp.HapticPeriodic Periodic
        {
            get
            {
                return global::SDL3Sharp.HapticPeriodic.__CreateInstance(__instance.periodic);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.periodic = *(global::SDL3Sharp.HapticPeriodic.__Internal*) value.__Instance;
            }
        }

        /// <summary>Condition effect.</summary>
        public global::SDL3Sharp.HapticCondition Condition
        {
            get
            {
                return global::SDL3Sharp.HapticCondition.__CreateInstance(__instance.condition);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.condition = *(global::SDL3Sharp.HapticCondition.__Internal*) value.__Instance;
            }
        }

        /// <summary>Ramp effect.</summary>
        public global::SDL3Sharp.HapticRamp Ramp
        {
            get
            {
                return global::SDL3Sharp.HapticRamp.__CreateInstance(__instance.ramp);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.ramp = *(global::SDL3Sharp.HapticRamp.__Internal*) value.__Instance;
            }
        }

        /// <summary>Left/Right effect.</summary>
        public global::SDL3Sharp.HapticLeftRight Leftright
        {
            get
            {
                return global::SDL3Sharp.HapticLeftRight.__CreateInstance(__instance.leftright);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.leftright = *(global::SDL3Sharp.HapticLeftRight.__Internal*) value.__Instance;
            }
        }

        /// <summary>Custom effect.</summary>
        public global::SDL3Sharp.HapticCustom Custom
        {
            get
            {
                return global::SDL3Sharp.HapticCustom.__CreateInstance(__instance.custom);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.custom = *(global::SDL3Sharp.HapticCustom.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class SDL
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetHaptics", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint* GetHaptics(int* count);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetHapticInstanceName", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetHapticInstanceName(uint instance_id);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_OpenHaptic", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr OpenHaptic(uint instance_id);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetHapticFromInstanceID", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetHapticFromInstanceID(uint instance_id);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetHapticInstanceID", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint GetHapticInstanceID(__IntPtr haptic);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetHapticName", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetHapticName(__IntPtr haptic);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_IsMouseHaptic", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool IsMouseHaptic();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_OpenHapticFromMouse", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr OpenHapticFromMouse();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_IsJoystickHaptic", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool IsJoystickHaptic(__IntPtr joystick);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_OpenHapticFromJoystick", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr OpenHapticFromJoystick(__IntPtr joystick);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_CloseHaptic", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void CloseHaptic(__IntPtr haptic);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetMaxHapticEffects", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetMaxHapticEffects(__IntPtr haptic);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetMaxHapticEffectsPlaying", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetMaxHapticEffectsPlaying(__IntPtr haptic);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetHapticFeatures", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint GetHapticFeatures(__IntPtr haptic);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetNumHapticAxes", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetNumHapticAxes(__IntPtr haptic);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_HapticEffectSupported", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool HapticEffectSupported(__IntPtr haptic, __IntPtr effect);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_CreateHapticEffect", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int CreateHapticEffect(__IntPtr haptic, __IntPtr effect);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_UpdateHapticEffect", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int UpdateHapticEffect(__IntPtr haptic, int effect, __IntPtr data);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_RunHapticEffect", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int RunHapticEffect(__IntPtr haptic, int effect, uint iterations);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_StopHapticEffect", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int StopHapticEffect(__IntPtr haptic, int effect);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_DestroyHapticEffect", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void DestroyHapticEffect(__IntPtr haptic, int effect);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetHapticEffectStatus", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetHapticEffectStatus(__IntPtr haptic, int effect);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetHapticGain", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetHapticGain(__IntPtr haptic, int gain);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetHapticAutocenter", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetHapticAutocenter(__IntPtr haptic, int autocenter);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_PauseHaptic", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int PauseHaptic(__IntPtr haptic);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_ResumeHaptic", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int ResumeHaptic(__IntPtr haptic);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_StopHapticEffects", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int StopHapticEffects(__IntPtr haptic);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_HapticRumbleSupported", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool HapticRumbleSupported(__IntPtr haptic);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_InitHapticRumble", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int InitHapticRumble(__IntPtr haptic);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_PlayHapticRumble", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int PlayHapticRumble(__IntPtr haptic, float strength, uint length);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_StopHapticRumble", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int StopHapticRumble(__IntPtr haptic);
        }

        /// <summary>Get a list of currently connected haptic devices.</summary>
        /// <param name="count">a pointer filled in with the number of haptic devices returned</param>
        /// <remarks>
        /// <para>a 0 terminated array of haptic device instance IDs which should be</para>
        /// <para>freed with SDL_free(), or NULL on error; call SDL_GetError() for</para>
        /// <para>more details.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_OpenHaptic</para>
        /// </remarks>
        public static uint* GetHaptics(ref int count)
        {
            fixed (int* __count0 = &count)
            {
                var __arg0 = __count0;
                var ___ret = __Internal.GetHaptics(__arg0);
                return ___ret;
            }
        }

        /// <summary>Get the implementation dependent name of a haptic device.</summary>
        /// <param name="instance_id">the haptic device instance ID</param>
        /// <remarks>
        /// <para>This can be called before any haptic devices are opened.</para>
        /// <para>the name of the selected haptic device. If no name can be found,</para>
        /// <para>this function returns NULL; call SDL_GetError() for more</para>
        /// <para>information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetHapticName</para>
        /// <para>SDL_OpenHaptic</para>
        /// </remarks>
        public static string GetHapticInstanceName(uint instance_id)
        {
            var ___ret = __Internal.GetHapticInstanceName(instance_id);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Open a haptic device for use.</summary>
        /// <param name="instance_id">the haptic device instance ID</param>
        /// <remarks>
        /// <para>The index passed as an argument refers to the N'th haptic device on this</para>
        /// <para>system.</para>
        /// <para>When opening a haptic device, its gain will be set to maximum and</para>
        /// <para>autocenter will be disabled. To modify these values use SDL_SetHapticGain()</para>
        /// <para>and SDL_SetHapticAutocenter().</para>
        /// <para>the device identifier or NULL on failure; call SDL_GetError() for</para>
        /// <para>more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CloseHaptic</para>
        /// <para>SDL_GetHaptics</para>
        /// <para>SDL_OpenHapticFromJoystick</para>
        /// <para>SDL_OpenHapticFromMouse</para>
        /// <para>SDL_PauseHaptic</para>
        /// <para>SDL_SetHapticAutocenter</para>
        /// <para>SDL_SetHapticGain</para>
        /// <para>SDL_StopHapticEffects</para>
        /// </remarks>
        public static global::SDL3Sharp.Haptic OpenHaptic(uint instance_id)
        {
            var ___ret = __Internal.OpenHaptic(instance_id);
            var __result0 = global::SDL3Sharp.Haptic.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the SDL_Haptic associated with an instance ID, if it has been opened.</summary>
        /// <param name="instance_id">the instance ID to get the SDL_Haptic for</param>
        /// <remarks>
        /// <para>an SDL_Haptic on success or NULL on failure or if it hasn't been</para>
        /// <para>opened yet; call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static global::SDL3Sharp.Haptic GetHapticFromInstanceID(uint instance_id)
        {
            var ___ret = __Internal.GetHapticFromInstanceID(instance_id);
            var __result0 = global::SDL3Sharp.Haptic.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the instance ID of an opened haptic device.</summary>
        /// <param name="haptic">the SDL_Haptic device to query</param>
        /// <remarks>
        /// <para>the instance ID of the specified haptic device on success or 0 on</para>
        /// <para>failure; call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_OpenHaptic</para>
        /// </remarks>
        public static uint GetHapticInstanceID(global::SDL3Sharp.Haptic haptic)
        {
            var __arg0 = haptic is null ? __IntPtr.Zero : haptic.__Instance;
            var ___ret = __Internal.GetHapticInstanceID(__arg0);
            return ___ret;
        }

        /// <summary>Get the implementation dependent name of a haptic device.</summary>
        /// <param name="haptic">the SDL_Haptic obtained from SDL_OpenJoystick()</param>
        /// <remarks>
        /// <para>the name of the selected haptic device. If no name can be found,</para>
        /// <para>this function returns NULL; call SDL_GetError() for more</para>
        /// <para>information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetHapticInstanceName</para>
        /// <para>SDL_OpenHaptic</para>
        /// </remarks>
        public static string GetHapticName(global::SDL3Sharp.Haptic haptic)
        {
            var __arg0 = haptic is null ? __IntPtr.Zero : haptic.__Instance;
            var ___ret = __Internal.GetHapticName(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Query whether or not the current mouse has haptic capabilities.</summary>
        /// <remarks>
        /// <para>SDL_TRUE if the mouse is haptic or SDL_FALSE if it isn't.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_OpenHapticFromMouse</para>
        /// </remarks>
        public static bool IsMouseHaptic()
        {
            var ___ret = __Internal.IsMouseHaptic();
            return ___ret;
        }

        /// <summary>Try to open a haptic device from the current mouse.</summary>
        /// <remarks>
        /// <para>the haptic device identifier or NULL on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_OpenHaptic</para>
        /// <para>SDL_IsMouseHaptic</para>
        /// </remarks>
        public static global::SDL3Sharp.Haptic OpenHapticFromMouse()
        {
            var ___ret = __Internal.OpenHapticFromMouse();
            var __result0 = global::SDL3Sharp.Haptic.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Query if a joystick has haptic features.</summary>
        /// <param name="joystick">the SDL_Joystick to test for haptic capabilities</param>
        /// <remarks>
        /// <para>SDL_TRUE if the joystick is haptic or SDL_FALSE if it isn't.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_OpenHapticFromJoystick</para>
        /// </remarks>
        public static bool IsJoystickHaptic(global::SDL3Sharp.Joystick joystick)
        {
            var __arg0 = joystick is null ? __IntPtr.Zero : joystick.__Instance;
            var ___ret = __Internal.IsJoystickHaptic(__arg0);
            return ___ret;
        }

        /// <summary>Open a haptic device for use from a joystick device.</summary>
        /// <param name="joystick">the SDL_Joystick to create a haptic device from</param>
        /// <remarks>
        /// <para>You must still close the haptic device separately. It will not be closed</para>
        /// <para>with the joystick.</para>
        /// <para>When opened from a joystick you should first close the haptic device before</para>
        /// <para>closing the joystick device. If not, on some implementations the haptic</para>
        /// <para>device will also get unallocated and you'll be unable to use force feedback</para>
        /// <para>on that device.</para>
        /// <para>a valid haptic device identifier on success or NULL on failure;</para>
        /// <para>call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CloseHaptic</para>
        /// <para>SDL_OpenHaptic</para>
        /// <para>SDL_IsJoystickHaptic</para>
        /// </remarks>
        public static global::SDL3Sharp.Haptic OpenHapticFromJoystick(global::SDL3Sharp.Joystick joystick)
        {
            var __arg0 = joystick is null ? __IntPtr.Zero : joystick.__Instance;
            var ___ret = __Internal.OpenHapticFromJoystick(__arg0);
            var __result0 = global::SDL3Sharp.Haptic.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Close a haptic device previously opened with SDL_OpenHaptic().</summary>
        /// <param name="haptic">the SDL_Haptic device to close</param>
        /// <remarks>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_OpenHaptic</para>
        /// </remarks>
        public static void CloseHaptic(global::SDL3Sharp.Haptic haptic)
        {
            var __arg0 = haptic is null ? __IntPtr.Zero : haptic.__Instance;
            __Internal.CloseHaptic(__arg0);
        }

        /// <summary>Get the number of effects a haptic device can store.</summary>
        /// <param name="haptic">the SDL_Haptic device to query</param>
        /// <remarks>
        /// <para>On some platforms this isn't fully supported, and therefore is an</para>
        /// <para>approximation. Always check to see if your created effect was actually</para>
        /// <para>created and do not rely solely on SDL_GetMaxHapticEffects().</para>
        /// <para>the number of effects the haptic device can store or a negative</para>
        /// <para>error code on failure; call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetMaxHapticEffectsPlaying</para>
        /// <para>SDL_GetHapticFeatures</para>
        /// </remarks>
        public static int GetMaxHapticEffects(global::SDL3Sharp.Haptic haptic)
        {
            var __arg0 = haptic is null ? __IntPtr.Zero : haptic.__Instance;
            var ___ret = __Internal.GetMaxHapticEffects(__arg0);
            return ___ret;
        }

        /// <summary>Get the number of effects a haptic device can play at the same time.</summary>
        /// <param name="haptic">the SDL_Haptic device to query maximum playing effects</param>
        /// <remarks>
        /// <para>This is not supported on all platforms, but will always return a value.</para>
        /// <para>the number of effects the haptic device can play at the same time</para>
        /// <para>or a negative error code on failure; call SDL_GetError() for more</para>
        /// <para>information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetMaxHapticEffects</para>
        /// <para>SDL_GetHapticFeatures</para>
        /// </remarks>
        public static int GetMaxHapticEffectsPlaying(global::SDL3Sharp.Haptic haptic)
        {
            var __arg0 = haptic is null ? __IntPtr.Zero : haptic.__Instance;
            var ___ret = __Internal.GetMaxHapticEffectsPlaying(__arg0);
            return ___ret;
        }

        /// <summary>Get the haptic device's supported features in bitwise manner.</summary>
        /// <param name="haptic">the SDL_Haptic device to query</param>
        /// <remarks>
        /// <para>a list of supported haptic features in bitwise manner (OR'd), or 0</para>
        /// <para>on failure; call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_HapticEffectSupported</para>
        /// <para>SDL_GetMaxHapticEffects</para>
        /// </remarks>
        public static uint GetHapticFeatures(global::SDL3Sharp.Haptic haptic)
        {
            var __arg0 = haptic is null ? __IntPtr.Zero : haptic.__Instance;
            var ___ret = __Internal.GetHapticFeatures(__arg0);
            return ___ret;
        }

        /// <summary>Get the number of haptic axes the device has.</summary>
        /// <param name="haptic">the SDL_Haptic device to query</param>
        /// <remarks>
        /// <para>The number of haptic axes might be useful if working with the</para>
        /// <para>SDL_HapticDirection effect.</para>
        /// <para>the number of axes on success or a negative error code on failure;</para>
        /// <para>call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int GetNumHapticAxes(global::SDL3Sharp.Haptic haptic)
        {
            var __arg0 = haptic is null ? __IntPtr.Zero : haptic.__Instance;
            var ___ret = __Internal.GetNumHapticAxes(__arg0);
            return ___ret;
        }

        /// <summary>Check to see if an effect is supported by a haptic device.</summary>
        /// <param name="haptic">the SDL_Haptic device to query</param>
        /// <param name="effect">the desired effect to query</param>
        /// <remarks>
        /// <para>SDL_TRUE if the effect is supported or SDL_FALSE if it isn't.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateHapticEffect</para>
        /// <para>SDL_GetHapticFeatures</para>
        /// </remarks>
        public static bool HapticEffectSupported(global::SDL3Sharp.Haptic haptic, global::SDL3Sharp.HapticEffect effect)
        {
            var __arg0 = haptic is null ? __IntPtr.Zero : haptic.__Instance;
            var ____arg1 = effect.__Instance;
            var __arg1 = new __IntPtr(&____arg1);
            var ___ret = __Internal.HapticEffectSupported(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Create a new haptic effect on a specified device.</summary>
        /// <param name="haptic">an SDL_Haptic device to create the effect on</param>
        /// <param name="effect">
        /// <para>an SDL_HapticEffect structure containing the properties of</para>
        /// <para>the effect to create</para>
        /// </param>
        /// <remarks>
        /// <para>the ID of the effect on success or a negative error code on</para>
        /// <para>failure; call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_DestroyHapticEffect</para>
        /// <para>SDL_RunHapticEffect</para>
        /// <para>SDL_UpdateHapticEffect</para>
        /// </remarks>
        public static int CreateHapticEffect(global::SDL3Sharp.Haptic haptic, global::SDL3Sharp.HapticEffect effect)
        {
            var __arg0 = haptic is null ? __IntPtr.Zero : haptic.__Instance;
            var ____arg1 = effect.__Instance;
            var __arg1 = new __IntPtr(&____arg1);
            var ___ret = __Internal.CreateHapticEffect(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Update the properties of an effect.</summary>
        /// <param name="haptic">the SDL_Haptic device that has the effect</param>
        /// <param name="effect">the identifier of the effect to update</param>
        /// <param name="data">
        /// <para>an SDL_HapticEffect structure containing the new effect</para>
        /// <para>properties to use</para>
        /// </param>
        /// <remarks>
        /// <para>Can be used dynamically, although behavior when dynamically changing</para>
        /// <para>direction may be strange. Specifically the effect may re-upload itself and</para>
        /// <para>start playing from the start. You also cannot change the type either when</para>
        /// <para>running SDL_UpdateHapticEffect().</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_DestroyHapticEffect</para>
        /// <para>SDL_CreateHapticEffect</para>
        /// <para>SDL_RunHapticEffect</para>
        /// </remarks>
        public static int UpdateHapticEffect(global::SDL3Sharp.Haptic haptic, int effect, global::SDL3Sharp.HapticEffect data)
        {
            var __arg0 = haptic is null ? __IntPtr.Zero : haptic.__Instance;
            var ____arg2 = data.__Instance;
            var __arg2 = new __IntPtr(&____arg2);
            var ___ret = __Internal.UpdateHapticEffect(__arg0, effect, __arg2);
            return ___ret;
        }

        /// <summary>Run the haptic effect on its associated haptic device.</summary>
        /// <param name="haptic">the SDL_Haptic device to run the effect on</param>
        /// <param name="effect">the ID of the haptic effect to run</param>
        /// <param name="iterations">
        /// <para>the number of iterations to run the effect; use</para>
        /// <para>`SDL_HAPTIC_INFINITY` to repeat forever</para>
        /// </param>
        /// <remarks>
        /// <para>To repeat the effect over and over indefinitely, set `iterations` to</para>
        /// <para>`SDL_HAPTIC_INFINITY`. (Repeats the envelope - attack and fade.) To make</para>
        /// <para>one instance of the effect last indefinitely (so the effect does not fade),</para>
        /// <para>set the effect's `length` in its structure/union to `SDL_HAPTIC_INFINITY`</para>
        /// <para>instead.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_DestroyHapticEffect</para>
        /// <para>SDL_GetHapticEffectStatus</para>
        /// <para>SDL_StopHapticEffect</para>
        /// </remarks>
        public static int RunHapticEffect(global::SDL3Sharp.Haptic haptic, int effect, uint iterations)
        {
            var __arg0 = haptic is null ? __IntPtr.Zero : haptic.__Instance;
            var ___ret = __Internal.RunHapticEffect(__arg0, effect, iterations);
            return ___ret;
        }

        /// <summary>Stop the haptic effect on its associated haptic device.</summary>
        /// <param name="haptic">the SDL_Haptic device to stop the effect on</param>
        /// <param name="effect">the ID of the haptic effect to stop</param>
        /// <remarks>
        /// <para>*</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_DestroyHapticEffect</para>
        /// <para>SDL_RunHapticEffect</para>
        /// </remarks>
        public static int StopHapticEffect(global::SDL3Sharp.Haptic haptic, int effect)
        {
            var __arg0 = haptic is null ? __IntPtr.Zero : haptic.__Instance;
            var ___ret = __Internal.StopHapticEffect(__arg0, effect);
            return ___ret;
        }

        /// <summary>Destroy a haptic effect on the device.</summary>
        /// <param name="haptic">the SDL_Haptic device to destroy the effect on</param>
        /// <param name="effect">the ID of the haptic effect to destroy</param>
        /// <remarks>
        /// <para>This will stop the effect if it's running. Effects are automatically</para>
        /// <para>destroyed when the device is closed.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateHapticEffect</para>
        /// </remarks>
        public static void DestroyHapticEffect(global::SDL3Sharp.Haptic haptic, int effect)
        {
            var __arg0 = haptic is null ? __IntPtr.Zero : haptic.__Instance;
            __Internal.DestroyHapticEffect(__arg0, effect);
        }

        /// <summary>Get the status of the current effect on the specified haptic device.</summary>
        /// <param name="haptic">the SDL_Haptic device to query for the effect status on</param>
        /// <param name="effect">the ID of the haptic effect to query its status</param>
        /// <remarks>
        /// <para>Device must support the SDL_HAPTIC_STATUS feature.</para>
        /// <para>0 if it isn't playing, 1 if it is playing, or a negative error</para>
        /// <para>code on failure; call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_RunHapticEffect</para>
        /// <para>SDL_StopHapticEffect</para>
        /// </remarks>
        public static int GetHapticEffectStatus(global::SDL3Sharp.Haptic haptic, int effect)
        {
            var __arg0 = haptic is null ? __IntPtr.Zero : haptic.__Instance;
            var ___ret = __Internal.GetHapticEffectStatus(__arg0, effect);
            return ___ret;
        }

        /// <summary>Set the global gain of the specified haptic device.</summary>
        /// <param name="haptic">the SDL_Haptic device to set the gain on</param>
        /// <param name="gain">value to set the gain to, should be between 0 and 100 (0 - 100)</param>
        /// <remarks>
        /// <para>Device must support the SDL_HAPTIC_GAIN feature.</para>
        /// <para>The user may specify the maximum gain by setting the environment variable</para>
        /// <para>`SDL_HAPTIC_GAIN_MAX` which should be between 0 and 100. All calls to</para>
        /// <para>SDL_SetHapticGain() will scale linearly using `SDL_HAPTIC_GAIN_MAX` as the</para>
        /// <para>maximum.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetHapticFeatures</para>
        /// </remarks>
        public static int SetHapticGain(global::SDL3Sharp.Haptic haptic, int gain)
        {
            var __arg0 = haptic is null ? __IntPtr.Zero : haptic.__Instance;
            var ___ret = __Internal.SetHapticGain(__arg0, gain);
            return ___ret;
        }

        /// <summary>Set the global autocenter of the device.</summary>
        /// <param name="haptic">the SDL_Haptic device to set autocentering on</param>
        /// <param name="autocenter">value to set autocenter to (0-100)</param>
        /// <remarks>
        /// <para>Autocenter should be between 0 and 100. Setting it to 0 will disable</para>
        /// <para>autocentering.</para>
        /// <para>Device must support the SDL_HAPTIC_AUTOCENTER feature.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetHapticFeatures</para>
        /// </remarks>
        public static int SetHapticAutocenter(global::SDL3Sharp.Haptic haptic, int autocenter)
        {
            var __arg0 = haptic is null ? __IntPtr.Zero : haptic.__Instance;
            var ___ret = __Internal.SetHapticAutocenter(__arg0, autocenter);
            return ___ret;
        }

        /// <summary>Pause a haptic device.</summary>
        /// <param name="haptic">the SDL_Haptic device to pause</param>
        /// <remarks>
        /// <para>Device must support the `SDL_HAPTIC_PAUSE` feature. Call SDL_ResumeHaptic()</para>
        /// <para>to resume playback.</para>
        /// <para>Do not modify the effects nor add new ones while the device is paused. That</para>
        /// <para>can cause all sorts of weird errors.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_ResumeHaptic</para>
        /// </remarks>
        public static int PauseHaptic(global::SDL3Sharp.Haptic haptic)
        {
            var __arg0 = haptic is null ? __IntPtr.Zero : haptic.__Instance;
            var ___ret = __Internal.PauseHaptic(__arg0);
            return ___ret;
        }

        /// <summary>Resume a haptic device.</summary>
        /// <param name="haptic">the SDL_Haptic device to unpause</param>
        /// <remarks>
        /// <para>Call to unpause after SDL_PauseHaptic().</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_PauseHaptic</para>
        /// </remarks>
        public static int ResumeHaptic(global::SDL3Sharp.Haptic haptic)
        {
            var __arg0 = haptic is null ? __IntPtr.Zero : haptic.__Instance;
            var ___ret = __Internal.ResumeHaptic(__arg0);
            return ___ret;
        }

        /// <summary>Stop all the currently playing effects on a haptic device.</summary>
        /// <param name="haptic">the SDL_Haptic device to stop</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int StopHapticEffects(global::SDL3Sharp.Haptic haptic)
        {
            var __arg0 = haptic is null ? __IntPtr.Zero : haptic.__Instance;
            var ___ret = __Internal.StopHapticEffects(__arg0);
            return ___ret;
        }

        /// <summary>Check whether rumble is supported on a haptic device.</summary>
        /// <param name="haptic">haptic device to check for rumble support</param>
        /// <remarks>
        /// <para>SDL_TRUE if the effect is supported or SDL_FALSE if it isn't.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_InitHapticRumble</para>
        /// <para>SDL_PlayHapticRumble</para>
        /// <para>SDL_StopHapticRumble</para>
        /// </remarks>
        public static bool HapticRumbleSupported(global::SDL3Sharp.Haptic haptic)
        {
            var __arg0 = haptic is null ? __IntPtr.Zero : haptic.__Instance;
            var ___ret = __Internal.HapticRumbleSupported(__arg0);
            return ___ret;
        }

        /// <summary>Initialize a haptic device for simple rumble playback.</summary>
        /// <param name="haptic">the haptic device to initialize for simple rumble playback</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_OpenHaptic</para>
        /// <para>SDL_PlayHapticRumble</para>
        /// <para>SDL_StopHapticRumble</para>
        /// <para>SDL_HapticRumbleSupported</para>
        /// </remarks>
        public static int InitHapticRumble(global::SDL3Sharp.Haptic haptic)
        {
            var __arg0 = haptic is null ? __IntPtr.Zero : haptic.__Instance;
            var ___ret = __Internal.InitHapticRumble(__arg0);
            return ___ret;
        }

        /// <summary>Run a simple rumble effect on a haptic device.</summary>
        /// <param name="haptic">the haptic device to play the rumble effect on</param>
        /// <param name="strength">strength of the rumble to play as a 0-1 float value</param>
        /// <param name="length">length of the rumble to play in milliseconds</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_InitHapticRumble</para>
        /// <para>SDL_StopHapticRumble</para>
        /// <para>SDL_HapticRumbleSupported</para>
        /// </remarks>
        public static int PlayHapticRumble(global::SDL3Sharp.Haptic haptic, float strength, uint length)
        {
            var __arg0 = haptic is null ? __IntPtr.Zero : haptic.__Instance;
            var ___ret = __Internal.PlayHapticRumble(__arg0, strength, length);
            return ___ret;
        }

        /// <summary>Stop the simple rumble on a haptic device.</summary>
        /// <param name="haptic">the haptic device to stop the rumble effect on</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_InitHapticRumble</para>
        /// <para>SDL_PlayHapticRumble</para>
        /// <para>SDL_HapticRumbleSupported</para>
        /// </remarks>
        public static int StopHapticRumble(global::SDL3Sharp.Haptic haptic)
        {
            var __arg0 = haptic is null ? __IntPtr.Zero : haptic.__Instance;
            var ___ret = __Internal.StopHapticRumble(__arg0);
            return ___ret;
        }
    }
}
