// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required
#pragma warning disable CS9084 // Struct member returns 'this' or other instance members by reference

namespace SDL3Sharp
{
    /// <summary>Audio format flags.</summary>
    /// <remarks>
    /// <para>These are what the 16 bits in SDL_AudioFormat currently mean...</para>
    /// <para>(Unspecified bits are always zero).</para>
    /// <para>There are macros in SDL 2.0 and later to query these bits.</para>
    /// </remarks>
    /// <summary>SDL Audio Device instance IDs.</summary>
    /// <summary>A callback that fires when data passes through an SDL_AudioStream.</summary>
    /// <param name="stream">The SDL audio stream associated with this callback.</param>
    /// <param name="additional_amount">The amount of data, in bytes, that is needed right now.</param>
    /// <param name="total_amount">The total amount of data requested, in bytes, that is requested or available.</param>
    /// <param name="userdata">An opaque pointer provided by the app for their personal use.</param>
    /// <remarks>
    /// <para>Apps can (optionally) register a callback with an audio stream that</para>
    /// <para>is called when data is added with SDL_PutAudioStreamData, or requested</para>
    /// <para>with SDL_GetAudioStreamData. These callbacks may run from any</para>
    /// <para>thread, so if you need to protect shared data, you should use</para>
    /// <para>SDL_LockAudioStream to serialize access; this lock will be held by</para>
    /// <para>before your callback is called, so your callback does not need to</para>
    /// <para>manage the lock explicitly.</para>
    /// <para>Two values are offered here: one is the amount of additional data needed</para>
    /// <para>to satisfy the immediate request (which might be zero if the stream</para>
    /// <para>already has enough data queued) and the other is the total amount</para>
    /// <para>being requested. In a Get call triggering a Put callback, these</para>
    /// <para>values can be different. In a Put call triggering a Get callback,</para>
    /// <para>these values are always the same.</para>
    /// <para>Byte counts might be slightly overestimated due to buffering or</para>
    /// <para>resampling, and may change from call to call.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void AudioStreamCallback(__IntPtr userdata, __IntPtr stream, int additional_amount, int total_amount);

    /// <summary>A callback that fires when data is about to be fed to an audio device.</summary>
    /// <remarks>
    /// <para>This is useful for accessing the final mix, perhaps for writing a</para>
    /// <para>visualizer or applying a final effect to the audio data before playback.</para>
    /// <para>SDL_SetAudioDevicePostmixCallback</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void AudioPostmixCallback(__IntPtr userdata, __IntPtr spec, float* buffer, int buflen);

    public unsafe partial class AudioStream
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.AudioStream> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.AudioStream>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.AudioStream managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.AudioStream managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static AudioStream __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new AudioStream(native.ToPointer(), skipVTables);
        }

        internal static AudioStream __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (AudioStream)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static AudioStream __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new AudioStream(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private AudioStream(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected AudioStream(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class AudioSpec : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12, Pack = 8)]
        public partial struct __Internal
        {
            internal ushort format;
            internal int channels;
            internal int freq;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_AudioSpec@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.AudioSpec> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.AudioSpec>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.AudioSpec managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.AudioSpec managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static AudioSpec __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new AudioSpec(native.ToPointer(), skipVTables);
        }

        internal static AudioSpec __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (AudioSpec)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static AudioSpec __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new AudioSpec(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private AudioSpec(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected AudioSpec(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public AudioSpec()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.AudioSpec.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public AudioSpec(global::SDL3Sharp.AudioSpec _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.AudioSpec.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.AudioSpec.__Internal*) __Instance) = *((global::SDL3Sharp.AudioSpec.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Audio data format</summary>
        public ushort Format
        {
            get
            {
                return ((__Internal*)__Instance)->format;
            }

            set
            {
                ((__Internal*)__Instance)->format = value;
            }
        }

        /// <summary>Number of channels: 1 mono, 2 stereo, etc</summary>
        public int Channels
        {
            get
            {
                return ((__Internal*)__Instance)->channels;
            }

            set
            {
                ((__Internal*)__Instance)->channels = value;
            }
        }

        /// <summary>sample rate: sample frames per second</summary>
        public int Freq
        {
            get
            {
                return ((__Internal*)__Instance)->freq;
            }

            set
            {
                ((__Internal*)__Instance)->freq = value;
            }
        }
    }

    public unsafe partial class SDL
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetNumAudioDrivers", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetNumAudioDrivers();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetAudioDriver", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetAudioDriver(int index);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetCurrentAudioDriver", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetCurrentAudioDriver();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetAudioOutputDevices", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint* GetAudioOutputDevices(int* count);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetAudioCaptureDevices", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint* GetAudioCaptureDevices(int* count);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetAudioDeviceName", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern sbyte* GetAudioDeviceName(uint devid);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetAudioDeviceFormat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetAudioDeviceFormat(uint devid, __IntPtr spec, int* sample_frames);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_OpenAudioDevice", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint OpenAudioDevice(uint devid, __IntPtr spec);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_PauseAudioDevice", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int PauseAudioDevice(uint dev);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_ResumeAudioDevice", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int ResumeAudioDevice(uint dev);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_AudioDevicePaused", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool AudioDevicePaused(uint dev);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_CloseAudioDevice", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void CloseAudioDevice(uint devid);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_BindAudioStreams", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BindAudioStreams(uint devid, __IntPtr streams, int num_streams);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_BindAudioStream", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BindAudioStream(uint devid, __IntPtr stream);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_UnbindAudioStreams", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UnbindAudioStreams(__IntPtr streams, int num_streams);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_UnbindAudioStream", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UnbindAudioStream(__IntPtr stream);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetAudioStreamDevice", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint GetAudioStreamDevice(__IntPtr stream);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_CreateAudioStream", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CreateAudioStream(__IntPtr src_spec, __IntPtr dst_spec);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetAudioStreamProperties", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint GetAudioStreamProperties(__IntPtr stream);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetAudioStreamFormat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetAudioStreamFormat(__IntPtr stream, __IntPtr src_spec, __IntPtr dst_spec);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetAudioStreamFormat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetAudioStreamFormat(__IntPtr stream, __IntPtr src_spec, __IntPtr dst_spec);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetAudioStreamFrequencyRatio", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float GetAudioStreamFrequencyRatio(__IntPtr stream);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetAudioStreamFrequencyRatio", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetAudioStreamFrequencyRatio(__IntPtr stream, float ratio);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_PutAudioStreamData", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int PutAudioStreamData(__IntPtr stream, __IntPtr buf, int len);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetAudioStreamData", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetAudioStreamData(__IntPtr stream, __IntPtr buf, int len);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetAudioStreamAvailable", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetAudioStreamAvailable(__IntPtr stream);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetAudioStreamQueued", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetAudioStreamQueued(__IntPtr stream);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_FlushAudioStream", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FlushAudioStream(__IntPtr stream);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_ClearAudioStream", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int ClearAudioStream(__IntPtr stream);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_LockAudioStream", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LockAudioStream(__IntPtr stream);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_UnlockAudioStream", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int UnlockAudioStream(__IntPtr stream);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetAudioStreamGetCallback", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetAudioStreamGetCallback(__IntPtr stream, __IntPtr callback, __IntPtr userdata);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetAudioStreamPutCallback", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetAudioStreamPutCallback(__IntPtr stream, __IntPtr callback, __IntPtr userdata);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_DestroyAudioStream", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void DestroyAudioStream(__IntPtr stream);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_OpenAudioDeviceStream", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr OpenAudioDeviceStream(uint devid, __IntPtr spec, __IntPtr callback, __IntPtr userdata);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetAudioPostmixCallback", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetAudioPostmixCallback(uint devid, __IntPtr callback, __IntPtr userdata);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_LoadWAV_RW", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LoadWAV_RW(__IntPtr src, bool freesrc, __IntPtr spec, byte** audio_buf, uint* audio_len);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_LoadWAV", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LoadWAV([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string path, __IntPtr spec, byte** audio_buf, uint* audio_len);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_MixAudioFormat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int MixAudioFormat(byte* dst, byte* src, ushort format, uint len, int volume);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_ConvertAudioSamples", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int ConvertAudioSamples(__IntPtr src_spec, byte* src_data, int src_len, __IntPtr dst_spec, byte** dst_data, int* dst_len);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetSilenceValueForFormat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetSilenceValueForFormat(ushort format);
        }

        /// <summary>Use this function to get the number of built-in audio drivers.</summary>
        /// <remarks>
        /// <para>This function returns a hardcoded number. This never returns a negative</para>
        /// <para>value; if there are no drivers compiled into this build of SDL, this</para>
        /// <para>function returns zero. The presence of a driver in this list does not mean</para>
        /// <para>it will function, it just means SDL is capable of interacting with that</para>
        /// <para>interface. For example, a build of SDL might have esound support, but if</para>
        /// <para>there's no esound server available, SDL's esound driver would fail if used.</para>
        /// <para>By default, SDL tries all drivers, in its preferred order, until one is</para>
        /// <para>found to be usable.</para>
        /// <para>the number of built-in audio drivers.</para>
        /// <para>It is safe to call this function from any thread.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetAudioDriver</para>
        /// </remarks>
        public static int GetNumAudioDrivers()
        {
            var ___ret = __Internal.GetNumAudioDrivers();
            return ___ret;
        }

        /// <summary>Use this function to get the name of a built in audio driver.</summary>
        /// <param name="index">
        /// <para>the index of the audio driver; the value ranges from 0 to</para>
        /// <para>SDL_GetNumAudioDrivers() - 1</para>
        /// </param>
        /// <remarks>
        /// <para>The list of audio drivers is given in the order that they are normally</para>
        /// <para>initialized by default; the drivers that seem more reasonable to choose</para>
        /// <para>first (as far as the SDL developers believe) are earlier in the list.</para>
        /// <para>The names of drivers are all simple, low-ASCII identifiers, like &quot;alsa&quot;,</para>
        /// <para>&quot;coreaudio&quot; or &quot;xaudio2&quot;. These never have Unicode characters, and are not</para>
        /// <para>meant to be proper names.</para>
        /// <para>the name of the audio driver at the requested index, or NULL if an</para>
        /// <para>invalid index was specified.</para>
        /// <para>It is safe to call this function from any thread.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetNumAudioDrivers</para>
        /// </remarks>
        public static string GetAudioDriver(int index)
        {
            var ___ret = __Internal.GetAudioDriver(index);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Get the name of the current audio driver.</summary>
        /// <remarks>
        /// <para>The returned string points to internal static memory and thus never becomes</para>
        /// <para>invalid, even if you quit the audio subsystem and initialize a new driver</para>
        /// <para>(although such a case would return a different static string from another</para>
        /// <para>call to this function, of course). As such, you should not modify or free</para>
        /// <para>the returned string.</para>
        /// <para>the name of the current audio driver or NULL if no driver has been</para>
        /// <para>initialized.</para>
        /// <para>It is safe to call this function from any thread.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static string GetCurrentAudioDriver()
        {
            var ___ret = __Internal.GetCurrentAudioDriver();
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Get a list of currently-connected audio output devices.</summary>
        /// <param name="count">a pointer filled in with the number of devices returned</param>
        /// <remarks>
        /// <para>This returns of list of available devices that play sound, perhaps to</para>
        /// <para>speakers or headphones (&quot;output&quot; devices). If you want devices that record</para>
        /// <para>audio, like a microphone (&quot;capture&quot; devices), use</para>
        /// <para>SDL_GetAudioCaptureDevices() instead.</para>
        /// <para>This only returns a list of physical devices; it will not have any device</para>
        /// <para>IDs returned by SDL_OpenAudioDevice().</para>
        /// <para>a 0 terminated array of device instance IDs which should be freed</para>
        /// <para>with SDL_free(), or NULL on error; call SDL_GetError() for more</para>
        /// <para>details.</para>
        /// <para>It is safe to call this function from any thread.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_OpenAudioDevice</para>
        /// <para>SDL_GetAudioCaptureDevices</para>
        /// </remarks>
        public static uint* GetAudioOutputDevices(ref int count)
        {
            fixed (int* __count0 = &count)
            {
                var __arg0 = __count0;
                var ___ret = __Internal.GetAudioOutputDevices(__arg0);
                return ___ret;
            }
        }

        /// <summary>Get a list of currently-connected audio capture devices.</summary>
        /// <param name="count">a pointer filled in with the number of devices returned</param>
        /// <remarks>
        /// <para>This returns of list of available devices that record audio, like a</para>
        /// <para>microphone (&quot;capture&quot; devices). If you want devices that play sound,</para>
        /// <para>perhaps to speakers or headphones (&quot;output&quot; devices), use</para>
        /// <para>SDL_GetAudioOutputDevices() instead.</para>
        /// <para>This only returns a list of physical devices; it will not have any device</para>
        /// <para>IDs returned by SDL_OpenAudioDevice().</para>
        /// <para>a 0 terminated array of device instance IDs which should be freed</para>
        /// <para>with SDL_free(), or NULL on error; call SDL_GetError() for more</para>
        /// <para>details.</para>
        /// <para>It is safe to call this function from any thread.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_OpenAudioDevice</para>
        /// <para>SDL_GetAudioOutputDevices</para>
        /// </remarks>
        public static uint* GetAudioCaptureDevices(ref int count)
        {
            fixed (int* __count0 = &count)
            {
                var __arg0 = __count0;
                var ___ret = __Internal.GetAudioCaptureDevices(__arg0);
                return ___ret;
            }
        }

        /// <summary>Get the human-readable name of a specific audio device.</summary>
        /// <param name="devid">the instance ID of the device to query.</param>
        /// <remarks>
        /// <para>The string returned by this function is UTF-8 encoded. The caller should</para>
        /// <para>call SDL_free on the return value when done with it.</para>
        /// <para>the name of the audio device, or NULL on error.</para>
        /// <para>It is safe to call this function from any thread.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetAudioOutputDevices</para>
        /// <para>SDL_GetAudioCaptureDevices</para>
        /// <para>SDL_GetDefaultAudioInfo</para>
        /// </remarks>
        public static sbyte* GetAudioDeviceName(uint devid)
        {
            var ___ret = __Internal.GetAudioDeviceName(devid);
            return ___ret;
        }

        /// <summary>Get the current audio format of a specific audio device.</summary>
        /// <param name="devid">the instance ID of the device to query.</param>
        /// <param name="spec">On return, will be filled with device details.</param>
        /// <param name="sample_frames">
        /// <para>Pointer to store device buffer size, in sample frames.</para>
        /// <para>Can be NULL.</para>
        /// </param>
        /// <remarks>
        /// <para>For an opened device, this will report the format the device is currently</para>
        /// <para>using. If the device isn't yet opened, this will report the device's</para>
        /// <para>preferred format (or a reasonable default if this can't be determined).</para>
        /// <para>You may also specify SDL_AUDIO_DEVICE_DEFAULT_OUTPUT or</para>
        /// <para>SDL_AUDIO_DEVICE_DEFAULT_CAPTURE here, which is useful for getting a</para>
        /// <para>reasonable recommendation before opening the system-recommended default</para>
        /// <para>device.</para>
        /// <para>You can also use this to request the current device buffer size. This is</para>
        /// <para>specified in sample frames and represents the amount of data SDL will feed</para>
        /// <para>to the physical hardware in each chunk. This can be converted to</para>
        /// <para>milliseconds of audio with the following equation:</para>
        /// <para>`ms = (int) ((((Sint64) frames) * 1000) / spec.freq);`</para>
        /// <para>Buffer size is only important if you need low-level control over the audio</para>
        /// <para>playback timing. Most apps do not need this.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>It is safe to call this function from any thread.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int GetAudioDeviceFormat(uint devid, global::SDL3Sharp.AudioSpec spec, ref int sample_frames)
        {
            var __arg1 = spec is null ? __IntPtr.Zero : spec.__Instance;
            fixed (int* __sample_frames2 = &sample_frames)
            {
                var __arg2 = __sample_frames2;
                var ___ret = __Internal.GetAudioDeviceFormat(devid, __arg1, __arg2);
                return ___ret;
            }
        }

        /// <summary>Open a specific audio device.</summary>
        /// <param name="devid">
        /// <para>the device instance id to open, or</para>
        /// <para>SDL_AUDIO_DEVICE_DEFAULT_OUTPUT or</para>
        /// <para>SDL_AUDIO_DEVICE_DEFAULT_CAPTURE for the most reasonable</para>
        /// <para>default device.</para>
        /// </param>
        /// <param name="spec">
        /// <para>the requested device configuration. Can be NULL to use</para>
        /// <para>reasonable defaults.</para>
        /// </param>
        /// <remarks>
        /// <para>You can open both output and capture devices through this function. Output</para>
        /// <para>devices will take data from bound audio streams, mix it, and send it to the</para>
        /// <para>hardware. Capture devices will feed any bound audio streams with a copy of</para>
        /// <para>any incoming data.</para>
        /// <para>An opened audio device starts out with no audio streams bound. To start</para>
        /// <para>audio playing, bind a stream and supply audio data to it. Unlike SDL2,</para>
        /// <para>there is no audio callback; you only bind audio streams and make sure they</para>
        /// <para>have data flowing into them (however, you can simulate SDL2's semantics</para>
        /// <para>fairly closely by using SDL_OpenAudioDeviceStream instead of this</para>
        /// <para>function).</para>
        /// <para>If you don't care about opening a specific device, pass a `devid` of either</para>
        /// <para>`SDL_AUDIO_DEVICE_DEFAULT_OUTPUT` or `SDL_AUDIO_DEVICE_DEFAULT_CAPTURE`. In</para>
        /// <para>this case, SDL will try to pick the most reasonable default, and may also</para>
        /// <para>switch between physical devices seamlessly later, if the most reasonable</para>
        /// <para>default changes during the lifetime of this opened device (user changed the</para>
        /// <para>default in the OS's system preferences, the default got unplugged so the</para>
        /// <para>system jumped to a new default, the user plugged in headphones on a mobile</para>
        /// <para>device, etc). Unless you have a good reason to choose a specific device,</para>
        /// <para>this is probably what you want.</para>
        /// <para>You may request a specific format for the audio device, but there is no</para>
        /// <para>promise the device will honor that request for several reasons. As such,</para>
        /// <para>it's only meant to be a hint as to what data your app will provide. Audio</para>
        /// <para>streams will accept data in whatever format you specify and manage</para>
        /// <para>conversion for you as appropriate. SDL_GetAudioDeviceFormat can tell you</para>
        /// <para>the preferred format for the device before opening and the actual format</para>
        /// <para>the device is using after opening.</para>
        /// <para>It's legal to open the same device ID more than once; each successful open</para>
        /// <para>will generate a new logical SDL_AudioDeviceID that is managed separately</para>
        /// <para>from others on the same physical device. This allows libraries to open a</para>
        /// <para>device separately from the main app and bind its own streams without</para>
        /// <para>conflicting.</para>
        /// <para>It is also legal to open a device ID returned by a previous call to this</para>
        /// <para>function; doing so just creates another logical device on the same physical</para>
        /// <para>device. This may be useful for making logical groupings of audio streams.</para>
        /// <para>This function returns the opened device ID on success. This is a new,</para>
        /// <para>unique SDL_AudioDeviceID that represents a logical device.</para>
        /// <para>Some backends might offer arbitrary devices (for example, a networked audio</para>
        /// <para>protocol that can connect to an arbitrary server). For these, as a change</para>
        /// <para>from SDL2, you should open a default device ID and use an SDL hint to</para>
        /// <para>specify the target if you care, or otherwise let the backend figure out a</para>
        /// <para>reasonable default. Most backends don't offer anything like this, and often</para>
        /// <para>this would be an end user setting an environment variable for their custom</para>
        /// <para>need, and not something an application should specifically manage.</para>
        /// <para>When done with an audio device, possibly at the end of the app's life, one</para>
        /// <para>should call SDL_CloseAudioDevice() on the returned device id.</para>
        /// <para>The device ID on success, 0 on error; call SDL_GetError() for more</para>
        /// <para>information.</para>
        /// <para>It is safe to call this function from any thread.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CloseAudioDevice</para>
        /// <para>SDL_GetAudioDeviceFormat</para>
        /// </remarks>
        public static uint OpenAudioDevice(uint devid, global::SDL3Sharp.AudioSpec spec)
        {
            var __arg1 = spec is null ? __IntPtr.Zero : spec.__Instance;
            var ___ret = __Internal.OpenAudioDevice(devid, __arg1);
            return ___ret;
        }

        /// <summary>Use this function to pause audio playback on a specified device.</summary>
        /// <param name="dev">a device opened by SDL_OpenAudioDevice()</param>
        /// <remarks>
        /// <para>This function pauses audio processing for a given device. Any bound audio</para>
        /// <para>streams will not progress, and no audio will be generated. Pausing one</para>
        /// <para>device does not prevent other unpaused devices from running.</para>
        /// <para>Unlike in SDL2, audio devices start in an _unpaused_ state, since an app</para>
        /// <para>has to bind a stream before any audio will flow. Pausing a paused device is</para>
        /// <para>a legal no-op.</para>
        /// <para>Pausing a device can be useful to halt all audio without unbinding all the</para>
        /// <para>audio streams. This might be useful while a game is paused, or a level is</para>
        /// <para>loading, etc.</para>
        /// <para>Physical devices can not be paused or unpaused, only logical devices</para>
        /// <para>created through SDL_OpenAudioDevice() can be.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>It is safe to call this function from any thread.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_ResumeAudioDevice</para>
        /// <para>SDL_AudioDevicePaused</para>
        /// </remarks>
        public static int PauseAudioDevice(uint dev)
        {
            var ___ret = __Internal.PauseAudioDevice(dev);
            return ___ret;
        }

        /// <summary>Use this function to unpause audio playback on a specified device.</summary>
        /// <param name="dev">a device opened by SDL_OpenAudioDevice()</param>
        /// <remarks>
        /// <para>This function unpauses audio processing for a given device that has</para>
        /// <para>previously been paused with SDL_PauseAudioDevice(). Once unpaused, any</para>
        /// <para>bound audio streams will begin to progress again, and audio can be</para>
        /// <para>generated.</para>
        /// <para>Unlike in SDL2, audio devices start in an _unpaused_ state, since an app</para>
        /// <para>has to bind a stream before any audio will flow. Unpausing an unpaused</para>
        /// <para>device is a legal no-op.</para>
        /// <para>Physical devices can not be paused or unpaused, only logical devices</para>
        /// <para>created through SDL_OpenAudioDevice() can be.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>It is safe to call this function from any thread.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_AudioDevicePaused</para>
        /// <para>SDL_PauseAudioDevice</para>
        /// </remarks>
        public static int ResumeAudioDevice(uint dev)
        {
            var ___ret = __Internal.ResumeAudioDevice(dev);
            return ___ret;
        }

        /// <summary>Use this function to query if an audio device is paused.</summary>
        /// <param name="dev">a device opened by SDL_OpenAudioDevice()</param>
        /// <remarks>
        /// <para>Unlike in SDL2, audio devices start in an _unpaused_ state, since an app</para>
        /// <para>has to bind a stream before any audio will flow.</para>
        /// <para>Physical devices can not be paused or unpaused, only logical devices</para>
        /// <para>created through SDL_OpenAudioDevice() can be. Physical and invalid device</para>
        /// <para>IDs will report themselves as unpaused here.</para>
        /// <para>SDL_TRUE if device is valid and paused, SDL_FALSE otherwise.</para>
        /// <para>It is safe to call this function from any thread.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_PauseAudioDevice</para>
        /// <para>SDL_ResumeAudioDevice</para>
        /// </remarks>
        public static bool AudioDevicePaused(uint dev)
        {
            var ___ret = __Internal.AudioDevicePaused(dev);
            return ___ret;
        }

        /// <summary>Close a previously-opened audio device.</summary>
        /// <param name="devid">
        /// <para>an audio device id previously returned by</para>
        /// <para>SDL_OpenAudioDevice()</para>
        /// </param>
        /// <remarks>
        /// <para>The application should close open audio devices once they are no longer</para>
        /// <para>needed.</para>
        /// <para>This function may block briefly while pending audio data is played by the</para>
        /// <para>hardware, so that applications don't drop the last buffer of data they</para>
        /// <para>supplied if terminating immediately afterwards.</para>
        /// <para>It is safe to call this function from any thread.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_OpenAudioDevice</para>
        /// </remarks>
        public static void CloseAudioDevice(uint devid)
        {
            __Internal.CloseAudioDevice(devid);
        }

        /// <summary>Bind a list of audio streams to an audio device.</summary>
        /// <param name="devid">an audio device to bind a stream to.</param>
        /// <param name="streams">an array of audio streams to unbind.</param>
        /// <param name="num_streams">Number streams listed in the `streams` array.</param>
        /// <remarks>
        /// <para>Audio data will flow through any bound streams. For an output device, data</para>
        /// <para>for all bound streams will be mixed together and fed to the device. For a</para>
        /// <para>capture device, a copy of recorded data will be provided to each bound</para>
        /// <para>stream.</para>
        /// <para>Audio streams can only be bound to an open device. This operation is</para>
        /// <para>atomic--all streams bound in the same call will start processing at the</para>
        /// <para>same time, so they can stay in sync. Also: either all streams will be bound</para>
        /// <para>or none of them will be.</para>
        /// <para>It is an error to bind an already-bound stream; it must be explicitly</para>
        /// <para>unbound first.</para>
        /// <para>Binding a stream to a device will set its output format for output devices,</para>
        /// <para>and its input format for capture devices, so they match the device's</para>
        /// <para>settings. The caller is welcome to change the other end of the stream's</para>
        /// <para>format at any time.</para>
        /// <para>0 on success, -1 on error; call SDL_GetError() for more</para>
        /// <para>information.</para>
        /// <para>It is safe to call this function from any thread.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_BindAudioStreams</para>
        /// <para>SDL_UnbindAudioStreams</para>
        /// <para>SDL_UnbindAudioStream</para>
        /// <para>SDL_GetAudioStreamDevice</para>
        /// </remarks>
        public static int BindAudioStreams(uint devid, global::SDL3Sharp.AudioStream streams, int num_streams)
        {
            var ____arg1 = streams is null ? __IntPtr.Zero : streams.__Instance;
            var __arg1 = new __IntPtr(&____arg1);
            var ___ret = __Internal.BindAudioStreams(devid, __arg1, num_streams);
            return ___ret;
        }

        /// <summary>Bind a single audio stream to an audio device.</summary>
        /// <param name="devid">an audio device to bind a stream to.</param>
        /// <param name="stream">an audio stream to bind to a device.</param>
        /// <remarks>
        /// <para>This is a convenience function, equivalent to calling</para>
        /// <para>`SDL_BindAudioStreams(devid,&amp;stream, 1)`.</para>
        /// <para>0 on success, -1 on error; call SDL_GetError() for more</para>
        /// <para>information.</para>
        /// <para>It is safe to call this function from any thread.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_BindAudioStreams</para>
        /// <para>SDL_UnbindAudioStreams</para>
        /// <para>SDL_UnbindAudioStream</para>
        /// <para>SDL_GetAudioStreamDevice</para>
        /// </remarks>
        public static int BindAudioStream(uint devid, global::SDL3Sharp.AudioStream stream)
        {
            var __arg1 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var ___ret = __Internal.BindAudioStream(devid, __arg1);
            return ___ret;
        }

        /// <summary>Unbind a list of audio streams from their audio devices.</summary>
        /// <param name="streams">an array of audio streams to unbind.</param>
        /// <param name="num_streams">Number streams listed in the `streams` array.</param>
        /// <remarks>
        /// <para>The streams being unbound do not all have to be on the same device. All</para>
        /// <para>streams on the same device will be unbound atomically (data will stop</para>
        /// <para>flowing through them all unbound streams on the same device at the same</para>
        /// <para>time).</para>
        /// <para>Unbinding a stream that isn't bound to a device is a legal no-op.</para>
        /// <para>It is safe to call this function from any thread.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_BindAudioStreams</para>
        /// <para>SDL_BindAudioStream</para>
        /// <para>SDL_UnbindAudioStream</para>
        /// <para>SDL_GetAudioStreamDevice</para>
        /// </remarks>
        public static void UnbindAudioStreams(global::SDL3Sharp.AudioStream streams, int num_streams)
        {
            var ____arg0 = streams is null ? __IntPtr.Zero : streams.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            __Internal.UnbindAudioStreams(__arg0, num_streams);
        }

        /// <summary>Unbind a single audio stream from its audio device.</summary>
        /// <param name="stream">an audio stream to unbind from a device.</param>
        /// <remarks>
        /// <para>This is a convenience function, equivalent to calling</para>
        /// <para>`SDL_UnbindAudioStreams(&amp;stream, 1)`.</para>
        /// <para>It is safe to call this function from any thread.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_BindAudioStream</para>
        /// <para>SDL_BindAudioStreams</para>
        /// <para>SDL_UnbindAudioStreams</para>
        /// <para>SDL_GetAudioStreamDevice</para>
        /// </remarks>
        public static void UnbindAudioStream(global::SDL3Sharp.AudioStream stream)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            __Internal.UnbindAudioStream(__arg0);
        }

        /// <summary>Query an audio stream for its currently-bound device.</summary>
        /// <param name="stream">the audio stream to query.</param>
        /// <remarks>
        /// <para>This reports the audio device that an audio stream is currently bound to.</para>
        /// <para>If not bound, or invalid, this returns zero, which is not a valid device</para>
        /// <para>ID.</para>
        /// <para>The bound audio device, or 0 if not bound or invalid.</para>
        /// <para>It is safe to call this function from any thread.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_BindAudioStream</para>
        /// <para>SDL_BindAudioStreams</para>
        /// <para>SDL_UnbindAudioStream</para>
        /// <para>SDL_UnbindAudioStreams</para>
        /// </remarks>
        public static uint GetAudioStreamDevice(global::SDL3Sharp.AudioStream stream)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var ___ret = __Internal.GetAudioStreamDevice(__arg0);
            return ___ret;
        }

        /// <summary>Create a new audio stream.</summary>
        /// <param name="src_spec">The format details of the input audio</param>
        /// <param name="dst_spec">The format details of the output audio</param>
        /// <remarks>
        /// <para>a new audio stream on success, or NULL on failure.</para>
        /// <para>It is safe to call this function from any thread.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_PutAudioStreamData</para>
        /// <para>SDL_GetAudioStreamData</para>
        /// <para>SDL_GetAudioStreamAvailable</para>
        /// <para>SDL_FlushAudioStream</para>
        /// <para>SDL_ClearAudioStream</para>
        /// <para>SDL_ChangeAudioStreamOutput</para>
        /// <para>SDL_DestroyAudioStream</para>
        /// </remarks>
        public static global::SDL3Sharp.AudioStream CreateAudioStream(global::SDL3Sharp.AudioSpec src_spec, global::SDL3Sharp.AudioSpec dst_spec)
        {
            var __arg0 = src_spec is null ? __IntPtr.Zero : src_spec.__Instance;
            var __arg1 = dst_spec is null ? __IntPtr.Zero : dst_spec.__Instance;
            var ___ret = __Internal.CreateAudioStream(__arg0, __arg1);
            var __result0 = global::SDL3Sharp.AudioStream.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the properties associated with an audio stream.</summary>
        /// <param name="stream">the SDL_AudioStream to query</param>
        /// <remarks>
        /// <para>a valid property ID on success or 0 on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetProperty</para>
        /// <para>SDL_SetProperty</para>
        /// </remarks>
        public static uint GetAudioStreamProperties(global::SDL3Sharp.AudioStream stream)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var ___ret = __Internal.GetAudioStreamProperties(__arg0);
            return ___ret;
        }

        /// <summary>Query the current format of an audio stream.</summary>
        /// <param name="stream">the SDL_AudioStream to query.</param>
        /// <param name="src_spec">Where to store the input audio format; ignored if NULL.</param>
        /// <param name="dst_spec">Where to store the output audio format; ignored if NULL.</param>
        /// <remarks>
        /// <para>0 on success, or -1 on error.</para>
        /// <para>It is safe to call this function from any thread, as it holds</para>
        /// <para>a stream-specific mutex while running.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int GetAudioStreamFormat(global::SDL3Sharp.AudioStream stream, global::SDL3Sharp.AudioSpec src_spec, global::SDL3Sharp.AudioSpec dst_spec)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var __arg1 = src_spec is null ? __IntPtr.Zero : src_spec.__Instance;
            var __arg2 = dst_spec is null ? __IntPtr.Zero : dst_spec.__Instance;
            var ___ret = __Internal.GetAudioStreamFormat(__arg0, __arg1, __arg2);
            return ___ret;
        }

        /// <summary>Change the input and output formats of an audio stream.</summary>
        /// <param name="stream">The stream the format is being changed</param>
        /// <param name="src_spec">
        /// <para>The new format of the audio input; if NULL, it is not</para>
        /// <para>changed.</para>
        /// </param>
        /// <param name="dst_spec">
        /// <para>The new format of the audio output; if NULL, it is not</para>
        /// <para>changed.</para>
        /// </param>
        /// <remarks>
        /// <para>Future calls to and SDL_GetAudioStreamAvailable and SDL_GetAudioStreamData</para>
        /// <para>will reflect the new format, and future calls to SDL_PutAudioStreamData</para>
        /// <para>must provide data in the new input formats.</para>
        /// <para>0 on success, or -1 on error.</para>
        /// <para>It is safe to call this function from any thread, as it holds</para>
        /// <para>a stream-specific mutex while running.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetAudioStreamFormat</para>
        /// <para>SDL_PutAudioStreamData</para>
        /// <para>SDL_GetAudioStreamData</para>
        /// <para>SDL_GetAudioStreamAvailable</para>
        /// <para>SDL_SetAudioStreamFrequencyRatio</para>
        /// </remarks>
        public static int SetAudioStreamFormat(global::SDL3Sharp.AudioStream stream, global::SDL3Sharp.AudioSpec src_spec, global::SDL3Sharp.AudioSpec dst_spec)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var __arg1 = src_spec is null ? __IntPtr.Zero : src_spec.__Instance;
            var __arg2 = dst_spec is null ? __IntPtr.Zero : dst_spec.__Instance;
            var ___ret = __Internal.SetAudioStreamFormat(__arg0, __arg1, __arg2);
            return ___ret;
        }

        /// <summary>Get the frequency ratio of an audio stream.</summary>
        /// <param name="stream">the SDL_AudioStream to query.</param>
        /// <remarks>
        /// <para>the frequency ratio of the stream, or 0.0 on error</para>
        /// <para>It is safe to call this function from any thread, as it holds</para>
        /// <para>a stream-specific mutex while running.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_SetAudioStreamFrequencyRatio</para>
        /// </remarks>
        public static float GetAudioStreamFrequencyRatio(global::SDL3Sharp.AudioStream stream)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var ___ret = __Internal.GetAudioStreamFrequencyRatio(__arg0);
            return ___ret;
        }

        /// <summary>Change the frequency ratio of an audio stream.</summary>
        /// <param name="stream">The stream the frequency ratio is being changed</param>
        /// <param name="ratio">
        /// <para>The frequency ratio. 1.0 is normal speed. Must be between 0.01</para>
        /// <para>and 100.</para>
        /// </param>
        /// <remarks>
        /// <para>The frequency ratio is used to adjust the rate at which input data is</para>
        /// <para>consumed. Changing this effectively modifies the speed and pitch of the</para>
        /// <para>audio. A value greater than 1.0 will play the audio faster, and at a higher</para>
        /// <para>pitch. A value less than 1.0 will play the audio slower, and at a lower</para>
        /// <para>pitch.</para>
        /// <para>This is applied during SDL_GetAudioStreamData, and can be continuously</para>
        /// <para>changed to create various effects.</para>
        /// <para>0 on success, or -1 on error.</para>
        /// <para>It is safe to call this function from any thread, as it holds</para>
        /// <para>a stream-specific mutex while running.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetAudioStreamFrequencyRatio</para>
        /// <para>SDL_SetAudioStreamFormat</para>
        /// </remarks>
        public static int SetAudioStreamFrequencyRatio(global::SDL3Sharp.AudioStream stream, float ratio)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var ___ret = __Internal.SetAudioStreamFrequencyRatio(__arg0, ratio);
            return ___ret;
        }

        /// <summary>Add data to be converted/resampled to the stream.</summary>
        /// <param name="stream">The stream the audio data is being added to</param>
        /// <param name="buf">A pointer to the audio data to add</param>
        /// <param name="len">The number of bytes to write to the stream</param>
        /// <remarks>
        /// <para>This data must match the format/channels/samplerate specified in the latest</para>
        /// <para>call to SDL_SetAudioStreamFormat, or the format specified when creating the</para>
        /// <para>stream if it hasn't been changed.</para>
        /// <para>Note that this call simply queues unconverted data for later. This is</para>
        /// <para>different than SDL2, where data was converted during the Put call and the</para>
        /// <para>Get call would just dequeue the previously-converted data.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>It is safe to call this function from any thread, but if the</para>
        /// <para>stream has a callback set, the caller might need to manage</para>
        /// <para>extra locking.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateAudioStream</para>
        /// <para>SDL_GetAudioStreamData</para>
        /// <para>SDL_GetAudioStreamAvailable</para>
        /// <para>SDL_FlushAudioStream</para>
        /// <para>SDL_ClearAudioStream</para>
        /// <para>SDL_DestroyAudioStream</para>
        /// </remarks>
        public static int PutAudioStreamData(global::SDL3Sharp.AudioStream stream, __IntPtr buf, int len)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var ___ret = __Internal.PutAudioStreamData(__arg0, buf, len);
            return ___ret;
        }

        /// <summary>Get converted/resampled data from the stream.</summary>
        /// <param name="stream">The stream the audio is being requested from</param>
        /// <param name="buf">A buffer to fill with audio data</param>
        /// <param name="len">The maximum number of bytes to fill</param>
        /// <remarks>
        /// <para>The input/output data format/channels/samplerate is specified when creating</para>
        /// <para>the stream, and can be changed after creation by calling</para>
        /// <para>SDL_SetAudioStreamFormat.</para>
        /// <para>Note that any conversion and resampling necessary is done during this call,</para>
        /// <para>and SDL_PutAudioStreamData simply queues unconverted data for later. This</para>
        /// <para>is different than SDL2, where that work was done while inputting new data</para>
        /// <para>to the stream and requesting the output just copied the converted data.</para>
        /// <para>the number of bytes read from the stream, or -1 on error</para>
        /// <para>It is safe to call this function from any thread, but if the</para>
        /// <para>stream has a callback set, the caller might need to manage</para>
        /// <para>extra locking.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateAudioStream</para>
        /// <para>SDL_PutAudioStreamData</para>
        /// <para>SDL_GetAudioStreamAvailable</para>
        /// <para>SDL_SetAudioStreamFormat</para>
        /// <para>SDL_FlushAudioStream</para>
        /// <para>SDL_ClearAudioStream</para>
        /// <para>SDL_DestroyAudioStream</para>
        /// </remarks>
        public static int GetAudioStreamData(global::SDL3Sharp.AudioStream stream, __IntPtr buf, int len)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var ___ret = __Internal.GetAudioStreamData(__arg0, buf, len);
            return ___ret;
        }

        /// <summary>Get the number of converted/resampled bytes available.</summary>
        /// <param name="stream">The audio stream to query</param>
        /// <remarks>
        /// <para>The stream may be buffering data behind the scenes until it has enough to</para>
        /// <para>resample correctly, so this number might be lower than what you expect, or</para>
        /// <para>even be zero. Add more data or flush the stream if you need the data now.</para>
        /// <para>If the stream has so much data that it would overflow an int, the return</para>
        /// <para>value is clamped to a maximum value, but no queued data is lost; if there</para>
        /// <para>are gigabytes of data queued, the app might need to read some of it with</para>
        /// <para>SDL_GetAudioStreamData before this function's return value is no longer</para>
        /// <para>clamped.</para>
        /// <para>the number of converted/resampled bytes available.</para>
        /// <para>It is safe to call this function from any thread.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateAudioStream</para>
        /// <para>SDL_PutAudioStreamData</para>
        /// <para>SDL_GetAudioStreamData</para>
        /// <para>SDL_FlushAudioStream</para>
        /// <para>SDL_ClearAudioStream</para>
        /// <para>SDL_DestroyAudioStream</para>
        /// </remarks>
        public static int GetAudioStreamAvailable(global::SDL3Sharp.AudioStream stream)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var ___ret = __Internal.GetAudioStreamAvailable(__arg0);
            return ___ret;
        }

        /// <summary>Get the number of bytes currently queued.</summary>
        /// <param name="stream">The audio stream to query</param>
        /// <remarks>
        /// <para>Note that audio streams can change their input format at any time, even if</para>
        /// <para>there is still data queued in a different format, so the returned byte</para>
        /// <para>count will not necessarily match the number of _sample frames_ available.</para>
        /// <para>Users of this API should be aware of format changes they make when feeding</para>
        /// <para>a stream and plan accordingly.</para>
        /// <para>Queued data is not converted until it is consumed by</para>
        /// <para>SDL_GetAudioStreamData, so this value should be representative of the exact</para>
        /// <para>data that was put into the stream.</para>
        /// <para>If the stream has so much data that it would overflow an int, the return</para>
        /// <para>value is clamped to a maximum value, but no queued data is lost; if there</para>
        /// <para>are gigabytes of data queued, the app might need to read some of it with</para>
        /// <para>SDL_GetAudioStreamData before this function's return value is no longer</para>
        /// <para>clamped.</para>
        /// <para>the number of bytes queued.</para>
        /// <para>It is safe to call this function from any thread.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_PutAudioStreamData</para>
        /// <para>SDL_GetAudioStreamData</para>
        /// <para>SDL_ClearAudioStream</para>
        /// </remarks>
        public static int GetAudioStreamQueued(global::SDL3Sharp.AudioStream stream)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var ___ret = __Internal.GetAudioStreamQueued(__arg0);
            return ___ret;
        }

        /// <summary>
        /// <para>Tell the stream that you're done sending data, and anything being buffered</para>
        /// <para>should be converted/resampled and made available immediately.</para>
        /// </summary>
        /// <param name="stream">The audio stream to flush</param>
        /// <remarks>
        /// <para>It is legal to add more data to a stream after flushing, but there will be</para>
        /// <para>audio gaps in the output. Generally this is intended to signal the end of</para>
        /// <para>input, so the complete output becomes available.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>It is safe to call this function from any thread.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateAudioStream</para>
        /// <para>SDL_PutAudioStreamData</para>
        /// <para>SDL_GetAudioStreamData</para>
        /// <para>SDL_GetAudioStreamAvailable</para>
        /// <para>SDL_ClearAudioStream</para>
        /// <para>SDL_DestroyAudioStream</para>
        /// </remarks>
        public static int FlushAudioStream(global::SDL3Sharp.AudioStream stream)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var ___ret = __Internal.FlushAudioStream(__arg0);
            return ___ret;
        }

        /// <summary>Clear any pending data in the stream without converting it</summary>
        /// <param name="stream">The audio stream to clear</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>It is safe to call this function from any thread.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateAudioStream</para>
        /// <para>SDL_PutAudioStreamData</para>
        /// <para>SDL_GetAudioStreamData</para>
        /// <para>SDL_GetAudioStreamAvailable</para>
        /// <para>SDL_FlushAudioStream</para>
        /// <para>SDL_DestroyAudioStream</para>
        /// </remarks>
        public static int ClearAudioStream(global::SDL3Sharp.AudioStream stream)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var ___ret = __Internal.ClearAudioStream(__arg0);
            return ___ret;
        }

        /// <summary>Lock an audio stream for serialized access.</summary>
        /// <param name="stream">The audio stream to lock.</param>
        /// <remarks>
        /// <para>Each SDL_AudioStream has an internal mutex it uses to protect its data</para>
        /// <para>structures from threading conflicts. This function allows an app to lock</para>
        /// <para>that mutex, which could be useful if registering callbacks on this stream.</para>
        /// <para>One does not need to lock a stream to use in it most cases, as the stream</para>
        /// <para>manages this lock internally. However, this lock is held during callbacks,</para>
        /// <para>which may run from arbitrary threads at any time, so if an app needs to</para>
        /// <para>protect shared data during those callbacks, locking the stream guarantees</para>
        /// <para>that the callback is not running while the lock is held.</para>
        /// <para>As this is just a wrapper over SDL_LockMutex for an internal lock, it has</para>
        /// <para>all the same attributes (recursive locks are allowed, etc).</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>It is safe to call this function from any thread.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_UnlockAudioStream</para>
        /// <para>SDL_SetAudioStreamPutCallback</para>
        /// <para>SDL_SetAudioStreamGetCallback</para>
        /// </remarks>
        public static int LockAudioStream(global::SDL3Sharp.AudioStream stream)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var ___ret = __Internal.LockAudioStream(__arg0);
            return ___ret;
        }

        /// <summary>Unlock an audio stream for serialized access.</summary>
        /// <param name="stream">The audio stream to unlock.</param>
        /// <remarks>
        /// <para>This unlocks an audio stream after a call to SDL_LockAudioStream.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>You should only call this from the same thread that</para>
        /// <para>previously called SDL_LockAudioStream.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_LockAudioStream</para>
        /// <para>SDL_SetAudioStreamPutCallback</para>
        /// <para>SDL_SetAudioStreamGetCallback</para>
        /// </remarks>
        public static int UnlockAudioStream(global::SDL3Sharp.AudioStream stream)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var ___ret = __Internal.UnlockAudioStream(__arg0);
            return ___ret;
        }

        /// <summary>Set a callback that runs when data is requested from an audio stream.</summary>
        /// <param name="stream">the audio stream to set the new callback on.</param>
        /// <param name="callback">
        /// <para>the new callback function to call when data is added to the</para>
        /// <para>stream.</para>
        /// </param>
        /// <param name="userdata">
        /// <para>an opaque pointer provided to the callback for its own</para>
        /// <para>personal use.</para>
        /// </param>
        /// <remarks>
        /// <para>This callback is called _before_ data is obtained from the stream, giving</para>
        /// <para>the callback the chance to add more on-demand.</para>
        /// <para>The callback can (optionally) call SDL_PutAudioStreamData() to add more</para>
        /// <para>audio to the stream during this call; if needed, the request that triggered</para>
        /// <para>this callback will obtain the new data immediately.</para>
        /// <para>The callback's `approx_request` argument is roughly how many bytes of</para>
        /// <para>_unconverted_ data (in the stream's input format) is needed by the caller,</para>
        /// <para>although this may overestimate a little for safety. This takes into account</para>
        /// <para>how much is already in the stream and only asks for any extra necessary to</para>
        /// <para>resolve the request, which means the callback may be asked for zero bytes,</para>
        /// <para>and a different amount on each call.</para>
        /// <para>The callback is not required to supply exact amounts; it is allowed to</para>
        /// <para>supply too much or too little or none at all. The caller will get what's</para>
        /// <para>available, up to the amount they requested, regardless of this callback's</para>
        /// <para>outcome.</para>
        /// <para>Clearing or flushing an audio stream does not call this callback.</para>
        /// <para>This function obtains the stream's lock, which means any existing callback</para>
        /// <para>(get or put) in progress will finish running before setting the new</para>
        /// <para>callback.</para>
        /// <para>Setting a NULL function turns off the callback.</para>
        /// <para>0 on success, -1 on error. This only fails if `stream` is NULL.</para>
        /// <para>It is safe to call this function from any thread.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_SetAudioStreamPutCallback</para>
        /// </remarks>
        public static int SetAudioStreamGetCallback(global::SDL3Sharp.AudioStream stream, global::SDL3Sharp.AudioStreamCallback callback, __IntPtr userdata)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var __arg1 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var ___ret = __Internal.SetAudioStreamGetCallback(__arg0, __arg1, userdata);
            return ___ret;
        }

        /// <summary>Set a callback that runs when data is added to an audio stream.</summary>
        /// <param name="stream">the audio stream to set the new callback on.</param>
        /// <param name="callback">
        /// <para>the new callback function to call when data is added to the</para>
        /// <para>stream.</para>
        /// </param>
        /// <param name="userdata">
        /// <para>an opaque pointer provided to the callback for its own</para>
        /// <para>personal use.</para>
        /// </param>
        /// <remarks>
        /// <para>This callback is called _after_ the data is added to the stream, giving the</para>
        /// <para>callback the chance to obtain it immediately.</para>
        /// <para>The callback can (optionally) call SDL_GetAudioStreamData() to obtain audio</para>
        /// <para>from the stream during this call.</para>
        /// <para>The callback's `approx_request` argument is how many bytes of _converted_</para>
        /// <para>data (in the stream's output format) was provided by the caller, although</para>
        /// <para>this may underestimate a little for safety. This value might be less than</para>
        /// <para>what is currently available in the stream, if data was already there, and</para>
        /// <para>might be less than the caller provided if the stream needs to keep a buffer</para>
        /// <para>to aid in resampling. Which means the callback may be provided with zero</para>
        /// <para>bytes, and a different amount on each call.</para>
        /// <para>The callback may call SDL_GetAudioStreamAvailable to see the total amount</para>
        /// <para>currently available to read from the stream, instead of the total provided</para>
        /// <para>by the current call.</para>
        /// <para>The callback is not required to obtain all data. It is allowed to read less</para>
        /// <para>or none at all. Anything not read now simply remains in the stream for</para>
        /// <para>later access.</para>
        /// <para>Clearing or flushing an audio stream does not call this callback.</para>
        /// <para>This function obtains the stream's lock, which means any existing callback</para>
        /// <para>(get or put) in progress will finish running before setting the new</para>
        /// <para>callback.</para>
        /// <para>Setting a NULL function turns off the callback.</para>
        /// <para>0 on success, -1 on error. This only fails if `stream` is NULL.</para>
        /// <para>It is safe to call this function from any thread.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_SetAudioStreamGetCallback</para>
        /// </remarks>
        public static int SetAudioStreamPutCallback(global::SDL3Sharp.AudioStream stream, global::SDL3Sharp.AudioStreamCallback callback, __IntPtr userdata)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var __arg1 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var ___ret = __Internal.SetAudioStreamPutCallback(__arg0, __arg1, userdata);
            return ___ret;
        }

        /// <summary>Free an audio stream</summary>
        /// <param name="stream">The audio stream to free</param>
        /// <remarks>
        /// <para>It is safe to call this function from any thread.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateAudioStream</para>
        /// <para>SDL_PutAudioStreamData</para>
        /// <para>SDL_GetAudioStreamData</para>
        /// <para>SDL_GetAudioStreamAvailable</para>
        /// <para>SDL_FlushAudioStream</para>
        /// <para>SDL_ClearAudioStream</para>
        /// </remarks>
        public static void DestroyAudioStream(global::SDL3Sharp.AudioStream stream)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            __Internal.DestroyAudioStream(__arg0);
        }

        /// <summary>Convenience function for straightforward audio init for the common case.</summary>
        /// <param name="devid">
        /// <para>an audio device to open, or SDL_AUDIO_DEVICE_DEFAULT_OUTPUT or</para>
        /// <para>SDL_AUDIO_DEVICE_DEFAULT_CAPTURE.</para>
        /// </param>
        /// <param name="spec">the audio stream's data format. Required.</param>
        /// <param name="callback">
        /// <para>A callback where the app will provide new data for</para>
        /// <para>playback, or receive new data for capture. Can be NULL, in</para>
        /// <para>which case the app will need to call SDL_PutAudioStreamData</para>
        /// <para>or SDL_GetAudioStreamData as necessary.</para>
        /// </param>
        /// <param name="userdata">
        /// <para>App-controlled pointer passed to callback. Can be NULL.</para>
        /// <para>Ignored if callback is NULL.</para>
        /// </param>
        /// <remarks>
        /// <para>If all your app intends to do is provide a single source of PCM audio, this</para>
        /// <para>function allows you to do all your audio setup in a single call.</para>
        /// <para>This is intended to be a clean means to migrate apps from SDL2.</para>
        /// <para>This function will open an audio device, create a stream and bind it.</para>
        /// <para>Unlike other methods of setup, the audio device will be closed when this</para>
        /// <para>stream is destroyed, so the app can treat the returned SDL_AudioStream as</para>
        /// <para>the only object needed to manage audio playback.</para>
        /// <para>Also unlike other functions, the audio device begins paused. This is to map</para>
        /// <para>more closely to SDL2-style behavior, and since there is no extra step here</para>
        /// <para>to bind a stream to begin audio flowing. The audio device should be resumed</para>
        /// <para>with SDL_ResumeAudioDevice(SDL_GetAudioStreamDevice(stream));</para>
        /// <para>This function works with both playback and capture devices.</para>
        /// <para>The `spec` parameter represents the app's side of the audio stream. That</para>
        /// <para>is, for recording audio, this will be the output format, and for playing</para>
        /// <para>audio, this will be the input format.</para>
        /// <para>If you don't care about opening a specific audio device, you can (and</para>
        /// <para>probably _should_), use SDL_AUDIO_DEVICE_DEFAULT_OUTPUT for playback and</para>
        /// <para>SDL_AUDIO_DEVICE_DEFAULT_CAPTURE for recording.</para>
        /// <para>One can optionally provide a callback function; if NULL, the app is</para>
        /// <para>expected to queue audio data for playback (or unqueue audio data if</para>
        /// <para>capturing). Otherwise, the callback will begin to fire once the device is</para>
        /// <para>unpaused.</para>
        /// <para>an audio stream on success, ready to use. NULL on error; call</para>
        /// <para>SDL_GetError() for more information. When done with this stream,</para>
        /// <para>call SDL_DestroyAudioStream to free resources and close the</para>
        /// <para>device.</para>
        /// <para>It is safe to call this function from any thread.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetAudioStreamDevice</para>
        /// <para>SDL_ResumeAudioDevice</para>
        /// </remarks>
        public static global::SDL3Sharp.AudioStream OpenAudioDeviceStream(uint devid, global::SDL3Sharp.AudioSpec spec, global::SDL3Sharp.AudioStreamCallback callback, __IntPtr userdata)
        {
            var __arg1 = spec is null ? __IntPtr.Zero : spec.__Instance;
            var __arg2 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var ___ret = __Internal.OpenAudioDeviceStream(devid, __arg1, __arg2, userdata);
            var __result0 = global::SDL3Sharp.AudioStream.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Set a callback that fires when data is about to be fed to an audio device.</summary>
        /// <param name="devid">The ID of an opened audio device.</param>
        /// <param name="callback">A callback function to be called. Can be NULL.</param>
        /// <param name="userdata">App-controlled pointer passed to callback. Can be NULL.</param>
        /// <remarks>
        /// <para>This is useful for accessing the final mix, perhaps for writing a</para>
        /// <para>visualizer or applying a final effect to the audio data before playback.</para>
        /// <para>The buffer is the final mix of all bound audio streams on an opened device;</para>
        /// <para>this callback will fire regularly for any device that is both opened and</para>
        /// <para>unpaused. If there is no new data to mix, either because no streams are</para>
        /// <para>bound to the device or all the streams are empty, this callback will still</para>
        /// <para>fire with the entire buffer set to silence.</para>
        /// <para>This callback is allowed to make changes to the data; the contents of the</para>
        /// <para>buffer after this call is what is ultimately passed along to the hardware.</para>
        /// <para>The callback is always provided the data in float format (values from -1.0f</para>
        /// <para>to 1.0f), but the number of channels or sample rate may be different than</para>
        /// <para>the format the app requested when opening the device; SDL might have had to</para>
        /// <para>manage a conversion behind the scenes, or the playback might have jumped to</para>
        /// <para>new physical hardware when a system default changed, etc. These details may</para>
        /// <para>change between calls. Accordingly, the size of the buffer might change</para>
        /// <para>between calls as well.</para>
        /// <para>This callback can run at any time, and from any thread; if you need to</para>
        /// <para>serialize access to your app's data, you should provide and use a mutex or</para>
        /// <para>other synchronization device.</para>
        /// <para>All of this to say: there are specific needs this callback can fulfill, but</para>
        /// <para>it is not the simplest interface. Apps should generally provide audio in</para>
        /// <para>their preferred format through an SDL_AudioStream and let SDL handle the</para>
        /// <para>difference.</para>
        /// <para>This function is extremely time-sensitive; the callback should do the least</para>
        /// <para>amount of work possible and return as quickly as it can. The longer the</para>
        /// <para>callback runs, the higher the risk of audio dropouts or other problems.</para>
        /// <para>This function will block until the audio device is in between iterations,</para>
        /// <para>so any existing callback that might be running will finish before this</para>
        /// <para>function sets the new callback and returns.</para>
        /// <para>Setting a NULL callback function disables any previously-set callback.</para>
        /// <para>zero on success, -1 on error; call SDL_GetError() for more</para>
        /// <para>information.</para>
        /// <para>It is safe to call this function from any thread.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int SetAudioPostmixCallback(uint devid, global::SDL3Sharp.AudioPostmixCallback callback, __IntPtr userdata)
        {
            var __arg1 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var ___ret = __Internal.SetAudioPostmixCallback(devid, __arg1, userdata);
            return ___ret;
        }

        /// <summary>Load the audio data of a WAVE file into memory.</summary>
        /// <param name="src">The data source for the WAVE data</param>
        /// <param name="freesrc">
        /// <para>If SDL_TRUE, calls SDL_RWclose() on `src` before returning,</para>
        /// <para>even in the case of an error</para>
        /// </param>
        /// <param name="spec">
        /// <para>A pointer to an SDL_AudioSpec that will be set to the WAVE</para>
        /// <para>data's format details on successful return</para>
        /// </param>
        /// <param name="audio_buf">
        /// <para>A pointer filled with the audio data, allocated by the</para>
        /// <para>function</para>
        /// </param>
        /// <param name="audio_len">
        /// <para>A pointer filled with the length of the audio data buffer</para>
        /// <para>in bytes</para>
        /// </param>
        /// <remarks>
        /// <para>Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to</para>
        /// <para>be valid pointers. The entire data portion of the file is then loaded into</para>
        /// <para>memory and decoded if necessary.</para>
        /// <para>Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and</para>
        /// <para>32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and</para>
        /// <para>A-law and mu-law (8 bits). Other formats are currently unsupported and</para>
        /// <para>cause an error.</para>
        /// <para>If this function succeeds, the return value is zero and the pointer to the</para>
        /// <para>audio data allocated by the function is written to `audio_buf` and its</para>
        /// <para>length in bytes to `audio_len`. The SDL_AudioSpec members `freq`,</para>
        /// <para>`channels`, and `format` are set to the values of the audio data in the</para>
        /// <para>buffer.</para>
        /// <para>It's necessary to use SDL_free() to free the audio data returned in</para>
        /// <para>`audio_buf` when it is no longer used.</para>
        /// <para>Because of the underspecification of the .WAV format, there are many</para>
        /// <para>problematic files in the wild that cause issues with strict decoders. To</para>
        /// <para>provide compatibility with these files, this decoder is lenient in regards</para>
        /// <para>to the truncation of the file, the fact chunk, and the size of the RIFF</para>
        /// <para>chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,</para>
        /// <para>`SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to</para>
        /// <para>tune the behavior of the loading process.</para>
        /// <para>Any file that is invalid (due to truncation, corruption, or wrong values in</para>
        /// <para>the headers), too big, or unsupported causes an error. Additionally, any</para>
        /// <para>critical I/O error from the data source will terminate the loading process</para>
        /// <para>with an error. The function returns NULL on error and in all cases (with</para>
        /// <para>the exception of `src` being NULL), an appropriate error message will be</para>
        /// <para>set.</para>
        /// <para>It is required that the data source supports seeking.</para>
        /// <para>Example:</para>
        /// <para>```c</para>
        /// <para>SDL_LoadWAV_RW(SDL_RWFromFile(&quot;sample.wav&quot;, &quot;rb&quot;), 1,&amp;spec,&amp;buf,&amp;len);</para>
        /// <para>```</para>
        /// <para>Note that the SDL_LoadWAV function does this same thing for you, but in a</para>
        /// <para>less messy way:</para>
        /// <para>```c</para>
        /// <para>SDL_LoadWAV(&quot;sample.wav&quot;,&amp;spec,&amp;buf,&amp;len);</para>
        /// <para>```</para>
        /// <para>This function, if successfully called, returns 0. `audio_buf` will</para>
        /// <para>be filled with a pointer to an allocated buffer containing the</para>
        /// <para>audio data, and `audio_len` is filled with the length of that</para>
        /// <para>audio buffer in bytes.</para>
        /// <para>This function returns -1 if the .WAV file cannot be opened, uses</para>
        /// <para>an unknown data format, or is corrupt; call SDL_GetError() for</para>
        /// <para>more information.</para>
        /// <para>When the application is done with the data returned in</para>
        /// <para>`audio_buf`, it should call SDL_free() to dispose of it.</para>
        /// <para>It is safe to call this function from any thread.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_free</para>
        /// <para>SDL_LoadWAV</para>
        /// </remarks>
        public static int LoadWAV_RW(global::SDL3Sharp.RWops src, bool freesrc, global::SDL3Sharp.AudioSpec spec, byte** audio_buf, ref uint audio_len)
        {
            var __arg0 = src is null ? __IntPtr.Zero : src.__Instance;
            var __arg2 = spec is null ? __IntPtr.Zero : spec.__Instance;
            fixed (uint* __audio_len4 = &audio_len)
            {
                var __arg4 = __audio_len4;
                var ___ret = __Internal.LoadWAV_RW(__arg0, freesrc, __arg2, audio_buf, __arg4);
                return ___ret;
            }
        }

        /// <summary>Loads a WAV from a file path.</summary>
        /// <param name="path">The file path of the WAV file to open.</param>
        /// <param name="spec">
        /// <para>A pointer to an SDL_AudioSpec that will be set to the WAVE</para>
        /// <para>data's format details on successful return.</para>
        /// </param>
        /// <param name="audio_buf">
        /// <para>A pointer filled with the audio data, allocated by the</para>
        /// <para>function.</para>
        /// </param>
        /// <param name="audio_len">
        /// <para>A pointer filled with the length of the audio data buffer</para>
        /// <para>in bytes</para>
        /// </param>
        /// <remarks>
        /// <para>This is a convenience function that is effectively the same as:</para>
        /// <para>```c</para>
        /// <para>SDL_LoadWAV_RW(SDL_RWFromFile(path, &quot;rb&quot;), 1, spec, audio_buf, audio_len);</para>
        /// <para>```</para>
        /// <para>Note that in SDL2, this was a preprocessor macro and not a real function.</para>
        /// <para>This function, if successfully called, returns 0. `audio_buf` will</para>
        /// <para>be filled with a pointer to an allocated buffer containing the</para>
        /// <para>audio data, and `audio_len` is filled with the length of that</para>
        /// <para>audio buffer in bytes.</para>
        /// <para>This function returns -1 if the .WAV file cannot be opened, uses</para>
        /// <para>an unknown data format, or is corrupt; call SDL_GetError() for</para>
        /// <para>more information.</para>
        /// <para>When the application is done with the data returned in</para>
        /// <para>`audio_buf`, it should call SDL_free() to dispose of it.</para>
        /// <para>It is safe to call this function from any thread.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_free</para>
        /// <para>SDL_LoadWAV_RW</para>
        /// </remarks>
        public static int LoadWAV(string path, global::SDL3Sharp.AudioSpec spec, byte** audio_buf, ref uint audio_len)
        {
            var __arg1 = spec is null ? __IntPtr.Zero : spec.__Instance;
            fixed (uint* __audio_len3 = &audio_len)
            {
                var __arg3 = __audio_len3;
                var ___ret = __Internal.LoadWAV(path, __arg1, audio_buf, __arg3);
                return ___ret;
            }
        }

        /// <summary>Mix audio data in a specified format.</summary>
        /// <param name="dst">the destination for the mixed audio</param>
        /// <param name="src">the source audio buffer to be mixed</param>
        /// <param name="format">
        /// <para>the SDL_AudioFormat structure representing the desired audio</para>
        /// <para>format</para>
        /// </param>
        /// <param name="len">the length of the audio buffer in bytes</param>
        /// <param name="volume">
        /// <para>ranges from 0 - 128, and should be set to SDL_MIX_MAXVOLUME</para>
        /// <para>for full audio volume</para>
        /// </param>
        /// <remarks>
        /// <para>This takes an audio buffer `src` of `len` bytes of `format` data and mixes</para>
        /// <para>it into `dst`, performing addition, volume adjustment, and overflow</para>
        /// <para>clipping. The buffer pointed to by `dst` must also be `len` bytes of</para>
        /// <para>`format` data.</para>
        /// <para>This is provided for convenience -- you can mix your own audio data.</para>
        /// <para>Do not use this function for mixing together more than two streams of</para>
        /// <para>sample data. The output from repeated application of this function may be</para>
        /// <para>distorted by clipping, because there is no accumulator with greater range</para>
        /// <para>than the input (not to mention this being an inefficient way of doing it).</para>
        /// <para>It is a common misconception that this function is required to write audio</para>
        /// <para>data to an output stream in an audio callback. While you can do that,</para>
        /// <para>SDL_MixAudioFormat() is really only needed when you're mixing a single</para>
        /// <para>audio stream with a volume adjustment.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>It is safe to call this function from any thread.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int MixAudioFormat(byte* dst, byte* src, ushort format, uint len, int volume)
        {
            var ___ret = __Internal.MixAudioFormat(dst, src, format, len, volume);
            return ___ret;
        }

        /// <summary>Convert some audio data of one format to another format.</summary>
        /// <param name="src_spec">The format details of the input audio</param>
        /// <param name="src_data">The audio data to be converted</param>
        /// <param name="src_len">The len of src_data</param>
        /// <param name="dst_spec">The format details of the output audio</param>
        /// <param name="dst_data">
        /// <para>Will be filled with a pointer to converted audio data,</para>
        /// <para>which should be freed with SDL_free(). On error, it will be</para>
        /// <para>NULL.</para>
        /// </param>
        /// <param name="dst_len">Will be filled with the len of dst_data</param>
        /// <remarks>
        /// <para>Please note that this function is for convenience, but should not be used</para>
        /// <para>to resample audio in blocks, as it will introduce audio artifacts on the</para>
        /// <para>boundaries. You should only use this function if you are converting audio</para>
        /// <para>data in its entirety in one call. If you want to convert audio in smaller</para>
        /// <para>chunks, use an SDL_AudioStream, which is designed for this situation.</para>
        /// <para>Internally, this function creates and destroys an SDL_AudioStream on each</para>
        /// <para>use, so it's also less efficient than using one directly, if you need to</para>
        /// <para>convert multiple times.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>It is safe to call this function from any thread.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateAudioStream</para>
        /// </remarks>
        public static int ConvertAudioSamples(global::SDL3Sharp.AudioSpec src_spec, byte* src_data, int src_len, global::SDL3Sharp.AudioSpec dst_spec, byte** dst_data, ref int dst_len)
        {
            var __arg0 = src_spec is null ? __IntPtr.Zero : src_spec.__Instance;
            var __arg3 = dst_spec is null ? __IntPtr.Zero : dst_spec.__Instance;
            fixed (int* __dst_len5 = &dst_len)
            {
                var __arg5 = __dst_len5;
                var ___ret = __Internal.ConvertAudioSamples(__arg0, src_data, src_len, __arg3, dst_data, __arg5);
                return ___ret;
            }
        }

        /// <summary>Get the appropriate memset value for silencing an audio format.</summary>
        /// <param name="format">the audio data format to query.</param>
        /// <remarks>
        /// <para>The value returned by this function can be used as the second argument to</para>
        /// <para>memset (or SDL_memset) to set an audio buffer in a specific format to</para>
        /// <para>silence.</para>
        /// <para>A byte value that can be passed to memset.</para>
        /// <para>It is safe to call this function from any thread.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int GetSilenceValueForFormat(ushort format)
        {
            var ___ret = __Internal.GetSilenceValueForFormat(format);
            return ___ret;
        }
    }
}
