// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required
#pragma warning disable CS9084 // Struct member returns 'this' or other instance members by reference

namespace SDL3Sharp
{
    /// <summary>System theme</summary>
    public enum SystemTheme
    {
        /// <summary>Unknown system theme</summary>
        Unknown = 0,
        /// <summary>Light colored system theme</summary>
        Light = 1,
        /// <summary>Dark colored system theme</summary>
        Dark = 2
    }

    /// <summary>Display orientation</summary>
    public enum DisplayOrientation
    {
        /// <summary>The display orientation can't be determined</summary>
        Unknown = 0,
        /// <summary>The display is in landscape mode, with the right side up, relative to portrait mode</summary>
        Landscape = 1,
        /// <summary>The display is in landscape mode, with the left side up, relative to portrait mode</summary>
        LandscapeFlipped = 2,
        /// <summary>The display is in portrait mode</summary>
        Portrait = 3,
        /// <summary>The display is in portrait mode, upside down</summary>
        PortraitFlipped = 4
    }

    /// <summary>Window flash operation</summary>
    public enum FlashOperation
    {
        /// <summary>Cancel any window flash state</summary>
        Cancel = 0,
        /// <summary>Flash the window briefly to get attention</summary>
        Briefly = 1,
        /// <summary>Flash the window until it gets focus</summary>
        UntilFocused = 2
    }

    /// <summary>OpenGL configuration attributes</summary>
    public enum GLattr
    {
        RedSize = 0,
        GreenSize = 1,
        BlueSize = 2,
        AlphaSize = 3,
        BufferSize = 4,
        Doublebuffer = 5,
        DepthSize = 6,
        StencilSize = 7,
        AccumRedSize = 8,
        AccumGreenSize = 9,
        AccumBlueSize = 10,
        AccumAlphaSize = 11,
        Stereo = 12,
        Multisamplebuffers = 13,
        Multisamplesamples = 14,
        AcceleratedVisual = 15,
        RetainedBacking = 16,
        ContextMajorVersion = 17,
        ContextMinorVersion = 18,
        ContextFlags = 19,
        ContextProfileMask = 20,
        ShareWithCurrentContext = 21,
        FramebufferSrgbCapable = 22,
        ContextReleaseBehavior = 23,
        ContextResetNotification = 24,
        ContextNoError = 25,
        Floatbuffers = 26,
        EglPlatform = 27
    }

    [Flags]
    public enum GLprofile
    {
        Core = 1,
        Compatibility = 2,
        /// <summary>GLX_CONTEXT_ES2_PROFILE_BIT_EXT</summary>
        Es = 4
    }

    [Flags]
    public enum GLcontextFlag
    {
        DebugFlag = 1,
        ForwardCompatibleFlag = 2,
        RobustAccessFlag = 4,
        ResetIsolationFlag = 8
    }

    public enum GLcontextReleaseFlag
    {
        None = 0,
        Flush = 1
    }

    public enum GLContextResetNotification
    {
        NoNotification = 0,
        LoseContext = 1
    }

    /// <summary>Possible return values from the SDL_HitTest callback.</summary>
    /// <remarks>SDL_HitTest</remarks>
    public enum HitTestResult
    {
        /// <summary>Region is normal. No special properties.</summary>
        Normal = 0,
        /// <summary>Region can drag entire window.</summary>
        Draggable = 1,
        ResizeTopleft = 2,
        ResizeTop = 3,
        ResizeTopright = 4,
        ResizeRight = 5,
        ResizeBottomright = 6,
        ResizeBottom = 7,
        ResizeBottomleft = 8,
        ResizeLeft = 9
    }

    [Flags]
    public enum WindowFlags : uint
    {
        Fullscreen = 0x1,
        Opengl = 0x2,
        Occluded = 0x4,
        Hidden = 0x8,
        Borderless = 0x10,
        Resizable = 0x20,
        Minimized = 0x40,
        Maximized = 0x80,
        MouseGrabbed = 0x100,
        InputFocus = 0x200,
        MouseFocus = 0x400,
        External = 0x800,
        HighPixelDensity = 0x2000,
        MouseCapture = 0x4000,
        AlwaysOnTop = 0x8000,
        Utility = 0x20000,
        Tooltip = 0x40000,
        PopupMenu = 0x80000,
        KeyboardGrabbed = 0x100000,
        Vulkan = 0x10000000,
        Metal = 0x20000000,
        Transparent = 0x40000000,
        NotFocusable = 0x80000000
    }

    /// <summary>System theme</summary>
    /// <summary>The structure that defines a display mode</summary>
    /// <remarks>
    /// <para>SDL_GetFullscreenDisplayModes()</para>
    /// <para>SDL_GetDesktopDisplayMode()</para>
    /// <para>SDL_GetCurrentDisplayMode()</para>
    /// <para>SDL_SetWindowFullscreenMode()</para>
    /// <para>SDL_GetWindowFullscreenMode()</para>
    /// </remarks>
    /// <summary>Display orientation</summary>
    /// <summary>The flags on a window</summary>
    /// <remarks>SDL_GetWindowFlags</remarks>
    /// <summary>Window flash operation</summary>
    /// <summary>An opaque handle to an OpenGL context.</summary>
    /// <summary>Opaque EGL types.</summary>
    /// <summary>EGL attribute initialization callback types.</summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate long* EGLAttribArrayCallback();

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate int* EGLIntArrayCallback();

    /// <summary>OpenGL configuration attributes</summary>
    /// <summary>Possible return values from the SDL_HitTest callback.</summary>
    /// <remarks>SDL_HitTest</remarks>
    /// <summary>Callback used for hit-testing.</summary>
    /// <param name="win">the SDL_Window where hit-testing was set on</param>
    /// <param name="area">an SDL_Point which should be hit-tested</param>
    /// <param name="data">what was passed as `callback_data` to SDL_SetWindowHitTest()</param>
    /// <remarks>
    /// <para>an SDL_HitTestResult value.</para>
    /// <para>SDL_SetWindowHitTest</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate global::SDL3Sharp.HitTestResult HitTest(__IntPtr win, __IntPtr area, __IntPtr data);

    public unsafe partial class Window
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.Window> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.Window>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.Window managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.Window managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Window __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Window(native.ToPointer(), skipVTables);
        }

        internal static Window __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Window)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Window __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Window(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Window(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Window(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    /// <summary>The structure that defines a display mode</summary>
    /// <remarks>
    /// <para>SDL_GetFullscreenDisplayModes()</para>
    /// <para>SDL_GetDesktopDisplayMode()</para>
    /// <para>SDL_GetCurrentDisplayMode()</para>
    /// <para>SDL_SetWindowFullscreenMode()</para>
    /// <para>SDL_GetWindowFullscreenMode()</para>
    /// </remarks>
    public unsafe partial class DisplayMode : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32, Pack = 8)]
        public partial struct __Internal
        {
            internal uint displayID;
            internal global::SDL3Sharp.PixelFormatEnum format;
            internal int w;
            internal int h;
            internal float pixel_density;
            internal float refresh_rate;
            internal __IntPtr driverdata;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_DisplayMode@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.DisplayMode> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.DisplayMode>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.DisplayMode managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.DisplayMode managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static DisplayMode __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new DisplayMode(native.ToPointer(), skipVTables);
        }

        internal static DisplayMode __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (DisplayMode)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static DisplayMode __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DisplayMode(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DisplayMode(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected DisplayMode(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public DisplayMode()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.DisplayMode.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public DisplayMode(global::SDL3Sharp.DisplayMode _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.DisplayMode.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.DisplayMode.__Internal*) __Instance) = *((global::SDL3Sharp.DisplayMode.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>the display this mode is associated with</summary>
        public uint DisplayID
        {
            get
            {
                return ((__Internal*)__Instance)->displayID;
            }

            set
            {
                ((__Internal*)__Instance)->displayID = value;
            }
        }

        /// <summary>pixel format</summary>
        public global::SDL3Sharp.PixelFormatEnum Format
        {
            get
            {
                return ((__Internal*)__Instance)->format;
            }

            set
            {
                ((__Internal*)__Instance)->format = value;
            }
        }

        /// <summary>width</summary>
        public int W
        {
            get
            {
                return ((__Internal*)__Instance)->w;
            }

            set
            {
                ((__Internal*)__Instance)->w = value;
            }
        }

        /// <summary>height</summary>
        public int H
        {
            get
            {
                return ((__Internal*)__Instance)->h;
            }

            set
            {
                ((__Internal*)__Instance)->h = value;
            }
        }

        /// <summary>scale converting size to pixels (e.g. a 1920x1080 mode with 2.0 scale would have 3840x2160 pixels)</summary>
        public float PixelDensity
        {
            get
            {
                return ((__Internal*)__Instance)->pixel_density;
            }

            set
            {
                ((__Internal*)__Instance)->pixel_density = value;
            }
        }

        /// <summary>refresh rate (or zero for unspecified)</summary>
        public float RefreshRate
        {
            get
            {
                return ((__Internal*)__Instance)->refresh_rate;
            }

            set
            {
                ((__Internal*)__Instance)->refresh_rate = value;
            }
        }

        /// <summary>driver-specific data, initialize to 0</summary>
        public __IntPtr Driverdata
        {
            get
            {
                return ((__Internal*)__Instance)->driverdata;
            }

            set
            {
                ((__Internal*)__Instance)->driverdata = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class SDL
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetNumVideoDrivers", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetNumVideoDrivers();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetVideoDriver", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetVideoDriver(int index);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetCurrentVideoDriver", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetCurrentVideoDriver();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetSystemTheme", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::SDL3Sharp.SystemTheme GetSystemTheme();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetDisplays", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint* GetDisplays(int* count);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetPrimaryDisplay", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint GetPrimaryDisplay();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetDisplayProperties", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint GetDisplayProperties(uint displayID);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetDisplayName", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetDisplayName(uint displayID);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetDisplayBounds", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetDisplayBounds(uint displayID, __IntPtr rect);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetDisplayUsableBounds", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetDisplayUsableBounds(uint displayID, __IntPtr rect);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetNaturalDisplayOrientation", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::SDL3Sharp.DisplayOrientation GetNaturalDisplayOrientation(uint displayID);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetCurrentDisplayOrientation", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::SDL3Sharp.DisplayOrientation GetCurrentDisplayOrientation(uint displayID);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetDisplayContentScale", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float GetDisplayContentScale(uint displayID);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetFullscreenDisplayModes", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetFullscreenDisplayModes(uint displayID, int* count);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetClosestFullscreenDisplayMode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetClosestFullscreenDisplayMode(uint displayID, int w, int h, float refresh_rate, bool include_high_density_modes);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetDesktopDisplayMode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetDesktopDisplayMode(uint displayID);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetCurrentDisplayMode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetCurrentDisplayMode(uint displayID);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetDisplayForPoint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint GetDisplayForPoint(__IntPtr point);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetDisplayForRect", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint GetDisplayForRect(__IntPtr rect);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetDisplayForWindow", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint GetDisplayForWindow(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetWindowPixelDensity", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float GetWindowPixelDensity(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetWindowDisplayScale", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float GetWindowDisplayScale(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetWindowFullscreenMode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetWindowFullscreenMode(__IntPtr window, __IntPtr mode);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetWindowFullscreenMode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetWindowFullscreenMode(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetWindowICCProfile", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetWindowICCProfile(__IntPtr window, ulong* size);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetWindowPixelFormat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint GetWindowPixelFormat(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_CreateWindow", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CreateWindow([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string title, int w, int h, global::SDL3Sharp.WindowFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_CreatePopupWindow", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CreatePopupWindow(__IntPtr parent, int offset_x, int offset_y, int w, int h, global::SDL3Sharp.WindowFlags flags);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_CreateWindowWithProperties", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CreateWindowWithProperties(uint props);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetWindowID", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint GetWindowID(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetWindowFromID", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetWindowFromID(uint id);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetWindowParent", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetWindowParent(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetWindowProperties", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint GetWindowProperties(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetWindowFlags", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint GetWindowFlags(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetWindowTitle", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetWindowTitle(__IntPtr window, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string title);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetWindowTitle", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetWindowTitle(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetWindowIcon", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetWindowIcon(__IntPtr window, __IntPtr icon);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetWindowPosition", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetWindowPosition(__IntPtr window, int x, int y);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetWindowPosition", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetWindowPosition(__IntPtr window, int* x, int* y);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetWindowSize", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetWindowSize(__IntPtr window, int w, int h);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetWindowSize", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetWindowSize(__IntPtr window, int* w, int* h);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetWindowBordersSize", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetWindowBordersSize(__IntPtr window, int* top, int* left, int* bottom, int* right);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetWindowSizeInPixels", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetWindowSizeInPixels(__IntPtr window, int* w, int* h);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetWindowMinimumSize", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetWindowMinimumSize(__IntPtr window, int min_w, int min_h);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetWindowMinimumSize", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetWindowMinimumSize(__IntPtr window, int* w, int* h);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetWindowMaximumSize", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetWindowMaximumSize(__IntPtr window, int max_w, int max_h);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetWindowMaximumSize", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetWindowMaximumSize(__IntPtr window, int* w, int* h);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetWindowBordered", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetWindowBordered(__IntPtr window, bool bordered);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetWindowResizable", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetWindowResizable(__IntPtr window, bool resizable);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetWindowAlwaysOnTop", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetWindowAlwaysOnTop(__IntPtr window, bool on_top);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_ShowWindow", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int ShowWindow(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_HideWindow", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int HideWindow(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_RaiseWindow", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int RaiseWindow(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_MaximizeWindow", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int MaximizeWindow(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_MinimizeWindow", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int MinimizeWindow(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_RestoreWindow", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int RestoreWindow(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetWindowFullscreen", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetWindowFullscreen(__IntPtr window, bool fullscreen);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SyncWindow", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SyncWindow(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_WindowHasSurface", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool WindowHasSurface(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetWindowSurface", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetWindowSurface(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_UpdateWindowSurface", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int UpdateWindowSurface(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_UpdateWindowSurfaceRects", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int UpdateWindowSurfaceRects(__IntPtr window, __IntPtr rects, int numrects);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_DestroyWindowSurface", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int DestroyWindowSurface(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetWindowGrab", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetWindowGrab(__IntPtr window, bool grabbed);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetWindowKeyboardGrab", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetWindowKeyboardGrab(__IntPtr window, bool grabbed);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetWindowMouseGrab", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetWindowMouseGrab(__IntPtr window, bool grabbed);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetWindowGrab", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool GetWindowGrab(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetWindowKeyboardGrab", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool GetWindowKeyboardGrab(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetWindowMouseGrab", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool GetWindowMouseGrab(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetGrabbedWindow", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetGrabbedWindow();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetWindowMouseRect", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetWindowMouseRect(__IntPtr window, __IntPtr rect);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetWindowMouseRect", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetWindowMouseRect(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetWindowOpacity", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetWindowOpacity(__IntPtr window, float opacity);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetWindowOpacity", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetWindowOpacity(__IntPtr window, float* out_opacity);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetWindowModalFor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetWindowModalFor(__IntPtr modal_window, __IntPtr parent_window);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetWindowInputFocus", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetWindowInputFocus(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetWindowFocusable", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetWindowFocusable(__IntPtr window, bool focusable);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_ShowWindowSystemMenu", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int ShowWindowSystemMenu(__IntPtr window, int x, int y);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetWindowHitTest", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetWindowHitTest(__IntPtr window, __IntPtr callback, __IntPtr callback_data);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetWindowShape", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetWindowShape(__IntPtr window, __IntPtr shape);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_FlashWindow", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FlashWindow(__IntPtr window, global::SDL3Sharp.FlashOperation operation);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_DestroyWindow", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void DestroyWindow(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_ScreenSaverEnabled", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool ScreenSaverEnabled();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_EnableScreenSaver", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int EnableScreenSaver();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_DisableScreenSaver", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int DisableScreenSaver();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GL_LoadLibrary", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GL_LoadLibrary([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string path);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GL_GetProcAddress", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GL_GetProcAddress([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string proc);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_EGL_GetProcAddress", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr EGL_GetProcAddress([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string proc);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GL_UnloadLibrary", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GL_UnloadLibrary();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GL_ExtensionSupported", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool GL_ExtensionSupported([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string extension);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GL_ResetAttributes", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GL_ResetAttributes();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GL_SetAttribute", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GL_SetAttribute(global::SDL3Sharp.GLattr attr, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GL_GetAttribute", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GL_GetAttribute(global::SDL3Sharp.GLattr attr, int* value);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GL_CreateContext", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GL_CreateContext(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GL_MakeCurrent", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GL_MakeCurrent(__IntPtr window, __IntPtr context);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GL_GetCurrentWindow", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GL_GetCurrentWindow();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GL_GetCurrentContext", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GL_GetCurrentContext();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_EGL_GetCurrentEGLDisplay", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr EGL_GetCurrentEGLDisplay();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_EGL_GetCurrentEGLConfig", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr EGL_GetCurrentEGLConfig();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_EGL_GetWindowEGLSurface", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr EGL_GetWindowEGLSurface(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_EGL_SetEGLAttributeCallbacks", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void EGL_SetEGLAttributeCallbacks(__IntPtr platformAttribCallback, __IntPtr surfaceAttribCallback, __IntPtr contextAttribCallback);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GL_SetSwapInterval", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GL_SetSwapInterval(int interval);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GL_GetSwapInterval", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GL_GetSwapInterval(int* interval);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GL_SwapWindow", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GL_SwapWindow(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GL_DeleteContext", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GL_DeleteContext(__IntPtr context);
        }

        /// <summary>Get the number of video drivers compiled into SDL.</summary>
        /// <remarks>
        /// <para>a number &gt;= 1 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetVideoDriver</para>
        /// </remarks>
        public static int GetNumVideoDrivers()
        {
            var ___ret = __Internal.GetNumVideoDrivers();
            return ___ret;
        }

        /// <summary>Get the name of a built in video driver.</summary>
        /// <param name="index">the index of a video driver</param>
        /// <remarks>
        /// <para>The video drivers are presented in the order in which they are normally</para>
        /// <para>checked during initialization.</para>
        /// <para>the name of the video driver with the given **index**.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetNumVideoDrivers</para>
        /// </remarks>
        public static string GetVideoDriver(int index)
        {
            var ___ret = __Internal.GetVideoDriver(index);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Get the name of the currently initialized video driver.</summary>
        /// <remarks>
        /// <para>the name of the current video driver or NULL if no driver has been</para>
        /// <para>initialized.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetNumVideoDrivers</para>
        /// <para>SDL_GetVideoDriver</para>
        /// </remarks>
        public static string GetCurrentVideoDriver()
        {
            var ___ret = __Internal.GetCurrentVideoDriver();
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Get the current system theme</summary>
        /// <remarks>
        /// <para>the current system theme, light, dark, or unknown</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static global::SDL3Sharp.SystemTheme GetSystemTheme()
        {
            var ___ret = __Internal.GetSystemTheme();
            return ___ret;
        }

        /// <summary>Get a list of currently connected displays.</summary>
        /// <param name="count">a pointer filled in with the number of displays returned</param>
        /// <remarks>
        /// <para>a 0 terminated array of display instance IDs which should be freed</para>
        /// <para>with SDL_free(), or NULL on error; call SDL_GetError() for more</para>
        /// <para>details.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static uint* GetDisplays(ref int count)
        {
            fixed (int* __count0 = &count)
            {
                var __arg0 = __count0;
                var ___ret = __Internal.GetDisplays(__arg0);
                return ___ret;
            }
        }

        /// <summary>Return the primary display.</summary>
        /// <remarks>
        /// <para>the instance ID of the primary display on success or 0 on failure;</para>
        /// <para>call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetDisplays</para>
        /// </remarks>
        public static uint GetPrimaryDisplay()
        {
            var ___ret = __Internal.GetPrimaryDisplay();
            return ___ret;
        }

        /// <summary>Get the properties associated with a display.</summary>
        /// <param name="displayID">the instance ID of the display to query</param>
        /// <remarks>
        /// <para>The following read-only properties are provided by SDL:</para>
        /// <para>- `SDL_PROP_DISPLAY_HDR_ENABLED_BOOLEAN`: true if the display has HDR</para>
        /// <para>headroom above the SDR white point. This property can change dynamically</para>
        /// <para>when SDL_EVENT_DISPLAY_HDR_STATE_CHANGED is sent.</para>
        /// <para>- `SDL_PROP_DISPLAY_SDR_WHITE_POINT_FLOAT`: the value of SDR white in the</para>
        /// <para>SDL_COLORSPACE_SRGB_LINEAR colorspace. On Windows this corresponds to the</para>
        /// <para>SDR white level in scRGB colorspace, and on Apple platforms this is</para>
        /// <para>always 1.0 for EDR content. This property can change dynamically when</para>
        /// <para>SDL_EVENT_DISPLAY_HDR_STATE_CHANGED is sent.</para>
        /// <para>- `SDL_PROP_DISPLAY_HDR_HEADROOM_FLOAT`: the additional high dynamic range</para>
        /// <para>that can be displayed, in terms of the SDR white point. When HDR is not</para>
        /// <para>enabled, this will be 1.0. This property can change dynamically when</para>
        /// <para>SDL_EVENT_DISPLAY_HDR_STATE_CHANGED is sent.</para>
        /// <para>a valid property ID on success or 0 on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetProperty</para>
        /// <para>SDL_SetProperty</para>
        /// </remarks>
        public static uint GetDisplayProperties(uint displayID)
        {
            var ___ret = __Internal.GetDisplayProperties(displayID);
            return ___ret;
        }

        /// <summary>Get the name of a display in UTF-8 encoding.</summary>
        /// <param name="displayID">the instance ID of the display to query</param>
        /// <remarks>
        /// <para>the name of a display or NULL on failure; call SDL_GetError() for</para>
        /// <para>more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetDisplays</para>
        /// </remarks>
        public static string GetDisplayName(uint displayID)
        {
            var ___ret = __Internal.GetDisplayName(displayID);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Get the desktop area represented by a display.</summary>
        /// <param name="displayID">the instance ID of the display to query</param>
        /// <param name="rect">the SDL_Rect structure filled in with the display bounds</param>
        /// <remarks>
        /// <para>The primary display is always located at (0,0).</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetDisplayUsableBounds</para>
        /// <para>SDL_GetDisplays</para>
        /// </remarks>
        public static int GetDisplayBounds(uint displayID, global::SDL3Sharp.Rect rect)
        {
            var __arg1 = rect is null ? __IntPtr.Zero : rect.__Instance;
            var ___ret = __Internal.GetDisplayBounds(displayID, __arg1);
            return ___ret;
        }

        /// <summary>
        /// <para>Get the usable desktop area represented by a display, in screen</para>
        /// <para>coordinates.</para>
        /// </summary>
        /// <param name="displayID">the instance ID of the display to query</param>
        /// <param name="rect">the SDL_Rect structure filled in with the display bounds</param>
        /// <remarks>
        /// <para>This is the same area as SDL_GetDisplayBounds() reports, but with portions</para>
        /// <para>reserved by the system removed. For example, on Apple's macOS, this</para>
        /// <para>subtracts the area occupied by the menu bar and dock.</para>
        /// <para>Setting a window to be fullscreen generally bypasses these unusable areas,</para>
        /// <para>so these are good guidelines for the maximum space available to a</para>
        /// <para>non-fullscreen window.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetDisplayBounds</para>
        /// <para>SDL_GetDisplays</para>
        /// </remarks>
        public static int GetDisplayUsableBounds(uint displayID, global::SDL3Sharp.Rect rect)
        {
            var __arg1 = rect is null ? __IntPtr.Zero : rect.__Instance;
            var ___ret = __Internal.GetDisplayUsableBounds(displayID, __arg1);
            return ___ret;
        }

        /// <summary>Get the orientation of a display when it is unrotated.</summary>
        /// <param name="displayID">the instance ID of the display to query</param>
        /// <remarks>
        /// <para>The SDL_DisplayOrientation enum value of the display, or</para>
        /// <para>`SDL_ORIENTATION_UNKNOWN` if it isn't available.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetDisplays</para>
        /// </remarks>
        public static global::SDL3Sharp.DisplayOrientation GetNaturalDisplayOrientation(uint displayID)
        {
            var ___ret = __Internal.GetNaturalDisplayOrientation(displayID);
            return ___ret;
        }

        /// <summary>Get the orientation of a display.</summary>
        /// <param name="displayID">the instance ID of the display to query</param>
        /// <remarks>
        /// <para>The SDL_DisplayOrientation enum value of the display, or</para>
        /// <para>`SDL_ORIENTATION_UNKNOWN` if it isn't available.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetDisplays</para>
        /// </remarks>
        public static global::SDL3Sharp.DisplayOrientation GetCurrentDisplayOrientation(uint displayID)
        {
            var ___ret = __Internal.GetCurrentDisplayOrientation(displayID);
            return ___ret;
        }

        /// <summary>Get the content scale of a display.</summary>
        /// <param name="displayID">the instance ID of the display to query</param>
        /// <remarks>
        /// <para>The content scale is the expected scale for content based on the DPI</para>
        /// <para>settings of the display. For example, a 4K display might have a 2.0 (200%)</para>
        /// <para>display scale, which means that the user expects UI elements to be twice as</para>
        /// <para>big on this display, to aid in readability.</para>
        /// <para>The content scale of the display, or 0.0f on error; call</para>
        /// <para>SDL_GetError() for more details.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetDisplays</para>
        /// </remarks>
        public static float GetDisplayContentScale(uint displayID)
        {
            var ___ret = __Internal.GetDisplayContentScale(displayID);
            return ___ret;
        }

        /// <summary>Get a list of fullscreen display modes available on a display.</summary>
        /// <param name="displayID">the instance ID of the display to query</param>
        /// <param name="count">a pointer filled in with the number of displays returned</param>
        /// <remarks>
        /// <para>The display modes are sorted in this priority:</para>
        /// <para>- w -&gt; largest to smallest</para>
        /// <para>- h -&gt; largest to smallest</para>
        /// <para>- bits per pixel -&gt; more colors to fewer colors</para>
        /// <para>- packed pixel layout -&gt; largest to smallest</para>
        /// <para>- refresh rate -&gt; highest to lowest</para>
        /// <para>- pixel density -&gt; lowest to highest</para>
        /// <para>a NULL terminated array of display mode pointers which should be</para>
        /// <para>freed with SDL_free(), or NULL on error; call SDL_GetError() for</para>
        /// <para>more details.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetDisplays</para>
        /// </remarks>
        public static global::SDL3Sharp.DisplayMode GetFullscreenDisplayModes(uint displayID, ref int count)
        {
            fixed (int* __count1 = &count)
            {
                var __arg1 = __count1;
                var ___ret = __Internal.GetFullscreenDisplayModes(displayID, __arg1);
                __IntPtr _____ret = ___ret == __IntPtr.Zero ? __IntPtr.Zero : new __IntPtr(*(void**) ___ret);
                var __result0 = global::SDL3Sharp.DisplayMode.__GetOrCreateInstance(_____ret, false);
                return __result0;
            }
        }

        /// <summary>Get the closest match to the requested display mode.</summary>
        /// <param name="displayID">the instance ID of the display to query</param>
        /// <param name="w">the width in pixels of the desired display mode</param>
        /// <param name="h">the height in pixels of the desired display mode</param>
        /// <param name="refresh_rate">
        /// <para>the refresh rate of the desired display mode, or 0.0f</para>
        /// <para>for the desktop refresh rate</para>
        /// </param>
        /// <param name="include_high_density_modes">
        /// <para>Boolean to include high density modes in</para>
        /// <para>the search</para>
        /// </param>
        /// <remarks>
        /// <para>The available display modes are scanned and `closest` is filled in with the</para>
        /// <para>closest mode matching the requested mode and returned. The mode format and</para>
        /// <para>refresh rate default to the desktop mode if they are set to 0. The modes</para>
        /// <para>are scanned with size being first priority, format being second priority,</para>
        /// <para>and finally checking the refresh rate. If all the available modes are too</para>
        /// <para>small, then NULL is returned.</para>
        /// <para>a pointer to the closest display mode equal to or larger than the</para>
        /// <para>desired mode, or NULL on error; call SDL_GetError() for more</para>
        /// <para>information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetDisplays</para>
        /// <para>SDL_GetFullscreenDisplayModes</para>
        /// </remarks>
        public static global::SDL3Sharp.DisplayMode GetClosestFullscreenDisplayMode(uint displayID, int w, int h, float refresh_rate, bool include_high_density_modes)
        {
            var ___ret = __Internal.GetClosestFullscreenDisplayMode(displayID, w, h, refresh_rate, include_high_density_modes);
            var __result0 = global::SDL3Sharp.DisplayMode.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get information about the desktop's display mode.</summary>
        /// <param name="displayID">the instance ID of the display to query</param>
        /// <remarks>
        /// <para>There's a difference between this function and SDL_GetCurrentDisplayMode()</para>
        /// <para>when SDL runs fullscreen and has changed the resolution. In that case this</para>
        /// <para>function will return the previous native display mode, and not the current</para>
        /// <para>display mode.</para>
        /// <para>a pointer to the desktop display mode or NULL on error; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetCurrentDisplayMode</para>
        /// <para>SDL_GetDisplays</para>
        /// </remarks>
        public static global::SDL3Sharp.DisplayMode GetDesktopDisplayMode(uint displayID)
        {
            var ___ret = __Internal.GetDesktopDisplayMode(displayID);
            var __result0 = global::SDL3Sharp.DisplayMode.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get information about the current display mode.</summary>
        /// <param name="displayID">the instance ID of the display to query</param>
        /// <remarks>
        /// <para>There's a difference between this function and SDL_GetDesktopDisplayMode()</para>
        /// <para>when SDL runs fullscreen and has changed the resolution. In that case this</para>
        /// <para>function will return the current display mode, and not the previous native</para>
        /// <para>display mode.</para>
        /// <para>a pointer to the desktop display mode or NULL on error; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetDesktopDisplayMode</para>
        /// <para>SDL_GetDisplays</para>
        /// </remarks>
        public static global::SDL3Sharp.DisplayMode GetCurrentDisplayMode(uint displayID)
        {
            var ___ret = __Internal.GetCurrentDisplayMode(displayID);
            var __result0 = global::SDL3Sharp.DisplayMode.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the display containing a point.</summary>
        /// <param name="point">the point to query</param>
        /// <remarks>
        /// <para>the instance ID of the display containing the point or 0 on</para>
        /// <para>failure; call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetDisplayBounds</para>
        /// <para>SDL_GetDisplays</para>
        /// </remarks>
        public static uint GetDisplayForPoint(global::SDL3Sharp.Point point)
        {
            var ____arg0 = point.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            var ___ret = __Internal.GetDisplayForPoint(__arg0);
            return ___ret;
        }

        /// <summary>Get the display primarily containing a rect.</summary>
        /// <param name="rect">the rect to query</param>
        /// <remarks>
        /// <para>the instance ID of the display entirely containing the rect or</para>
        /// <para>closest to the center of the rect on success or 0 on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetDisplayBounds</para>
        /// <para>SDL_GetDisplays</para>
        /// </remarks>
        public static uint GetDisplayForRect(global::SDL3Sharp.Rect rect)
        {
            var __arg0 = rect is null ? __IntPtr.Zero : rect.__Instance;
            var ___ret = __Internal.GetDisplayForRect(__arg0);
            return ___ret;
        }

        /// <summary>Get the display associated with a window.</summary>
        /// <param name="window">the window to query</param>
        /// <remarks>
        /// <para>the instance ID of the display containing the center of the window</para>
        /// <para>on success or 0 on failure; call SDL_GetError() for more</para>
        /// <para>information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetDisplayBounds</para>
        /// <para>SDL_GetDisplays</para>
        /// </remarks>
        public static uint GetDisplayForWindow(global::SDL3Sharp.Window window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.GetDisplayForWindow(__arg0);
            return ___ret;
        }

        /// <summary>Get the pixel density of a window.</summary>
        /// <param name="window">the window to query</param>
        /// <remarks>
        /// <para>This is a ratio of pixel size to window size. For example, if the window is</para>
        /// <para>1920x1080 and it has a high density back buffer of 3840x2160 pixels, it</para>
        /// <para>would have a pixel density of 2.0.</para>
        /// <para>the pixel density or 0.0f on failure; call SDL_GetError() for more</para>
        /// <para>information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetWindowDisplayScale</para>
        /// </remarks>
        public static float GetWindowPixelDensity(global::SDL3Sharp.Window window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.GetWindowPixelDensity(__arg0);
            return ___ret;
        }

        /// <summary>Get the content display scale relative to a window's pixel size.</summary>
        /// <param name="window">the window to query</param>
        /// <remarks>
        /// <para>This is a combination of the window pixel density and the display content</para>
        /// <para>scale, and is the expected scale for displaying content in this window. For</para>
        /// <para>example, if a 3840x2160 window had a display scale of 2.0, the user expects</para>
        /// <para>the content to take twice as many pixels and be the same physical size as</para>
        /// <para>if it were being displayed in a 1920x1080 window with a display scale of</para>
        /// <para>1.0.</para>
        /// <para>Conceptually this value corresponds to the scale display setting, and is</para>
        /// <para>updated when that setting is changed, or the window moves to a display with</para>
        /// <para>a different scale setting.</para>
        /// <para>the display scale, or 0.0f on failure; call SDL_GetError() for</para>
        /// <para>more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static float GetWindowDisplayScale(global::SDL3Sharp.Window window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.GetWindowDisplayScale(__arg0);
            return ___ret;
        }

        /// <summary>Set the display mode to use when a window is visible and fullscreen.</summary>
        /// <param name="window">the window to affect</param>
        /// <param name="mode">
        /// <para>a pointer to the display mode to use, which can be NULL for</para>
        /// <para>borderless fullscreen desktop mode, or one of the fullscreen</para>
        /// <para>modes returned by SDL_GetFullscreenDisplayModes() to set an</para>
        /// <para>exclusive fullscreen mode.</para>
        /// </param>
        /// <remarks>
        /// <para>This only affects the display mode used when the window is fullscreen. To</para>
        /// <para>change the window size when the window is not fullscreen, use</para>
        /// <para>SDL_SetWindowSize().</para>
        /// <para>If the window is currently in the fullscreen state, this request is</para>
        /// <para>asynchronous on some windowing systems and the new mode dimensions may not</para>
        /// <para>be applied immediately upon the return of this function. If an immediate</para>
        /// <para>change is required, call SDL_SyncWindow() to block until the changes have</para>
        /// <para>taken effect.</para>
        /// <para>When the new mode takes effect, an SDL_EVENT_WINDOW_RESIZED and/or an</para>
        /// <para>SDL_EVENT_WINDOOW_PIXEL_SIZE_CHANGED event will be emitted with the new</para>
        /// <para>mode dimensions.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetWindowFullscreenMode</para>
        /// <para>SDL_SetWindowFullscreen</para>
        /// <para>SDL_SyncWindow</para>
        /// </remarks>
        public static int SetWindowFullscreenMode(global::SDL3Sharp.Window window, global::SDL3Sharp.DisplayMode mode)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __arg1 = mode is null ? __IntPtr.Zero : mode.__Instance;
            var ___ret = __Internal.SetWindowFullscreenMode(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Query the display mode to use when a window is visible at fullscreen.</summary>
        /// <param name="window">the window to query</param>
        /// <remarks>
        /// <para>a pointer to the exclusive fullscreen mode to use or NULL for</para>
        /// <para>borderless fullscreen desktop mode</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_SetWindowFullscreenMode</para>
        /// <para>SDL_SetWindowFullscreen</para>
        /// </remarks>
        public static global::SDL3Sharp.DisplayMode GetWindowFullscreenMode(global::SDL3Sharp.Window window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.GetWindowFullscreenMode(__arg0);
            var __result0 = global::SDL3Sharp.DisplayMode.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the raw ICC profile data for the screen the window is currently on.</summary>
        /// <param name="window">the window to query</param>
        /// <param name="size">the size of the ICC profile</param>
        /// <remarks>
        /// <para>Data returned should be freed with SDL_free.</para>
        /// <para>the raw ICC profile data on success or NULL on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static __IntPtr GetWindowICCProfile(global::SDL3Sharp.Window window, ref ulong size)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            fixed (ulong* __size1 = &size)
            {
                var __arg1 = __size1;
                var ___ret = __Internal.GetWindowICCProfile(__arg0, __arg1);
                return ___ret;
            }
        }

        /// <summary>Get the pixel format associated with the window.</summary>
        /// <param name="window">the window to query</param>
        /// <remarks>
        /// <para>the pixel format of the window on success or</para>
        /// <para>SDL_PIXELFORMAT_UNKNOWN on failure; call SDL_GetError() for more</para>
        /// <para>information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static uint GetWindowPixelFormat(global::SDL3Sharp.Window window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.GetWindowPixelFormat(__arg0);
            return ___ret;
        }

        /// <summary>Create a window with the specified dimensions and flags.</summary>
        /// <param name="title">the title of the window, in UTF-8 encoding</param>
        /// <param name="w">the width of the window</param>
        /// <param name="h">the height of the window</param>
        /// <param name="flags">0, or one or more SDL_WindowFlags OR'd together</param>
        /// <remarks>
        /// <para>`flags` may be any of the following OR'd together:</para>
        /// <para>- `SDL_WINDOW_FULLSCREEN`: fullscreen window at desktop resolution</para>
        /// <para>- `SDL_WINDOW_OPENGL`: window usable with an OpenGL context</para>
        /// <para>- `SDL_WINDOW_VULKAN`: window usable with a Vulkan instance</para>
        /// <para>- `SDL_WINDOW_METAL`: window usable with a Metal instance</para>
        /// <para>- `SDL_WINDOW_HIDDEN`: window is not visible</para>
        /// <para>- `SDL_WINDOW_BORDERLESS`: no window decoration</para>
        /// <para>- `SDL_WINDOW_RESIZABLE`: window can be resized</para>
        /// <para>- `SDL_WINDOW_MINIMIZED`: window is minimized</para>
        /// <para>- `SDL_WINDOW_MAXIMIZED`: window is maximized</para>
        /// <para>- `SDL_WINDOW_MOUSE_GRABBED`: window has grabbed mouse focus</para>
        /// <para>The SDL_Window is implicitly shown if SDL_WINDOW_HIDDEN is not set.</para>
        /// <para>On Apple's macOS, you **must** set the NSHighResolutionCapable Info.plist</para>
        /// <para>property to YES, otherwise you will not receive a High-DPI OpenGL canvas.</para>
        /// <para>The window pixel size may differ from its window coordinate size if the</para>
        /// <para>window is on a high pixel density display. Use SDL_GetWindowSize() to query</para>
        /// <para>the client area's size in window coordinates, and</para>
        /// <para>SDL_GetWindowSizeInPixels() or SDL_GetRenderOutputSize() to query the</para>
        /// <para>drawable size in pixels. Note that the drawable size can vary after the</para>
        /// <para>window is created and should be queried again if you get an</para>
        /// <para>SDL_EVENT_WINDOW_PIXEL_SIZE_CHANGED event.</para>
        /// <para>If the window is created with any of the SDL_WINDOW_OPENGL or</para>
        /// <para>SDL_WINDOW_VULKAN flags, then the corresponding LoadLibrary function</para>
        /// <para>(SDL_GL_LoadLibrary or SDL_Vulkan_LoadLibrary) is called and the</para>
        /// <para>corresponding UnloadLibrary function is called by SDL_DestroyWindow().</para>
        /// <para>If SDL_WINDOW_VULKAN is specified and there isn't a working Vulkan driver,</para>
        /// <para>SDL_CreateWindow() will fail because SDL_Vulkan_LoadLibrary() will fail.</para>
        /// <para>If SDL_WINDOW_METAL is specified on an OS that does not support Metal,</para>
        /// <para>SDL_CreateWindow() will fail.</para>
        /// <para>On non-Apple devices, SDL requires you to either not link to the Vulkan</para>
        /// <para>loader or link to a dynamic library version. This limitation may be removed</para>
        /// <para>in a future version of SDL.</para>
        /// <para>the window that was created or NULL on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreatePopupWindow</para>
        /// <para>SDL_CreateWindowWithProperties</para>
        /// <para>SDL_DestroyWindow</para>
        /// </remarks>
        public static global::SDL3Sharp.Window CreateWindow(string title, int w, int h, global::SDL3Sharp.WindowFlags flags)
        {
            var ___ret = __Internal.CreateWindow(title, w, h, flags);
            var __result0 = global::SDL3Sharp.Window.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Create a child popup window of the specified parent window.</summary>
        /// <param name="parent">the parent of the window, must not be NULL</param>
        /// <param name="offset_x">
        /// <para>the x position of the popup window relative to the origin</para>
        /// <para>of the parent</para>
        /// </param>
        /// <param name="offset_y">
        /// <para>the y position of the popup window relative to the origin</para>
        /// <para>of the parent window</para>
        /// </param>
        /// <param name="w">the width of the window</param>
        /// <param name="h">the height of the window</param>
        /// <param name="flags">
        /// <para>SDL_WINDOW_TOOLTIP or SDL_WINDOW_POPUP MENU, and zero or more</para>
        /// <para>additional SDL_WindowFlags OR'd together.</para>
        /// </param>
        /// <remarks>
        /// <para>'flags' **must** contain exactly one of the following: -</para>
        /// <para>'SDL_WINDOW_TOOLTIP': The popup window is a tooltip and will not pass any</para>
        /// <para>input events. - 'SDL_WINDOW_POPUP_MENU': The popup window is a popup menu.</para>
        /// <para>The topmost popup menu will implicitly gain the keyboard focus.</para>
        /// <para>The following flags are not relevant to popup window creation and will be</para>
        /// <para>ignored:</para>
        /// <para>- 'SDL_WINDOW_MINIMIZED'</para>
        /// <para>- 'SDL_WINDOW_MAXIMIZED'</para>
        /// <para>- 'SDL_WINDOW_FULLSCREEN'</para>
        /// <para>- 'SDL_WINDOW_BORDERLESS'</para>
        /// <para>The parent parameter **must** be non-null and a valid window. The parent of</para>
        /// <para>a popup window can be either a regular, toplevel window, or another popup</para>
        /// <para>window.</para>
        /// <para>Popup windows cannot be minimized, maximized, made fullscreen, raised,</para>
        /// <para>flash, be made a modal window, be the parent of a modal window, or grab the</para>
        /// <para>mouse and/or keyboard. Attempts to do so will fail.</para>
        /// <para>Popup windows implicitly do not have a border/decorations and do not appear</para>
        /// <para>on the taskbar/dock or in lists of windows such as alt-tab menus.</para>
        /// <para>If a parent window is hidden, any child popup windows will be recursively</para>
        /// <para>hidden as well. Child popup windows not explicitly hidden will be restored</para>
        /// <para>when the parent is shown.</para>
        /// <para>If the parent window is destroyed, any child popup windows will be</para>
        /// <para>recursively destroyed as well.</para>
        /// <para>the window that was created or NULL on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateWindow</para>
        /// <para>SDL_CreateWindowWithProperties</para>
        /// <para>SDL_DestroyWindow</para>
        /// <para>SDL_GetWindowParent</para>
        /// </remarks>
        public static global::SDL3Sharp.Window CreatePopupWindow(global::SDL3Sharp.Window parent, int offset_x, int offset_y, int w, int h, global::SDL3Sharp.WindowFlags flags)
        {
            var __arg0 = parent is null ? __IntPtr.Zero : parent.__Instance;
            var ___ret = __Internal.CreatePopupWindow(__arg0, offset_x, offset_y, w, h, flags);
            var __result0 = global::SDL3Sharp.Window.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Create a window with the specified properties.</summary>
        /// <param name="props">the properties to use</param>
        /// <remarks>
        /// <para>These are the supported properties:</para>
        /// <para>- `SDL_PROP_WINDOW_CREATE_ALWAYS_ON_TOP_BOOLEAN`: true if the window should</para>
        /// <para>be always on top</para>
        /// <para>- `SDL_PROP_WINDOW_CREATE_BORDERLESS_BOOLEAN`: true if the window has no</para>
        /// <para>window decoration</para>
        /// <para>- `SDL_PROP_WINDOW_CREATE_EXTERNAL_GRAPHICS_CONTEXT_BOOLEAN`: true if the</para>
        /// <para>window will be used with an externally managed graphics context.</para>
        /// <para>- `SDL_PROP_WINDOW_CREATE_FOCUSABLE_BOOLEAN`: true if the window should</para>
        /// <para>accept keyboard input (defaults true)</para>
        /// <para>- `SDL_PROP_WINDOW_CREATE_FULLSCREEN_BOOLEAN`: true if the window should</para>
        /// <para>start in fullscreen mode at desktop resolution</para>
        /// <para>- `SDL_PROP_WINDOW_CREATE_HEIGHT_NUMBER`: the height of the window</para>
        /// <para>- `SDL_PROP_WINDOW_CREATE_HIDDEN_BOOLEAN`: true if the window should start</para>
        /// <para>hidden</para>
        /// <para>- `SDL_PROP_WINDOW_CREATE_HIGH_PIXEL_DENSITY_BOOLEAN`: true if the window</para>
        /// <para>uses a high pixel density buffer if possible</para>
        /// <para>- `SDL_PROP_WINDOW_CREATE_MAXIMIZED_BOOLEAN`: true if the window should</para>
        /// <para>start maximized</para>
        /// <para>- `SDL_PROP_WINDOW_CREATE_MENU_BOOLEAN`: true if the window is a popup menu</para>
        /// <para>- `SDL_PROP_WINDOW_CREATE_METAL_BOOLEAN`: true if the window will be used</para>
        /// <para>with Metal rendering</para>
        /// <para>- `SDL_PROP_WINDOW_CREATE_MINIMIZED_BOOLEAN`: true if the window should</para>
        /// <para>start minimized</para>
        /// <para>- `SDL_PROP_WINDOW_CREATE_MOUSE_GRABBED_BOOLEAN`: true if the window starts</para>
        /// <para>with grabbed mouse focus</para>
        /// <para>- `SDL_PROP_WINDOW_CREATE_OPENGL_BOOLEAN`: true if the window will be used</para>
        /// <para>with OpenGL rendering</para>
        /// <para>- `SDL_PROP_WINDOW_CREATE_PARENT_POINTER`: an SDL_Window that will be the</para>
        /// <para>parent of this window, required for windows with the &quot;toolip&quot; and &quot;menu&quot;</para>
        /// <para>properties</para>
        /// <para>- `SDL_PROP_WINDOW_CREATE_RESIZABLE_BOOLEAN`: true if the window should be</para>
        /// <para>resizable</para>
        /// <para>- `SDL_PROP_WINDOW_CREATE_TITLE_STRING`: the title of the window, in UTF-8</para>
        /// <para>encoding</para>
        /// <para>- `SDL_PROP_WINDOW_CREATE_TRANSPARENT_BOOLEAN`: true if the window show</para>
        /// <para>transparent in the areas with alpha of 0</para>
        /// <para>- `SDL_PROP_WINDOW_CREATE_TOOLTIP_BOOLEAN`: true if the window is a tooltip</para>
        /// <para>- `SDL_PROP_WINDOW_CREATE_UTILITY_BOOLEAN`: true if the window is a utility</para>
        /// <para>window, not showing in the task bar and window list</para>
        /// <para>- `SDL_PROP_WINDOW_CREATE_VULKAN_BOOLEAN`: true if the window will be used</para>
        /// <para>with Vulkan rendering</para>
        /// <para>- `SDL_PROP_WINDOW_CREATE_WIDTH_NUMBER`: the width of the window</para>
        /// <para>- `SDL_PROP_WINDOW_CREATE_X_NUMBER`: the x position of the window, or</para>
        /// <para>`SDL_WINDOWPOS_CENTERED`, defaults to `SDL_WINDOWPOS_UNDEFINED`. This is</para>
        /// <para>relative to the parent for windows with the &quot;parent&quot; property set.</para>
        /// <para>- `SDL_PROP_WINDOW_CREATE_Y_NUMBER`: the y position of the window, or</para>
        /// <para>`SDL_WINDOWPOS_CENTERED`, defaults to `SDL_WINDOWPOS_UNDEFINED`. This is</para>
        /// <para>relative to the parent for windows with the &quot;parent&quot; property set.</para>
        /// <para>These are additional supported properties on macOS:</para>
        /// <para>- `SDL_PROP_WINDOW_CREATE_COCOA_WINDOW_POINTER`: the</para>
        /// <para>`(__unsafe_unretained)` NSWindow associated with the window, if you want</para>
        /// <para>to wrap an existing window.</para>
        /// <para>- `SDL_PROP_WINDOW_CREATE_COCOA_VIEW_POINTER`: the `(__unsafe_unretained)`</para>
        /// <para>NSView associated with the window, defaults to `[window contentView]`</para>
        /// <para>These are additional supported properties on Wayland:</para>
        /// <para>- `SDL_PROP_WINDOW_CREATE_WAYLAND_SCALE_TO_DISPLAY_BOOLEAN` - true if the</para>
        /// <para>window should use forced scaling designed to produce 1:1 pixel mapping if</para>
        /// <para>not flagged as being DPI-aware. This is intended to allow legacy</para>
        /// <para>applications to be displayed without desktop scaling being applied, and</para>
        /// <para>has issues with certain display configurations, as this forces the window</para>
        /// <para>to behave in a way that Wayland desktops were not designed to</para>
        /// <para>accommodate. Potential issues include, but are not limited to: rounding</para>
        /// <para>errors can result when odd window sizes/scales are used, the window may</para>
        /// <para>be unusably small, the window may jump in visible size at times, the</para>
        /// <para>window may appear to be larger than the desktop space, and possible loss</para>
        /// <para>of cursor precision can occur. New applications should be designed with</para>
        /// <para>proper DPI awareness and handling instead of enabling this.</para>
        /// <para>- `SDL_PROP_WINDOW_CREATE_WAYLAND_SURFACE_ROLE_CUSTOM_BOOLEAN` - true if</para>
        /// <para>the application wants to use the Wayland surface for a custom role and</para>
        /// <para>does not want it attached to an XDG toplevel window. See</para>
        /// <para>docs/README-wayland.md for more information on using custom surfaces.</para>
        /// <para>- `SDL_PROP_WINDOW_CREATE_WAYLAND_CREATE_EGL_WINDOW_BOOLEAN - true if the</para>
        /// <para>application wants an associated `wl_egl_window` object to be created,</para>
        /// <para>even if the window does not have the OpenGL property or flag set.</para>
        /// <para>- `SDL_PROP_WINDOW_CREATE_WAYLAND_WL_SURFACE_POINTER` - the wl_surface</para>
        /// <para>associated with the window, if you want to wrap an existing window. See</para>
        /// <para>docs/README-wayland.md for more information.</para>
        /// <para>These are additional supported properties on Windows:</para>
        /// <para>- `SDL_PROP_WINDOW_CREATE_WIN32_HWND_POINTER`: the HWND associated with the</para>
        /// <para>window, if you want to wrap an existing window.</para>
        /// <para>- `SDL_PROP_WINDOW_CREATE_WIN32_PIXEL_FORMAT_HWND_POINTER`: optional,</para>
        /// <para>another window to share pixel format with, useful for OpenGL windows</para>
        /// <para>These are additional supported properties with X11:</para>
        /// <para>- `SDL_PROP_WINDOW_CREATE_X11_WINDOW_NUMBER`: the X11 Window associated</para>
        /// <para>with the window, if you want to wrap an existing window.</para>
        /// <para>The window is implicitly shown if the &quot;hidden&quot; property is not set.</para>
        /// <para>Windows with the &quot;tooltip&quot; and &quot;menu&quot; properties are popup windows and have</para>
        /// <para>the behaviors and guidelines outlined in `SDL_CreatePopupWindow()`.</para>
        /// <para>the window that was created or NULL on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateWindow</para>
        /// <para>SDL_DestroyWindow</para>
        /// </remarks>
        public static global::SDL3Sharp.Window CreateWindowWithProperties(uint props)
        {
            var ___ret = __Internal.CreateWindowWithProperties(props);
            var __result0 = global::SDL3Sharp.Window.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the numeric ID of a window.</summary>
        /// <param name="window">the window to query</param>
        /// <remarks>
        /// <para>The numeric ID is what SDL_WindowEvent references, and is necessary to map</para>
        /// <para>these events to specific SDL_Window objects.</para>
        /// <para>the ID of the window on success or 0 on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetWindowFromID</para>
        /// </remarks>
        public static uint GetWindowID(global::SDL3Sharp.Window window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.GetWindowID(__arg0);
            return ___ret;
        }

        /// <summary>Get a window from a stored ID.</summary>
        /// <param name="id">the ID of the window</param>
        /// <remarks>
        /// <para>The numeric ID is what SDL_WindowEvent references, and is necessary to map</para>
        /// <para>these events to specific SDL_Window objects.</para>
        /// <para>the window associated with `id` or NULL if it doesn't exist; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetWindowID</para>
        /// </remarks>
        public static global::SDL3Sharp.Window GetWindowFromID(uint id)
        {
            var ___ret = __Internal.GetWindowFromID(id);
            var __result0 = global::SDL3Sharp.Window.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get parent of a window.</summary>
        /// <param name="window">the window to query</param>
        /// <remarks>
        /// <para>the parent of the window on success or NULL if the window has no</para>
        /// <para>parent.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreatePopupWindow</para>
        /// </remarks>
        public static global::SDL3Sharp.Window GetWindowParent(global::SDL3Sharp.Window window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.GetWindowParent(__arg0);
            var __result0 = global::SDL3Sharp.Window.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the properties associated with a window.</summary>
        /// <param name="window">the window to query</param>
        /// <remarks>
        /// <para>The following read-only properties are provided by SDL:</para>
        /// <para>- `SDL_PROP_WINDOW_SHAPE_POINTER`: the surface associated with a shaped</para>
        /// <para>window</para>
        /// <para>On Android:</para>
        /// <para>- `SDL_PROP_WINDOW_ANDROID_WINDOW_POINTER`: the ANativeWindow associated</para>
        /// <para>with the window</para>
        /// <para>- `SDL_PROP_WINDOW_ANDROID_SURFACE_POINTER`: the EGLSurface associated with</para>
        /// <para>the window</para>
        /// <para>On iOS:</para>
        /// <para>- `SDL_PROP_WINDOW_UIKIT_WINDOW_POINTER`: the `(__unsafe_unretained)`</para>
        /// <para>UIWindow associated with the window</para>
        /// <para>- `SDL_PROP_WINDOW_UIKIT_METAL_VIEW_TAG_NUMBER`: the NSInteger tag</para>
        /// <para>assocated with metal views on the window</para>
        /// <para>On KMS/DRM:</para>
        /// <para>- `SDL_PROP_WINDOW_KMSDRM_DEVICE_INDEX_NUMBER`: the device index associated</para>
        /// <para>with the window (e.g. the X in /dev/dri/cardX)</para>
        /// <para>- `SDL_PROP_WINDOW_KMSDRM_DRM_FD_NUMBER`: the DRM FD associated with the</para>
        /// <para>window</para>
        /// <para>- `SDL_PROP_WINDOW_KMSDRM_GBM_DEVICE_POINTER`: the GBM device associated</para>
        /// <para>with the window</para>
        /// <para>On macOS:</para>
        /// <para>- `SDL_PROP_WINDOW_COCOA_WINDOW_POINTER`: the `(__unsafe_unretained)`</para>
        /// <para>NSWindow associated with the window</para>
        /// <para>- `SDL_PROP_WINDOW_COCOA_METAL_VIEW_TAG_NUMBER`: the NSInteger tag</para>
        /// <para>assocated with metal views on the window</para>
        /// <para>On Vivante:</para>
        /// <para>- `SDL_PROP_WINDOW_VIVANTE_DISPLAY_POINTER`: the EGLNativeDisplayType</para>
        /// <para>associated with the window</para>
        /// <para>- `SDL_PROP_WINDOW_VIVANTE_WINDOW_POINTER`: the EGLNativeWindowType</para>
        /// <para>associated with the window</para>
        /// <para>- `SDL_PROP_WINDOW_VIVANTE_SURFACE_POINTER`: the EGLSurface associated with</para>
        /// <para>the window</para>
        /// <para>On UWP:</para>
        /// <para>- `SDL_PROP_WINDOW_WINRT_WINDOW_POINTER`: the IInspectable CoreWindow</para>
        /// <para>associated with the window</para>
        /// <para>On Windows:</para>
        /// <para>- `SDL_PROP_WINDOW_WIN32_HWND_POINTER`: the HWND associated with the window</para>
        /// <para>- `SDL_PROP_WINDOW_WIN32_HDC_POINTER`: the HDC associated with the window</para>
        /// <para>- `SDL_PROP_WINDOW_WIN32_INSTANCE_POINTER`: the HINSTANCE associated with</para>
        /// <para>the window</para>
        /// <para>On Wayland:</para>
        /// <para>Note: The `xdg_*` window objects do not internally persist across window</para>
        /// <para>show/hide calls. They will be null if the window is hidden and must be</para>
        /// <para>queried each time it is shown.</para>
        /// <para>- `SDL_PROP_WINDOW_WAYLAND_DISPLAY_POINTER`: the wl_display associated with</para>
        /// <para>the window</para>
        /// <para>- `SDL_PROP_WINDOW_WAYLAND_SURFACE_POINTER`: the wl_surface associated with</para>
        /// <para>the window</para>
        /// <para>- `SDL_PROP_WINDOW_WAYLAND_EGL_WINDOW_POINTER`: the wl_egl_window</para>
        /// <para>associated with the window</para>
        /// <para>- `SDL_PROP_WINDOW_WAYLAND_XDG_SURFACE_POINTER`: the xdg_surface associated</para>
        /// <para>with the window</para>
        /// <para>- `SDL_PROP_WINDOW_WAYLAND_XDG_TOPLEVEL_POINTER`: the xdg_toplevel role</para>
        /// <para>associated with the window</para>
        /// <para>- `SDL_PROP_WINDOW_WAYLAND_XDG_POPUP_POINTER`: the xdg_popup role</para>
        /// <para>associated with the window</para>
        /// <para>- `SDL_PROP_WINDOW_WAYLAND_XDG_POSITIONER_POINTER`: the xdg_positioner</para>
        /// <para>associated with the window, in popup mode</para>
        /// <para>On X11:</para>
        /// <para>- `SDL_PROP_WINDOW_X11_DISPLAY_POINTER`: the X11 Display associated with</para>
        /// <para>the window</para>
        /// <para>- `SDL_PROP_WINDOW_X11_SCREEN_NUMBER`: the screen number associated with</para>
        /// <para>the window</para>
        /// <para>- `SDL_PROP_WINDOW_X11_WINDOW_NUMBER`: the X11 Window associated with the</para>
        /// <para>window</para>
        /// <para>a valid property ID on success or 0 on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetProperty</para>
        /// <para>SDL_SetProperty</para>
        /// </remarks>
        public static uint GetWindowProperties(global::SDL3Sharp.Window window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.GetWindowProperties(__arg0);
            return ___ret;
        }

        /// <summary>Get the window flags.</summary>
        /// <param name="window">the window to query</param>
        /// <remarks>
        /// <para>a mask of the SDL_WindowFlags associated with `window`</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateWindow</para>
        /// <para>SDL_HideWindow</para>
        /// <para>SDL_MaximizeWindow</para>
        /// <para>SDL_MinimizeWindow</para>
        /// <para>SDL_SetWindowFullscreen</para>
        /// <para>SDL_SetWindowGrab</para>
        /// <para>SDL_ShowWindow</para>
        /// </remarks>
        public static uint GetWindowFlags(global::SDL3Sharp.Window window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.GetWindowFlags(__arg0);
            return ___ret;
        }

        /// <summary>Set the title of a window.</summary>
        /// <param name="window">the window to change</param>
        /// <param name="title">the desired window title in UTF-8 format</param>
        /// <remarks>
        /// <para>This string is expected to be in UTF-8 encoding.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetWindowTitle</para>
        /// </remarks>
        public static int SetWindowTitle(global::SDL3Sharp.Window window, string title)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.SetWindowTitle(__arg0, title);
            return ___ret;
        }

        /// <summary>Get the title of a window.</summary>
        /// <param name="window">the window to query</param>
        /// <remarks>
        /// <para>the title of the window in UTF-8 format or &quot;&quot; if there is no</para>
        /// <para>title.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_SetWindowTitle</para>
        /// </remarks>
        public static string GetWindowTitle(global::SDL3Sharp.Window window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.GetWindowTitle(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Set the icon for a window.</summary>
        /// <param name="window">the window to change</param>
        /// <param name="icon">an SDL_Surface structure containing the icon for the window</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int SetWindowIcon(global::SDL3Sharp.Window window, global::SDL3Sharp.Surface icon)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __arg1 = icon is null ? __IntPtr.Zero : icon.__Instance;
            var ___ret = __Internal.SetWindowIcon(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Request that the window's position be set.</summary>
        /// <param name="window">the window to reposition</param>
        /// <param name="x">
        /// <para>the x coordinate of the window, or `SDL_WINDOWPOS_CENTERED` or</para>
        /// <para>`SDL_WINDOWPOS_UNDEFINED`</para>
        /// </param>
        /// <param name="y">
        /// <para>the y coordinate of the window, or `SDL_WINDOWPOS_CENTERED` or</para>
        /// <para>`SDL_WINDOWPOS_UNDEFINED`</para>
        /// </param>
        /// <remarks>
        /// <para>If, at the time of this request, the window is in a fixed-size state such</para>
        /// <para>as maximized, this request may be deferred until the window returns to a</para>
        /// <para>resizable state.</para>
        /// <para>This can be used to reposition fullscreen-desktop windows onto a different</para>
        /// <para>display, however, exclusive fullscreen windows are locked to a specific</para>
        /// <para>display and can only be repositioned programmatically via</para>
        /// <para>SDL_SetWindowFullscreenMode().</para>
        /// <para>On some windowing systems this request is asynchronous and the new</para>
        /// <para>coordinates may not have have been applied immediately upon the return of</para>
        /// <para>this function. If an immediate change is required, call SDL_SyncWindow() to</para>
        /// <para>block until the changes have taken effect.</para>
        /// <para>When the window position changes, an SDL_EVENT_WINDOW_MOVED event will be</para>
        /// <para>emitted with the window's new coordinates. Note that the new coordinates</para>
        /// <para>may not match the exact coordinates requested, as some windowing systems</para>
        /// <para>can restrict the position of the window in certain scenarios (e.g.</para>
        /// <para>constraining the position so the window is always within desktop bounds).</para>
        /// <para>Additionally, as this is just a request, it can be denied by the windowing</para>
        /// <para>system.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetWindowPosition</para>
        /// <para>SDL_SyncWindow</para>
        /// </remarks>
        public static int SetWindowPosition(global::SDL3Sharp.Window window, int x, int y)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.SetWindowPosition(__arg0, x, y);
            return ___ret;
        }

        /// <summary>Get the position of a window.</summary>
        /// <param name="window">the window to query</param>
        /// <param name="x">a pointer filled in with the x position of the window, may be NULL</param>
        /// <param name="y">a pointer filled in with the y position of the window, may be NULL</param>
        /// <remarks>
        /// <para>This is the current position of the window as last reported by the</para>
        /// <para>windowing system.</para>
        /// <para>If you do not need the value for one of the positions a NULL may be passed</para>
        /// <para>in the `x` or `y` parameter.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_SetWindowPosition</para>
        /// </remarks>
        public static int GetWindowPosition(global::SDL3Sharp.Window window, out int x, out int y)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            fixed (int* __x1 = &x)
            {
                var __arg1 = __x1;
                fixed (int* __y2 = &y)
                {
                    var __arg2 = __y2;
                    var ___ret = __Internal.GetWindowPosition(__arg0, __arg1, __arg2);
                    return ___ret;
                }
            }
        }

        /// <summary>Request that the size of a window's client area be set.</summary>
        /// <param name="window">the window to change</param>
        /// <param name="w">the width of the window, must be &gt; 0</param>
        /// <param name="h">the height of the window, must be &gt; 0</param>
        /// <remarks>
        /// <para>NULL can safely be passed as the `w` or `h` parameter if the width or</para>
        /// <para>height value is not desired.</para>
        /// <para>If, at the time of this request, the window in a fixed-size state, such as</para>
        /// <para>maximized or fullscreen, the request will be deferred until the window</para>
        /// <para>exits this state and becomes resizable again.</para>
        /// <para>To change the fullscreen mode of a window, use</para>
        /// <para>SDL_SetWindowFullscreenMode()</para>
        /// <para>On some windowing systems, this request is asynchronous and the new window</para>
        /// <para>size may not have have been applied immediately upon the return of this</para>
        /// <para>function. If an immediate change is required, call SDL_SyncWindow() to</para>
        /// <para>block until the changes have taken effect.</para>
        /// <para>When the window size changes, an SDL_EVENT_WINDOW_RESIZED event will be</para>
        /// <para>emitted with the new window dimensions. Note that the new dimensions may</para>
        /// <para>not match the exact size requested, as some windowing systems can restrict</para>
        /// <para>the window size in certain scenarios (e.g. constraining the size of the</para>
        /// <para>content area to remain within the usable desktop bounds). Additionally, as</para>
        /// <para>this is just a request, it can be denied by the windowing system.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetWindowSize</para>
        /// <para>SDL_SetWindowFullscreenMode</para>
        /// <para>SDL_SyncWindow</para>
        /// </remarks>
        public static int SetWindowSize(global::SDL3Sharp.Window window, int w, int h)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.SetWindowSize(__arg0, w, h);
            return ___ret;
        }

        /// <summary>Get the size of a window's client area.</summary>
        /// <param name="window">the window to query the width and height from</param>
        /// <param name="w">a pointer filled in with the width of the window, may be NULL</param>
        /// <param name="h">a pointer filled in with the height of the window, may be NULL</param>
        /// <remarks>
        /// <para>NULL can safely be passed as the `w` or `h` parameter if the width or</para>
        /// <para>height value is not desired.</para>
        /// <para>The window pixel size may differ from its window coordinate size if the</para>
        /// <para>window is on a high pixel density display. Use SDL_GetWindowSizeInPixels()</para>
        /// <para>or SDL_GetRenderOutputSize() to get the real client area size in pixels.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetRenderOutputSize</para>
        /// <para>SDL_GetWindowSizeInPixels</para>
        /// <para>SDL_SetWindowSize</para>
        /// </remarks>
        public static int GetWindowSize(global::SDL3Sharp.Window window, out int w, out int h)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            fixed (int* __w1 = &w)
            {
                var __arg1 = __w1;
                fixed (int* __h2 = &h)
                {
                    var __arg2 = __h2;
                    var ___ret = __Internal.GetWindowSize(__arg0, __arg1, __arg2);
                    return ___ret;
                }
            }
        }

        /// <summary>Get the size of a window's borders (decorations) around the client area.</summary>
        /// <param name="window">
        /// <para>the window to query the size values of the border</para>
        /// <para>(decorations) from</para>
        /// </param>
        /// <param name="top">
        /// <para>pointer to variable for storing the size of the top border; NULL</para>
        /// <para>is permitted</para>
        /// </param>
        /// <param name="left">
        /// <para>pointer to variable for storing the size of the left border;</para>
        /// <para>NULL is permitted</para>
        /// </param>
        /// <param name="bottom">
        /// <para>pointer to variable for storing the size of the bottom</para>
        /// <para>border; NULL is permitted</para>
        /// </param>
        /// <param name="right">
        /// <para>pointer to variable for storing the size of the right border;</para>
        /// <para>NULL is permitted</para>
        /// </param>
        /// <remarks>
        /// <para>Note: If this function fails (returns -1), the size values will be</para>
        /// <para>initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the</para>
        /// <para>window in question was borderless.</para>
        /// <para>Note: This function may fail on systems where the window has not yet been</para>
        /// <para>decorated by the display server (for example, immediately after calling</para>
        /// <para>SDL_CreateWindow). It is recommended that you wait at least until the</para>
        /// <para>window has been presented and composited, so that the window system has a</para>
        /// <para>chance to decorate the window and provide the border dimensions to SDL.</para>
        /// <para>This function also returns -1 if getting the information is not supported.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetWindowSize</para>
        /// </remarks>
        public static int GetWindowBordersSize(global::SDL3Sharp.Window window, ref int top, ref int left, ref int bottom, ref int right)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            fixed (int* __top1 = &top)
            {
                var __arg1 = __top1;
                fixed (int* __left2 = &left)
                {
                    var __arg2 = __left2;
                    fixed (int* __bottom3 = &bottom)
                    {
                        var __arg3 = __bottom3;
                        fixed (int* __right4 = &right)
                        {
                            var __arg4 = __right4;
                            var ___ret = __Internal.GetWindowBordersSize(__arg0, __arg1, __arg2, __arg3, __arg4);
                            return ___ret;
                        }
                    }
                }
            }
        }

        /// <summary>Get the size of a window's client area, in pixels.</summary>
        /// <param name="window">the window from which the drawable size should be queried</param>
        /// <param name="w">a pointer to variable for storing the width in pixels, may be NULL</param>
        /// <param name="h">
        /// <para>a pointer to variable for storing the height in pixels, may be</para>
        /// <para>NULL</para>
        /// </param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateWindow</para>
        /// <para>SDL_GetWindowSize</para>
        /// </remarks>
        public static int GetWindowSizeInPixels(global::SDL3Sharp.Window window, ref int w, ref int h)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            fixed (int* __w1 = &w)
            {
                var __arg1 = __w1;
                fixed (int* __h2 = &h)
                {
                    var __arg2 = __h2;
                    var ___ret = __Internal.GetWindowSizeInPixels(__arg0, __arg1, __arg2);
                    return ___ret;
                }
            }
        }

        /// <summary>Set the minimum size of a window's client area.</summary>
        /// <param name="window">the window to change</param>
        /// <param name="min_w">the minimum width of the window, or 0 for no limit</param>
        /// <param name="min_h">the minimum height of the window, or 0 for no limit</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetWindowMinimumSize</para>
        /// <para>SDL_SetWindowMaximumSize</para>
        /// </remarks>
        public static int SetWindowMinimumSize(global::SDL3Sharp.Window window, int min_w, int min_h)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.SetWindowMinimumSize(__arg0, min_w, min_h);
            return ___ret;
        }

        /// <summary>Get the minimum size of a window's client area.</summary>
        /// <param name="window">the window to query</param>
        /// <param name="w">
        /// <para>a pointer filled in with the minimum width of the window, may be</para>
        /// <para>NULL</para>
        /// </param>
        /// <param name="h">
        /// <para>a pointer filled in with the minimum height of the window, may be</para>
        /// <para>NULL</para>
        /// </param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetWindowMaximumSize</para>
        /// <para>SDL_SetWindowMinimumSize</para>
        /// </remarks>
        public static int GetWindowMinimumSize(global::SDL3Sharp.Window window, ref int w, ref int h)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            fixed (int* __w1 = &w)
            {
                var __arg1 = __w1;
                fixed (int* __h2 = &h)
                {
                    var __arg2 = __h2;
                    var ___ret = __Internal.GetWindowMinimumSize(__arg0, __arg1, __arg2);
                    return ___ret;
                }
            }
        }

        /// <summary>Set the maximum size of a window's client area.</summary>
        /// <param name="window">the window to change</param>
        /// <param name="max_w">the maximum width of the window, or 0 for no limit</param>
        /// <param name="max_h">the maximum height of the window, or 0 for no limit</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetWindowMaximumSize</para>
        /// <para>SDL_SetWindowMinimumSize</para>
        /// </remarks>
        public static int SetWindowMaximumSize(global::SDL3Sharp.Window window, int max_w, int max_h)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.SetWindowMaximumSize(__arg0, max_w, max_h);
            return ___ret;
        }

        /// <summary>Get the maximum size of a window's client area.</summary>
        /// <param name="window">the window to query</param>
        /// <param name="w">
        /// <para>a pointer filled in with the maximum width of the window, may be</para>
        /// <para>NULL</para>
        /// </param>
        /// <param name="h">
        /// <para>a pointer filled in with the maximum height of the window, may be</para>
        /// <para>NULL</para>
        /// </param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetWindowMinimumSize</para>
        /// <para>SDL_SetWindowMaximumSize</para>
        /// </remarks>
        public static int GetWindowMaximumSize(global::SDL3Sharp.Window window, ref int w, ref int h)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            fixed (int* __w1 = &w)
            {
                var __arg1 = __w1;
                fixed (int* __h2 = &h)
                {
                    var __arg2 = __h2;
                    var ___ret = __Internal.GetWindowMaximumSize(__arg0, __arg1, __arg2);
                    return ___ret;
                }
            }
        }

        /// <summary>Set the border state of a window.</summary>
        /// <param name="window">the window of which to change the border state</param>
        /// <param name="bordered">SDL_FALSE to remove border, SDL_TRUE to add border</param>
        /// <remarks>
        /// <para>This will add or remove the window's `SDL_WINDOW_BORDERLESS` flag and add</para>
        /// <para>or remove the border from the actual window. This is a no-op if the</para>
        /// <para>window's border already matches the requested state.</para>
        /// <para>You can't change the border state of a fullscreen window.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetWindowFlags</para>
        /// </remarks>
        public static int SetWindowBordered(global::SDL3Sharp.Window window, bool bordered)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.SetWindowBordered(__arg0, bordered);
            return ___ret;
        }

        /// <summary>Set the user-resizable state of a window.</summary>
        /// <param name="window">the window of which to change the resizable state</param>
        /// <param name="resizable">SDL_TRUE to allow resizing, SDL_FALSE to disallow</param>
        /// <remarks>
        /// <para>This will add or remove the window's `SDL_WINDOW_RESIZABLE` flag and</para>
        /// <para>allow/disallow user resizing of the window. This is a no-op if the window's</para>
        /// <para>resizable state already matches the requested state.</para>
        /// <para>You can't change the resizable state of a fullscreen window.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetWindowFlags</para>
        /// </remarks>
        public static int SetWindowResizable(global::SDL3Sharp.Window window, bool resizable)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.SetWindowResizable(__arg0, resizable);
            return ___ret;
        }

        /// <summary>Set the window to always be above the others.</summary>
        /// <param name="window">The window of which to change the always on top state</param>
        /// <param name="on_top">
        /// <para>SDL_TRUE to set the window always on top, SDL_FALSE to</para>
        /// <para>disable</para>
        /// </param>
        /// <remarks>
        /// <para>This will add or remove the window's `SDL_WINDOW_ALWAYS_ON_TOP` flag. This</para>
        /// <para>will bring the window to the front and keep the window above the rest.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetWindowFlags</para>
        /// </remarks>
        public static int SetWindowAlwaysOnTop(global::SDL3Sharp.Window window, bool on_top)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.SetWindowAlwaysOnTop(__arg0, on_top);
            return ___ret;
        }

        /// <summary>Show a window.</summary>
        /// <param name="window">the window to show</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_HideWindow</para>
        /// <para>SDL_RaiseWindow</para>
        /// </remarks>
        public static int ShowWindow(global::SDL3Sharp.Window window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.ShowWindow(__arg0);
            return ___ret;
        }

        /// <summary>Hide a window.</summary>
        /// <param name="window">the window to hide</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_ShowWindow</para>
        /// </remarks>
        public static int HideWindow(global::SDL3Sharp.Window window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.HideWindow(__arg0);
            return ___ret;
        }

        /// <summary>Raise a window above other windows and set the input focus.</summary>
        /// <param name="window">the window to raise</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int RaiseWindow(global::SDL3Sharp.Window window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.RaiseWindow(__arg0);
            return ___ret;
        }

        /// <summary>Request that the window be made as large as possible.</summary>
        /// <param name="window">the window to maximize</param>
        /// <remarks>
        /// <para>Non-resizable windows can't be maximized. The window must have the</para>
        /// <para>SDL_WINDOW_RESIZABLE flag set, or this will have no effect.</para>
        /// <para>On some windowing systems this request is asynchronous and the new window</para>
        /// <para>state may not have have been applied immediately upon the return of this</para>
        /// <para>function. If an immediate change is required, call SDL_SyncWindow() to</para>
        /// <para>block until the changes have taken effect.</para>
        /// <para>When the window state changes, an SDL_EVENT_WINDOW_MAXIMIZED event will be</para>
        /// <para>emitted. Note that, as this is just a request, the windowing system can</para>
        /// <para>deny the state change.</para>
        /// <para>When maximizing a window, whether the constraints set via</para>
        /// <para>SDL_SetWindowMaximumSize() are honored depends on the policy of the window</para>
        /// <para>manager. Win32 and macOS enforce the constraints when maximizing, while X11</para>
        /// <para>and Wayland window managers may vary.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_MinimizeWindow</para>
        /// <para>SDL_RestoreWindow</para>
        /// <para>SDL_SyncWindow</para>
        /// </remarks>
        public static int MaximizeWindow(global::SDL3Sharp.Window window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.MaximizeWindow(__arg0);
            return ___ret;
        }

        /// <summary>Request that the window be minimized to an iconic representation.</summary>
        /// <param name="window">the window to minimize</param>
        /// <remarks>
        /// <para>On some windowing systems this request is asynchronous and the new window</para>
        /// <para>state may not have have been applied immediately upon the return of this</para>
        /// <para>function. If an immediate change is required, call SDL_SyncWindow() to</para>
        /// <para>block until the changes have taken effect.</para>
        /// <para>When the window state changes, an SDL_EVENT_WINDOW_MINIMIZED event will be</para>
        /// <para>emitted. Note that, as this is just a request, the windowing system can</para>
        /// <para>deny the state change.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_MaximizeWindow</para>
        /// <para>SDL_RestoreWindow</para>
        /// <para>SDL_SyncWindow</para>
        /// </remarks>
        public static int MinimizeWindow(global::SDL3Sharp.Window window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.MinimizeWindow(__arg0);
            return ___ret;
        }

        /// <summary>
        /// <para>Request that the size and position of a minimized or maximized window be</para>
        /// <para>restored.</para>
        /// </summary>
        /// <param name="window">the window to restore</param>
        /// <remarks>
        /// <para>On some windowing systems this request is asynchronous and the new window</para>
        /// <para>state may not have have been applied immediately upon the return of this</para>
        /// <para>function. If an immediate change is required, call SDL_SyncWindow() to</para>
        /// <para>block until the changes have taken effect.</para>
        /// <para>When the window state changes, an SDL_EVENT_WINDOW_RESTORED event will be</para>
        /// <para>emitted. Note that, as this is just a request, the windowing system can</para>
        /// <para>deny the state change.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_MaximizeWindow</para>
        /// <para>SDL_MinimizeWindow</para>
        /// <para>SDL_SyncWindow</para>
        /// </remarks>
        public static int RestoreWindow(global::SDL3Sharp.Window window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.RestoreWindow(__arg0);
            return ___ret;
        }

        /// <summary>Request that the window's fullscreen state be changed.</summary>
        /// <param name="window">the window to change</param>
        /// <param name="fullscreen">SDL_TRUE for fullscreen mode, SDL_FALSE for windowed mode</param>
        /// <remarks>
        /// <para>By default a window in fullscreen state uses borderless fullscreen desktop</para>
        /// <para>mode, but a specific exclusive display mode can be set using</para>
        /// <para>SDL_SetWindowFullscreenMode().</para>
        /// <para>On some windowing systems this request is asynchronous and the new</para>
        /// <para>fullscreen state may not have have been applied immediately upon the return</para>
        /// <para>of this function. If an immediate change is required, call SDL_SyncWindow()</para>
        /// <para>to block until the changes have taken effect.</para>
        /// <para>When the window state changes, an SDL_EVENT_WINDOW_ENTER_FULLSCREEN or</para>
        /// <para>SDL_EVENT_WINDOW_LEAVE_FULLSCREEN event will be emitted. Note that, as this</para>
        /// <para>is just a request, it can be denied by the windowing system.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetWindowFullscreenMode</para>
        /// <para>SDL_SetWindowFullscreenMode</para>
        /// <para>SDL_SyncWindow</para>
        /// </remarks>
        public static int SetWindowFullscreen(global::SDL3Sharp.Window window, bool fullscreen)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.SetWindowFullscreen(__arg0, fullscreen);
            return ___ret;
        }

        /// <summary>Block until any pending window state is finalized.</summary>
        /// <param name="window">
        /// <para>the window for which to wait for the pending state to be</para>
        /// <para>applied</para>
        /// </param>
        /// <remarks>
        /// <para>On asynchronous windowing systems, this acts as a synchronization barrier</para>
        /// <para>for pending window state. It will attempt to wait until any pending window</para>
        /// <para>state has been applied and is guaranteed to return within finite time. Note</para>
        /// <para>that for how long it can potentially block depends on the underlying window</para>
        /// <para>system, as window state changes may involve somewhat lengthy animations</para>
        /// <para>that must complete before the window is in its final requested state.</para>
        /// <para>On windowing systems where changes are immediate, this does nothing.</para>
        /// <para>0 on success, a positive value if the operation timed out before</para>
        /// <para>the window was in the requested state, or a negative error code on</para>
        /// <para>failure; call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_SetWindowSize</para>
        /// <para>SDL_SetWindowPosition</para>
        /// <para>SDL_SetWindowFullscreen</para>
        /// <para>SDL_MinimizeWindow</para>
        /// <para>SDL_MaximizeWindow</para>
        /// <para>SDL_RestoreWindow</para>
        /// </remarks>
        public static int SyncWindow(global::SDL3Sharp.Window window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.SyncWindow(__arg0);
            return ___ret;
        }

        /// <summary>Return whether the window has a surface associated with it.</summary>
        /// <param name="window">the window to query</param>
        /// <remarks>
        /// <para>SDL_TRUE if there is a surface associated with the window, or</para>
        /// <para>SDL_FALSE otherwise.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetWindowSurface</para>
        /// </remarks>
        public static bool WindowHasSurface(global::SDL3Sharp.Window window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.WindowHasSurface(__arg0);
            return ___ret;
        }

        /// <summary>Get the SDL surface associated with the window.</summary>
        /// <param name="window">the window to query</param>
        /// <remarks>
        /// <para>A new surface will be created with the optimal format for the window, if</para>
        /// <para>necessary. This surface will be freed when the window is destroyed. Do not</para>
        /// <para>free this surface.</para>
        /// <para>This surface will be invalidated if the window is resized. After resizing a</para>
        /// <para>window this function must be called again to return a valid surface.</para>
        /// <para>You may not combine this with 3D or the rendering API on this window.</para>
        /// <para>This function is affected by `SDL_HINT_FRAMEBUFFER_ACCELERATION`.</para>
        /// <para>the surface associated with the window, or NULL on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_DestroyWindowSurface</para>
        /// <para>SDL_WindowHasSurface</para>
        /// <para>SDL_UpdateWindowSurface</para>
        /// <para>SDL_UpdateWindowSurfaceRects</para>
        /// </remarks>
        public static global::SDL3Sharp.Surface GetWindowSurface(global::SDL3Sharp.Window window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.GetWindowSurface(__arg0);
            var __result0 = global::SDL3Sharp.Surface.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Copy the window surface to the screen.</summary>
        /// <param name="window">the window to update</param>
        /// <remarks>
        /// <para>This is the function you use to reflect any changes to the surface on the</para>
        /// <para>screen.</para>
        /// <para>This function is equivalent to the SDL 1.2 API SDL_Flip().</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetWindowSurface</para>
        /// <para>SDL_UpdateWindowSurfaceRects</para>
        /// </remarks>
        public static int UpdateWindowSurface(global::SDL3Sharp.Window window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.UpdateWindowSurface(__arg0);
            return ___ret;
        }

        /// <summary>Copy areas of the window surface to the screen.</summary>
        /// <param name="window">the window to update</param>
        /// <param name="rects">
        /// <para>an array of SDL_Rect structures representing areas of the</para>
        /// <para>surface to copy, in pixels</para>
        /// </param>
        /// <param name="numrects">the number of rectangles</param>
        /// <remarks>
        /// <para>This is the function you use to reflect changes to portions of the surface</para>
        /// <para>on the screen.</para>
        /// <para>This function is equivalent to the SDL 1.2 API SDL_UpdateRects().</para>
        /// <para>Note that this function will update _at least_ the rectangles specified,</para>
        /// <para>but this is only intended as an optimization; in practice, this might</para>
        /// <para>update more of the screen (or all of the screen!), depending on what method</para>
        /// <para>SDL uses to send pixels to the system.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetWindowSurface</para>
        /// <para>SDL_UpdateWindowSurface</para>
        /// </remarks>
        public static int UpdateWindowSurfaceRects(global::SDL3Sharp.Window window, global::SDL3Sharp.Rect rects, int numrects)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __arg1 = rects is null ? __IntPtr.Zero : rects.__Instance;
            var ___ret = __Internal.UpdateWindowSurfaceRects(__arg0, __arg1, numrects);
            return ___ret;
        }

        /// <summary>Destroy the surface associated with the window.</summary>
        /// <param name="window">the window to update</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetWindowSurface</para>
        /// <para>SDL_WindowHasSurface</para>
        /// </remarks>
        public static int DestroyWindowSurface(global::SDL3Sharp.Window window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.DestroyWindowSurface(__arg0);
            return ___ret;
        }

        /// <summary>Set a window's input grab mode.</summary>
        /// <param name="window">the window for which the input grab mode should be set</param>
        /// <param name="grabbed">SDL_TRUE to grab input or SDL_FALSE to release input</param>
        /// <remarks>
        /// <para>When input is grabbed, the mouse is confined to the window. This function</para>
        /// <para>will also grab the keyboard if `SDL_HINT_GRAB_KEYBOARD` is set. To grab the</para>
        /// <para>keyboard without also grabbing the mouse, use SDL_SetWindowKeyboardGrab().</para>
        /// <para>If the caller enables a grab while another window is currently grabbed, the</para>
        /// <para>other window loses its grab in favor of the caller's window.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetGrabbedWindow</para>
        /// <para>SDL_GetWindowGrab</para>
        /// </remarks>
        public static int SetWindowGrab(global::SDL3Sharp.Window window, bool grabbed)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.SetWindowGrab(__arg0, grabbed);
            return ___ret;
        }

        /// <summary>Set a window's keyboard grab mode.</summary>
        /// <param name="window">The window for which the keyboard grab mode should be set.</param>
        /// <param name="grabbed">This is SDL_TRUE to grab keyboard, and SDL_FALSE to release.</param>
        /// <remarks>
        /// <para>Keyboard grab enables capture of system keyboard shortcuts like Alt+Tab or</para>
        /// <para>the Meta/Super key. Note that not all system keyboard shortcuts can be</para>
        /// <para>captured by applications (one example is Ctrl+Alt+Del on Windows).</para>
        /// <para>This is primarily intended for specialized applications such as VNC clients</para>
        /// <para>or VM frontends. Normal games should not use keyboard grab.</para>
        /// <para>When keyboard grab is enabled, SDL will continue to handle Alt+Tab when the</para>
        /// <para>window is full-screen to ensure the user is not trapped in your</para>
        /// <para>application. If you have a custom keyboard shortcut to exit fullscreen</para>
        /// <para>mode, you may suppress this behavior with</para>
        /// <para>`SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED`.</para>
        /// <para>If the caller enables a grab while another window is currently grabbed, the</para>
        /// <para>other window loses its grab in favor of the caller's window.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetWindowKeyboardGrab</para>
        /// <para>SDL_SetWindowMouseGrab</para>
        /// <para>SDL_SetWindowGrab</para>
        /// </remarks>
        public static int SetWindowKeyboardGrab(global::SDL3Sharp.Window window, bool grabbed)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.SetWindowKeyboardGrab(__arg0, grabbed);
            return ___ret;
        }

        /// <summary>Set a window's mouse grab mode.</summary>
        /// <param name="window">The window for which the mouse grab mode should be set.</param>
        /// <param name="grabbed">This is SDL_TRUE to grab mouse, and SDL_FALSE to release.</param>
        /// <remarks>
        /// <para>Mouse grab confines the mouse cursor to the window.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetWindowMouseGrab</para>
        /// <para>SDL_SetWindowKeyboardGrab</para>
        /// <para>SDL_SetWindowGrab</para>
        /// </remarks>
        public static int SetWindowMouseGrab(global::SDL3Sharp.Window window, bool grabbed)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.SetWindowMouseGrab(__arg0, grabbed);
            return ___ret;
        }

        /// <summary>Get a window's input grab mode.</summary>
        /// <param name="window">the window to query</param>
        /// <remarks>
        /// <para>SDL_TRUE if input is grabbed, SDL_FALSE otherwise.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_SetWindowGrab</para>
        /// </remarks>
        public static bool GetWindowGrab(global::SDL3Sharp.Window window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.GetWindowGrab(__arg0);
            return ___ret;
        }

        /// <summary>Get a window's keyboard grab mode.</summary>
        /// <param name="window">the window to query</param>
        /// <remarks>
        /// <para>SDL_TRUE if keyboard is grabbed, and SDL_FALSE otherwise.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_SetWindowKeyboardGrab</para>
        /// <para>SDL_GetWindowGrab</para>
        /// </remarks>
        public static bool GetWindowKeyboardGrab(global::SDL3Sharp.Window window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.GetWindowKeyboardGrab(__arg0);
            return ___ret;
        }

        /// <summary>Get a window's mouse grab mode.</summary>
        /// <param name="window">the window to query</param>
        /// <remarks>
        /// <para>SDL_TRUE if mouse is grabbed, and SDL_FALSE otherwise.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_SetWindowKeyboardGrab</para>
        /// <para>SDL_GetWindowGrab</para>
        /// </remarks>
        public static bool GetWindowMouseGrab(global::SDL3Sharp.Window window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.GetWindowMouseGrab(__arg0);
            return ___ret;
        }

        /// <summary>Get the window that currently has an input grab enabled.</summary>
        /// <remarks>
        /// <para>the window if input is grabbed or NULL otherwise.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetWindowGrab</para>
        /// <para>SDL_SetWindowGrab</para>
        /// </remarks>
        public static global::SDL3Sharp.Window GetGrabbedWindow()
        {
            var ___ret = __Internal.GetGrabbedWindow();
            var __result0 = global::SDL3Sharp.Window.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Confines the cursor to the specified area of a window.</summary>
        /// <param name="window">The window that will be associated with the barrier.</param>
        /// <param name="rect">
        /// <para>A rectangle area in window-relative coordinates. If NULL the</para>
        /// <para>barrier for the specified window will be destroyed.</para>
        /// </param>
        /// <remarks>
        /// <para>Note that this does NOT grab the cursor, it only defines the area a cursor</para>
        /// <para>is restricted to when the window has mouse focus.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetWindowMouseRect</para>
        /// <para>SDL_SetWindowMouseGrab</para>
        /// </remarks>
        public static int SetWindowMouseRect(global::SDL3Sharp.Window window, global::SDL3Sharp.Rect rect)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __arg1 = rect is null ? __IntPtr.Zero : rect.__Instance;
            var ___ret = __Internal.SetWindowMouseRect(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Get the mouse confinement rectangle of a window.</summary>
        /// <param name="window">The window to query</param>
        /// <remarks>
        /// <para>A pointer to the mouse confinement rectangle of a window, or NULL</para>
        /// <para>if there isn't one.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_SetWindowMouseRect</para>
        /// </remarks>
        public static global::SDL3Sharp.Rect GetWindowMouseRect(global::SDL3Sharp.Window window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.GetWindowMouseRect(__arg0);
            var __result0 = global::SDL3Sharp.Rect.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Set the opacity for a window.</summary>
        /// <param name="window">the window which will be made transparent or opaque</param>
        /// <param name="opacity">the opacity value (0.0f - transparent, 1.0f - opaque)</param>
        /// <remarks>
        /// <para>The parameter `opacity` will be clamped internally between 0.0f</para>
        /// <para>(transparent) and 1.0f (opaque).</para>
        /// <para>This function also returns -1 if setting the opacity isn't supported.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetWindowOpacity</para>
        /// </remarks>
        public static int SetWindowOpacity(global::SDL3Sharp.Window window, float opacity)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.SetWindowOpacity(__arg0, opacity);
            return ___ret;
        }

        /// <summary>Get the opacity of a window.</summary>
        /// <param name="window">the window to get the current opacity value from</param>
        /// <param name="out_opacity">the float filled in (0.0f - transparent, 1.0f - opaque)</param>
        /// <remarks>
        /// <para>If transparency isn't supported on this platform, opacity will be reported</para>
        /// <para>as 1.0f without error.</para>
        /// <para>The parameter `opacity` is ignored if it is NULL.</para>
        /// <para>This function also returns -1 if an invalid window was provided.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_SetWindowOpacity</para>
        /// </remarks>
        public static int GetWindowOpacity(global::SDL3Sharp.Window window, out float out_opacity)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            fixed (float* __out_opacity1 = &out_opacity)
            {
                var __arg1 = __out_opacity1;
                var ___ret = __Internal.GetWindowOpacity(__arg0, __arg1);
                return ___ret;
            }
        }

        /// <summary>Set the window as a modal for another window.</summary>
        /// <param name="modal_window">the window that should be set modal</param>
        /// <param name="parent_window">the parent window for the modal window</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int SetWindowModalFor(global::SDL3Sharp.Window modal_window, global::SDL3Sharp.Window parent_window)
        {
            var __arg0 = modal_window is null ? __IntPtr.Zero : modal_window.__Instance;
            var __arg1 = parent_window is null ? __IntPtr.Zero : parent_window.__Instance;
            var ___ret = __Internal.SetWindowModalFor(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Explicitly set input focus to the window.</summary>
        /// <param name="window">the window that should get the input focus</param>
        /// <remarks>
        /// <para>You almost certainly want SDL_RaiseWindow() instead of this function. Use</para>
        /// <para>this with caution, as you might give focus to a window that is completely</para>
        /// <para>obscured by other windows.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_RaiseWindow</para>
        /// </remarks>
        public static int SetWindowInputFocus(global::SDL3Sharp.Window window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.SetWindowInputFocus(__arg0);
            return ___ret;
        }

        /// <summary>Set whether the window may have input focus.</summary>
        /// <param name="window">the window to set focusable state</param>
        /// <param name="focusable">
        /// <para>SDL_TRUE to allow input focus, SDL_FALSE to not allow</para>
        /// <para>input focus</para>
        /// </param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int SetWindowFocusable(global::SDL3Sharp.Window window, bool focusable)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.SetWindowFocusable(__arg0, focusable);
            return ___ret;
        }

        /// <summary>Display the system-level window menu.</summary>
        /// <param name="window">the window for which the menu will be displayed</param>
        /// <param name="x">
        /// <para>the x coordinate of the menu, relative to the origin (top-left) of</para>
        /// <para>the client area</para>
        /// </param>
        /// <param name="y">
        /// <para>the y coordinate of the menu, relative to the origin (top-left) of</para>
        /// <para>the client area</para>
        /// </param>
        /// <remarks>
        /// <para>This default window menu is provided by the system and on some platforms</para>
        /// <para>provides functionality for setting or changing privileged state on the</para>
        /// <para>window, such as moving it between workspaces or displays, or toggling the</para>
        /// <para>always-on-top property.</para>
        /// <para>On platforms or desktops where this is unsupported, this function does</para>
        /// <para>nothing.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int ShowWindowSystemMenu(global::SDL3Sharp.Window window, int x, int y)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.ShowWindowSystemMenu(__arg0, x, y);
            return ___ret;
        }

        /// <summary>Provide a callback that decides if a window region has special properties.</summary>
        /// <param name="window">the window to set hit-testing on</param>
        /// <param name="callback">the function to call when doing a hit-test</param>
        /// <param name="callback_data">an app-defined void pointer passed to **callback**</param>
        /// <remarks>
        /// <para>Normally windows are dragged and resized by decorations provided by the</para>
        /// <para>system window manager (a title bar, borders, etc), but for some apps, it</para>
        /// <para>makes sense to drag them from somewhere else inside the window itself; for</para>
        /// <para>example, one might have a borderless window that wants to be draggable from</para>
        /// <para>any part, or simulate its own title bar, etc.</para>
        /// <para>This function lets the app provide a callback that designates pieces of a</para>
        /// <para>given window as special. This callback is run during event processing if we</para>
        /// <para>need to tell the OS to treat a region of the window specially; the use of</para>
        /// <para>this callback is known as &quot;hit testing.&quot;</para>
        /// <para>Mouse input may not be delivered to your application if it is within a</para>
        /// <para>special area; the OS will often apply that input to moving the window or</para>
        /// <para>resizing the window and not deliver it to the application.</para>
        /// <para>Specifying NULL for a callback disables hit-testing. Hit-testing is</para>
        /// <para>disabled by default.</para>
        /// <para>Platforms that don't support this functionality will return -1</para>
        /// <para>unconditionally, even if you're attempting to disable hit-testing.</para>
        /// <para>Your callback may fire at any time, and its firing does not indicate any</para>
        /// <para>specific behavior (for example, on Windows, this certainly might fire when</para>
        /// <para>the OS is deciding whether to drag your window, but it fires for lots of</para>
        /// <para>other reasons, too, some unrelated to anything you probably care about _and</para>
        /// <para>when the mouse isn't actually at the location it is testing_). Since this</para>
        /// <para>can fire at any time, you should try to keep your callback efficient,</para>
        /// <para>devoid of allocations, etc.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int SetWindowHitTest(global::SDL3Sharp.Window window, global::SDL3Sharp.HitTest callback, __IntPtr callback_data)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __arg1 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var ___ret = __Internal.SetWindowHitTest(__arg0, __arg1, callback_data);
            return ___ret;
        }

        /// <summary>Set the shape of a transparent window.</summary>
        /// <param name="window">the window</param>
        /// <param name="shape">
        /// <para>the surface representing the shape of the window, or NULL to</para>
        /// <para>remove any current shape</para>
        /// </param>
        /// <remarks>
        /// <para>This sets the alpha channel of a transparent window and any fully</para>
        /// <para>transparent areas are also transparent to mouse clicks. If you are using</para>
        /// <para>something besides the SDL render API, then you are responsible for setting</para>
        /// <para>the alpha channel of the window yourself.</para>
        /// <para>The shape is copied inside this function, so you can free it afterwards. If</para>
        /// <para>your shape surface changes, you should call SDL_SetWindowShape() again to</para>
        /// <para>update the window.</para>
        /// <para>The window must have been created with the SDL_WINDOW_TRANSPARENT flag.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int SetWindowShape(global::SDL3Sharp.Window window, global::SDL3Sharp.Surface shape)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __arg1 = shape is null ? __IntPtr.Zero : shape.__Instance;
            var ___ret = __Internal.SetWindowShape(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Request a window to demand attention from the user.</summary>
        /// <param name="window">the window to be flashed</param>
        /// <param name="operation">the flash operation</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int FlashWindow(global::SDL3Sharp.Window window, global::SDL3Sharp.FlashOperation operation)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.FlashWindow(__arg0, operation);
            return ___ret;
        }

        /// <summary>Destroy a window.</summary>
        /// <param name="window">the window to destroy</param>
        /// <remarks>
        /// <para>If `window` is NULL, this function will return immediately after setting</para>
        /// <para>the SDL error message to &quot;Invalid window&quot;. See SDL_GetError().</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreatePopupWindow</para>
        /// <para>SDL_CreateWindow</para>
        /// <para>SDL_CreateWindowWithProperties</para>
        /// </remarks>
        public static void DestroyWindow(global::SDL3Sharp.Window window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.DestroyWindow(__arg0);
        }

        /// <summary>Check whether the screensaver is currently enabled.</summary>
        /// <remarks>
        /// <para>The screensaver is disabled by default since SDL 2.0.2. Before SDL 2.0.2</para>
        /// <para>the screensaver was enabled by default.</para>
        /// <para>The default can also be changed using `SDL_HINT_VIDEO_ALLOW_SCREENSAVER`.</para>
        /// <para>SDL_TRUE if the screensaver is enabled, SDL_FALSE if it is</para>
        /// <para>disabled.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_DisableScreenSaver</para>
        /// <para>SDL_EnableScreenSaver</para>
        /// </remarks>
        public static bool ScreenSaverEnabled()
        {
            var ___ret = __Internal.ScreenSaverEnabled();
            return ___ret;
        }

        /// <summary>Allow the screen to be blanked by a screen saver.</summary>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_DisableScreenSaver</para>
        /// <para>SDL_ScreenSaverEnabled</para>
        /// </remarks>
        public static int EnableScreenSaver()
        {
            var ___ret = __Internal.EnableScreenSaver();
            return ___ret;
        }

        /// <summary>Prevent the screen from being blanked by a screen saver.</summary>
        /// <remarks>
        /// <para>If you disable the screensaver, it is automatically re-enabled when SDL</para>
        /// <para>quits.</para>
        /// <para>The screensaver is disabled by default since SDL 2.0.2. Before SDL 2.0.2</para>
        /// <para>the screensaver was enabled by default.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_EnableScreenSaver</para>
        /// <para>SDL_ScreenSaverEnabled</para>
        /// </remarks>
        public static int DisableScreenSaver()
        {
            var ___ret = __Internal.DisableScreenSaver();
            return ___ret;
        }

        /// <summary>Dynamically load an OpenGL library.</summary>
        /// <param name="path">
        /// <para>the platform dependent OpenGL library name, or NULL to open the</para>
        /// <para>default OpenGL library</para>
        /// </param>
        /// <remarks>
        /// <para>This should be done after initializing the video driver, but before</para>
        /// <para>creating any OpenGL windows. If no OpenGL library is loaded, the default</para>
        /// <para>library will be loaded upon creation of the first OpenGL window.</para>
        /// <para>If you do this, you need to retrieve all of the GL functions used in your</para>
        /// <para>program from the dynamic library using SDL_GL_GetProcAddress().</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GL_GetProcAddress</para>
        /// <para>SDL_GL_UnloadLibrary</para>
        /// </remarks>
        public static int GL_LoadLibrary(string path)
        {
            var ___ret = __Internal.GL_LoadLibrary(path);
            return ___ret;
        }

        /// <summary>Get an OpenGL function by name.</summary>
        /// <param name="proc">the name of an OpenGL function</param>
        /// <remarks>
        /// <para>If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all</para>
        /// <para>GL functions must be retrieved this way. Usually this is used to retrieve</para>
        /// <para>function pointers to OpenGL extensions.</para>
        /// <para>There are some quirks to looking up OpenGL functions that require some</para>
        /// <para>extra care from the application. If you code carefully, you can handle</para>
        /// <para>these quirks without any platform-specific code, though:</para>
        /// <para>- On Windows, function pointers are specific to the current GL context;</para>
        /// <para>this means you need to have created a GL context and made it current</para>
        /// <para>before calling SDL_GL_GetProcAddress(). If you recreate your context or</para>
        /// <para>create a second context, you should assume that any existing function</para>
        /// <para>pointers aren't valid to use with it. This is (currently) a</para>
        /// <para>Windows-specific limitation, and in practice lots of drivers don't suffer</para>
        /// <para>this limitation, but it is still the way the wgl API is documented to</para>
        /// <para>work and you should expect crashes if you don't respect it. Store a copy</para>
        /// <para>of the function pointers that comes and goes with context lifespan.</para>
        /// <para>- On X11, function pointers returned by this function are valid for any</para>
        /// <para>context, and can even be looked up before a context is created at all.</para>
        /// <para>This means that, for at least some common OpenGL implementations, if you</para>
        /// <para>look up a function that doesn't exist, you'll get a non-NULL result that</para>
        /// <para>is _NOT_ safe to call. You must always make sure the function is actually</para>
        /// <para>available for a given GL context before calling it, by checking for the</para>
        /// <para>existence of the appropriate extension with SDL_GL_ExtensionSupported(),</para>
        /// <para>or verifying that the version of OpenGL you're using offers the function</para>
        /// <para>as core functionality.</para>
        /// <para>- Some OpenGL drivers, on all platforms, *will* return NULL if a function</para>
        /// <para>isn't supported, but you can't count on this behavior. Check for</para>
        /// <para>extensions you use, and if you get a NULL anyway, act as if that</para>
        /// <para>extension wasn't available. This is probably a bug in the driver, but you</para>
        /// <para>can code defensively for this scenario anyhow.</para>
        /// <para>- Just because you're on Linux/Unix, don't assume you'll be using X11.</para>
        /// <para>Next-gen display servers are waiting to replace it, and may or may not</para>
        /// <para>make the same promises about function pointers.</para>
        /// <para>- OpenGL function pointers must be declared `APIENTRY` as in the example</para>
        /// <para>code. This will ensure the proper calling convention is followed on</para>
        /// <para>platforms where this matters (Win32) thereby avoiding stack corruption.</para>
        /// <para>a pointer to the named OpenGL function. The returned pointer</para>
        /// <para>should be cast to the appropriate function signature.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GL_ExtensionSupported</para>
        /// <para>SDL_GL_LoadLibrary</para>
        /// <para>SDL_GL_UnloadLibrary</para>
        /// </remarks>
        public static global::SDL3Sharp.FunctionPointer GL_GetProcAddress(string proc)
        {
            var ___ret = __Internal.GL_GetProcAddress(proc);
            var __ptr0 = ___ret;
            return __ptr0 == IntPtr.Zero? null : (global::SDL3Sharp.FunctionPointer) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::SDL3Sharp.FunctionPointer));
        }

        /// <summary>Get an EGL library function by name.</summary>
        /// <param name="proc">the name of an EGL function</param>
        /// <remarks>
        /// <para>If an EGL library is loaded, this function allows applications to get entry</para>
        /// <para>points for EGL functions. This is useful to provide to an EGL API and</para>
        /// <para>extension loader.</para>
        /// <para>a pointer to the named EGL function. The returned pointer should</para>
        /// <para>be cast to the appropriate function signature.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GL_GetCurrentEGLDisplay</para>
        /// </remarks>
        public static global::SDL3Sharp.FunctionPointer EGL_GetProcAddress(string proc)
        {
            var ___ret = __Internal.EGL_GetProcAddress(proc);
            var __ptr0 = ___ret;
            return __ptr0 == IntPtr.Zero? null : (global::SDL3Sharp.FunctionPointer) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::SDL3Sharp.FunctionPointer));
        }

        /// <summary>Unload the OpenGL library previously loaded by SDL_GL_LoadLibrary().</summary>
        /// <remarks>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GL_LoadLibrary</para>
        /// </remarks>
        public static void GL_UnloadLibrary()
        {
            __Internal.GL_UnloadLibrary();
        }

        /// <summary>Check if an OpenGL extension is supported for the current context.</summary>
        /// <param name="extension">the name of the extension to check</param>
        /// <remarks>
        /// <para>This function operates on the current GL context; you must have created a</para>
        /// <para>context and it must be current before calling this function. Do not assume</para>
        /// <para>that all contexts you create will have the same set of extensions</para>
        /// <para>available, or that recreating an existing context will offer the same</para>
        /// <para>extensions again.</para>
        /// <para>While it's probably not a massive overhead, this function is not an O(1)</para>
        /// <para>operation. Check the extensions you care about after creating the GL</para>
        /// <para>context and save that information somewhere instead of calling the function</para>
        /// <para>every time you need to know.</para>
        /// <para>SDL_TRUE if the extension is supported, SDL_FALSE otherwise.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static bool GL_ExtensionSupported(string extension)
        {
            var ___ret = __Internal.GL_ExtensionSupported(extension);
            return ___ret;
        }

        /// <summary>Reset all previously set OpenGL context attributes to their default values.</summary>
        /// <remarks>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GL_GetAttribute</para>
        /// <para>SDL_GL_SetAttribute</para>
        /// </remarks>
        public static void GL_ResetAttributes()
        {
            __Internal.GL_ResetAttributes();
        }

        /// <summary>Set an OpenGL window attribute before window creation.</summary>
        /// <param name="attr">an SDL_GLattr enum value specifying the OpenGL attribute to set</param>
        /// <param name="value">the desired value for the attribute</param>
        /// <remarks>
        /// <para>This function sets the OpenGL attribute `attr` to `value`. The requested</para>
        /// <para>attributes should be set before creating an OpenGL window. You should use</para>
        /// <para>SDL_GL_GetAttribute() to check the values after creating the OpenGL</para>
        /// <para>context, since the values obtained can differ from the requested ones.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GL_GetAttribute</para>
        /// <para>SDL_GL_ResetAttributes</para>
        /// </remarks>
        public static int GL_SetAttribute(global::SDL3Sharp.GLattr attr, int value)
        {
            var ___ret = __Internal.GL_SetAttribute(attr, value);
            return ___ret;
        }

        /// <summary>Get the actual value for an attribute from the current context.</summary>
        /// <param name="attr">an SDL_GLattr enum value specifying the OpenGL attribute to get</param>
        /// <param name="value">a pointer filled in with the current value of `attr`</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GL_ResetAttributes</para>
        /// <para>SDL_GL_SetAttribute</para>
        /// </remarks>
        public static int GL_GetAttribute(global::SDL3Sharp.GLattr attr, out int value)
        {
            fixed (int* __value1 = &value)
            {
                var __arg1 = __value1;
                var ___ret = __Internal.GL_GetAttribute(attr, __arg1);
                return ___ret;
            }
        }

        /// <summary>Create an OpenGL context for an OpenGL window, and make it current.</summary>
        /// <param name="window">the window to associate with the context</param>
        /// <remarks>
        /// <para>Windows users new to OpenGL should note that, for historical reasons, GL</para>
        /// <para>functions added after OpenGL version 1.1 are not available by default.</para>
        /// <para>Those functions must be loaded at run-time, either with an OpenGL</para>
        /// <para>extension-handling library or with SDL_GL_GetProcAddress() and its related</para>
        /// <para>functions.</para>
        /// <para>SDL_GLContext is an alias for `void *`. It's opaque to the application.</para>
        /// <para>the OpenGL context associated with `window` or NULL on error; call</para>
        /// <para>SDL_GetError() for more details.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GL_DeleteContext</para>
        /// <para>SDL_GL_MakeCurrent</para>
        /// </remarks>
        public static __IntPtr GL_CreateContext(global::SDL3Sharp.Window window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.GL_CreateContext(__arg0);
            return ___ret;
        }

        /// <summary>Set up an OpenGL context for rendering into an OpenGL window.</summary>
        /// <param name="window">the window to associate with the context</param>
        /// <param name="context">the OpenGL context to associate with the window</param>
        /// <remarks>
        /// <para>The context must have been created with a compatible window.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GL_CreateContext</para>
        /// </remarks>
        public static int GL_MakeCurrent(global::SDL3Sharp.Window window, __IntPtr context)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.GL_MakeCurrent(__arg0, context);
            return ___ret;
        }

        /// <summary>Get the currently active OpenGL window.</summary>
        /// <remarks>
        /// <para>the currently active OpenGL window on success or NULL on failure;</para>
        /// <para>call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static global::SDL3Sharp.Window GL_GetCurrentWindow()
        {
            var ___ret = __Internal.GL_GetCurrentWindow();
            var __result0 = global::SDL3Sharp.Window.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the currently active OpenGL context.</summary>
        /// <remarks>
        /// <para>the currently active OpenGL context or NULL on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GL_MakeCurrent</para>
        /// </remarks>
        public static __IntPtr GL_GetCurrentContext()
        {
            var ___ret = __Internal.GL_GetCurrentContext();
            return ___ret;
        }

        /// <summary>Get the currently active EGL display.</summary>
        /// <remarks>
        /// <para>the currently active EGL display or NULL on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static __IntPtr EGL_GetCurrentEGLDisplay()
        {
            var ___ret = __Internal.EGL_GetCurrentEGLDisplay();
            return ___ret;
        }

        /// <summary>Get the currently active EGL config.</summary>
        /// <remarks>
        /// <para>the currently active EGL config or NULL on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static __IntPtr EGL_GetCurrentEGLConfig()
        {
            var ___ret = __Internal.EGL_GetCurrentEGLConfig();
            return ___ret;
        }

        /// <summary>Get the EGL surface associated with the window.</summary>
        /// <param name="window">the window to query</param>
        /// <remarks>
        /// <para>the EGLSurface pointer associated with the window, or NULL on</para>
        /// <para>failure.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static __IntPtr EGL_GetWindowEGLSurface(global::SDL3Sharp.Window window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.EGL_GetWindowEGLSurface(__arg0);
            return ___ret;
        }

        /// <summary>
        /// <para>Sets the callbacks for defining custom EGLAttrib arrays for EGL</para>
        /// <para>initialization.</para>
        /// </summary>
        /// <param name="platformAttribCallback">
        /// <para>Callback for attributes to pass to</para>
        /// <para>eglGetPlatformDisplay.</para>
        /// </param>
        /// <param name="surfaceAttribCallback">
        /// <para>Callback for attributes to pass to</para>
        /// <para>eglCreateSurface.</para>
        /// </param>
        /// <param name="contextAttribCallback">
        /// <para>Callback for attributes to pass to</para>
        /// <para>eglCreateContext.</para>
        /// </param>
        /// <remarks>
        /// <para>Each callback should return a pointer to an EGL attribute array terminated</para>
        /// <para>with EGL_NONE. Callbacks may return NULL pointers to signal an error, which</para>
        /// <para>will cause the SDL_CreateWindow process to fail gracefully.</para>
        /// <para>The arrays returned by each callback will be appended to the existing</para>
        /// <para>attribute arrays defined by SDL.</para>
        /// <para>NOTE: These callback pointers will be reset after SDL_GL_ResetAttributes.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static void EGL_SetEGLAttributeCallbacks(global::SDL3Sharp.EGLAttribArrayCallback platformAttribCallback, global::SDL3Sharp.EGLIntArrayCallback surfaceAttribCallback, global::SDL3Sharp.EGLIntArrayCallback contextAttribCallback)
        {
            var __arg0 = platformAttribCallback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(platformAttribCallback);
            var __arg1 = surfaceAttribCallback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(surfaceAttribCallback);
            var __arg2 = contextAttribCallback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(contextAttribCallback);
            __Internal.EGL_SetEGLAttributeCallbacks(__arg0, __arg1, __arg2);
        }

        /// <summary>Set the swap interval for the current OpenGL context.</summary>
        /// <param name="interval">
        /// <para>0 for immediate updates, 1 for updates synchronized with</para>
        /// <para>the vertical retrace, -1 for adaptive vsync</para>
        /// </param>
        /// <remarks>
        /// <para>Some systems allow specifying -1 for the interval, to enable adaptive</para>
        /// <para>vsync. Adaptive vsync works the same as vsync, but if you've already missed</para>
        /// <para>the vertical retrace for a given frame, it swaps buffers immediately, which</para>
        /// <para>might be less jarring for the user during occasional framerate drops. If an</para>
        /// <para>application requests adaptive vsync and the system does not support it,</para>
        /// <para>this function will fail and return -1. In such a case, you should probably</para>
        /// <para>retry the call with 1 for the interval.</para>
        /// <para>Adaptive vsync is implemented for some glX drivers with</para>
        /// <para>GLX_EXT_swap_control_tear, and for some Windows drivers with</para>
        /// <para>WGL_EXT_swap_control_tear.</para>
        /// <para>Read more on the Khronos wiki:</para>
        /// <para>https://www.khronos.org/opengl/wiki/Swap_Interval#Adaptive_Vsync</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GL_GetSwapInterval</para>
        /// </remarks>
        public static int GL_SetSwapInterval(int interval)
        {
            var ___ret = __Internal.GL_SetSwapInterval(interval);
            return ___ret;
        }

        /// <summary>Get the swap interval for the current OpenGL context.</summary>
        /// <param name="interval">
        /// <para>Output interval value. 0 if there is no vertical retrace</para>
        /// <para>synchronization, 1 if the buffer swap is synchronized with</para>
        /// <para>the vertical retrace, and -1 if late swaps happen</para>
        /// <para>immediately instead of waiting for the next retrace</para>
        /// </param>
        /// <remarks>
        /// <para>If the system can't determine the swap interval, or there isn't a valid</para>
        /// <para>current context, this function will set *interval to 0 as a safe default.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GL_SetSwapInterval</para>
        /// </remarks>
        public static int GL_GetSwapInterval(ref int interval)
        {
            fixed (int* __interval0 = &interval)
            {
                var __arg0 = __interval0;
                var ___ret = __Internal.GL_GetSwapInterval(__arg0);
                return ___ret;
            }
        }

        /// <summary>Update a window with OpenGL rendering.</summary>
        /// <param name="window">the window to change</param>
        /// <remarks>
        /// <para>This is used with double-buffered OpenGL contexts, which are the default.</para>
        /// <para>On macOS, make sure you bind 0 to the draw framebuffer before swapping the</para>
        /// <para>window, otherwise nothing will happen. If you aren't using</para>
        /// <para>glBindFramebuffer(), this is the default and you won't have to do anything</para>
        /// <para>extra.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int GL_SwapWindow(global::SDL3Sharp.Window window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.GL_SwapWindow(__arg0);
            return ___ret;
        }

        /// <summary>Delete an OpenGL context.</summary>
        /// <param name="context">the OpenGL context to be deleted</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GL_CreateContext</para>
        /// </remarks>
        public static int GL_DeleteContext(__IntPtr context)
        {
            var ___ret = __Internal.GL_DeleteContext(context);
            return ___ret;
        }
    }
}
