// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required
#pragma warning disable CS9084 // Struct member returns 'this' or other instance members by reference

namespace SDL3Sharp
{
    public enum AssertState
    {
        /// <summary>Retry the assert immediately.</summary>
        Retry = 0,
        /// <summary>Make the debugger trigger a breakpoint.</summary>
        Break = 1,
        /// <summary>Terminate the program.</summary>
        Abort = 2,
        /// <summary>Ignore the assert.</summary>
        Ignore = 3,
        /// <summary>Ignore the assert from now on.</summary>
        AlwaysIgnore = 4
    }

    /// <summary>A callback that fires when an SDL assertion fails.</summary>
    /// <param name="data">
    /// <para>a pointer to the SDL_AssertData structure corresponding to the</para>
    /// <para>current assertion</para>
    /// </param>
    /// <param name="userdata">what was passed as `userdata` to SDL_SetAssertionHandler()</param>
    /// <remarks>an SDL_AssertState value indicating how to handle the failure.</remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate global::SDL3Sharp.AssertState AssertionHandler(__IntPtr data, __IntPtr userdata);

    public unsafe partial class AssertData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 48, Pack = 8)]
        public partial struct __Internal
        {
            internal int always_ignore;
            internal uint trigger_count;
            internal __IntPtr condition;
            internal __IntPtr filename;
            internal int linenum;
            internal __IntPtr function;
            internal __IntPtr next;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_AssertData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.AssertData> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.AssertData>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.AssertData managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.AssertData managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        private bool __condition_OwnsNativeMemory = false;
        private bool __filename_OwnsNativeMemory = false;
        private bool __function_OwnsNativeMemory = false;
        protected bool __ownsNativeInstance;

        internal static AssertData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new AssertData(native.ToPointer(), skipVTables);
        }

        internal static AssertData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (AssertData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static AssertData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new AssertData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private AssertData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected AssertData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public AssertData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.AssertData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public AssertData(global::SDL3Sharp.AssertData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.AssertData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.AssertData.__Internal*) __Instance) = *((global::SDL3Sharp.AssertData.__Internal*) _0.__Instance);
            if (_0.__condition_OwnsNativeMemory)
                this.Condition = _0.Condition;
            if (_0.__filename_OwnsNativeMemory)
                this.Filename = _0.Filename;
            if (_0.__function_OwnsNativeMemory)
                this.Function = _0.Function;
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__condition_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->condition);
            if (__filename_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->filename);
            if (__function_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->function);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int AlwaysIgnore
        {
            get
            {
                return ((__Internal*)__Instance)->always_ignore;
            }

            set
            {
                ((__Internal*)__Instance)->always_ignore = value;
            }
        }

        public uint TriggerCount
        {
            get
            {
                return ((__Internal*)__Instance)->trigger_count;
            }

            set
            {
                ((__Internal*)__Instance)->trigger_count = value;
            }
        }

        public string Condition
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->condition);
            }

            set
            {
                if (__condition_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->condition);
                __condition_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->condition = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->condition = (__IntPtr) __bytePtr0;
            }
        }

        public string Filename
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->filename);
            }

            set
            {
                if (__filename_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->filename);
                __filename_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->filename = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->filename = (__IntPtr) __bytePtr0;
            }
        }

        public int Linenum
        {
            get
            {
                return ((__Internal*)__Instance)->linenum;
            }

            set
            {
                ((__Internal*)__Instance)->linenum = value;
            }
        }

        public string Function
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->function);
            }

            set
            {
                if (__function_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->function);
                __function_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->function = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->function = (__IntPtr) __bytePtr0;
            }
        }

        public global::SDL3Sharp.AssertData Next
        {
            get
            {
                var __result0 = global::SDL3Sharp.AssertData.__GetOrCreateInstance(((__Internal*)__Instance)->next, false);
                return __result0;
            }
        }
    }

    public unsafe partial class SDL
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_ReportAssertion", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::SDL3Sharp.AssertState ReportAssertion(__IntPtr data, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string func, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string file, int line);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetAssertionHandler", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetAssertionHandler(__IntPtr handler, __IntPtr userdata);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetDefaultAssertionHandler", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetDefaultAssertionHandler();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetAssertionHandler", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetAssertionHandler(__IntPtr* puserdata);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetAssertionReport", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetAssertionReport();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_ResetAssertionReport", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ResetAssertionReport();
        }

        /// <summary>Never call this directly.</summary>
        /// <param name="data">assert data structure</param>
        /// <param name="func">function name</param>
        /// <param name="file">file name</param>
        /// <param name="line">line number</param>
        /// <remarks>
        /// <para>Use the SDL_assert* macros.</para>
        /// <para>assert state</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static global::SDL3Sharp.AssertState ReportAssertion(global::SDL3Sharp.AssertData data, string func, string file, int line)
        {
            var __arg0 = data is null ? __IntPtr.Zero : data.__Instance;
            var ___ret = __Internal.ReportAssertion(__arg0, func, file, line);
            return ___ret;
        }

        /// <summary>Set an application-defined assertion handler.</summary>
        /// <param name="handler">
        /// <para>the SDL_AssertionHandler function to call when an assertion</para>
        /// <para>fails or NULL for the default handler</para>
        /// </param>
        /// <param name="userdata">a pointer that is passed to `handler`</param>
        /// <remarks>
        /// <para>This function allows an application to show its own assertion UI and/or</para>
        /// <para>force the response to an assertion failure. If the application doesn't</para>
        /// <para>provide this, SDL will try to do the right thing, popping up a</para>
        /// <para>system-specific GUI dialog, and probably minimizing any fullscreen windows.</para>
        /// <para>This callback may fire from any thread, but it runs wrapped in a mutex, so</para>
        /// <para>it will only fire from one thread at a time.</para>
        /// <para>This callback is NOT reset to SDL's internal handler upon SDL_Quit()!</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetAssertionHandler</para>
        /// </remarks>
        public static void SetAssertionHandler(global::SDL3Sharp.AssertionHandler handler, __IntPtr userdata)
        {
            var __arg0 = handler == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(handler);
            __Internal.SetAssertionHandler(__arg0, userdata);
        }

        /// <summary>Get the default assertion handler.</summary>
        /// <remarks>
        /// <para>This returns the function pointer that is called by default when an</para>
        /// <para>assertion is triggered. This is an internal function provided by SDL, that</para>
        /// <para>is used for assertions when SDL_SetAssertionHandler() hasn't been used to</para>
        /// <para>provide a different function.</para>
        /// <para>the default SDL_AssertionHandler that is called when an assert</para>
        /// <para>triggers.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetAssertionHandler</para>
        /// </remarks>
        public static global::SDL3Sharp.AssertionHandler GetDefaultAssertionHandler()
        {
            var ___ret = __Internal.GetDefaultAssertionHandler();
            var __ptr0 = ___ret;
            return __ptr0 == IntPtr.Zero? null : (global::SDL3Sharp.AssertionHandler) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::SDL3Sharp.AssertionHandler));
        }

        /// <summary>Get the current assertion handler.</summary>
        /// <param name="puserdata">
        /// <para>pointer which is filled with the &quot;userdata&quot; pointer that</para>
        /// <para>was passed to SDL_SetAssertionHandler()</para>
        /// </param>
        /// <remarks>
        /// <para>This returns the function pointer that is called when an assertion is</para>
        /// <para>triggered. This is either the value last passed to</para>
        /// <para>SDL_SetAssertionHandler(), or if no application-specified function is set,</para>
        /// <para>is equivalent to calling SDL_GetDefaultAssertionHandler().</para>
        /// <para>The parameter `puserdata` is a pointer to a void*, which will store the</para>
        /// <para>&quot;userdata&quot; pointer that was passed to SDL_SetAssertionHandler(). This value</para>
        /// <para>will always be NULL for the default handler. If you don't care about this</para>
        /// <para>data, it is safe to pass a NULL pointer to this function to ignore it.</para>
        /// <para>the SDL_AssertionHandler that is called when an assert triggers.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_SetAssertionHandler</para>
        /// </remarks>
        public static global::SDL3Sharp.AssertionHandler GetAssertionHandler(__IntPtr* puserdata)
        {
            var ___ret = __Internal.GetAssertionHandler(puserdata);
            var __ptr0 = ___ret;
            return __ptr0 == IntPtr.Zero? null : (global::SDL3Sharp.AssertionHandler) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::SDL3Sharp.AssertionHandler));
        }

        /// <summary>Get a list of all assertion failures.</summary>
        /// <remarks>
        /// <para>This function gets all assertions triggered since the last call to</para>
        /// <para>SDL_ResetAssertionReport(), or the start of the program.</para>
        /// <para>The proper way to examine this data looks something like this:</para>
        /// <para>```c</para>
        /// <para>const SDL_AssertData *item = SDL_GetAssertionReport();</para>
        /// <para>while (item) {</para>
        /// <para>printf(&quot;'%s', %s (%s:%d), triggered %u times, always ignore: %s.\\n&quot;,</para>
        /// <para>item-&gt;condition, item-&gt;function, item-&gt;filename,</para>
        /// <para>item-&gt;linenum, item-&gt;trigger_count,</para>
        /// <para>item-&gt;always_ignore ? &quot;yes&quot; : &quot;no&quot;);</para>
        /// <para>item = item-&gt;next;</para>
        /// <para>}</para>
        /// <para>```</para>
        /// <para>a list of all failed assertions or NULL if the list is empty. This</para>
        /// <para>memory should not be modified or freed by the application.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_ResetAssertionReport</para>
        /// </remarks>
        public static global::SDL3Sharp.AssertData GetAssertionReport()
        {
            var ___ret = __Internal.GetAssertionReport();
            var __result0 = global::SDL3Sharp.AssertData.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Clear the list of all assertion failures.</summary>
        /// <remarks>
        /// <para>This function will clear the list of all assertions triggered up to that</para>
        /// <para>point. Immediately following this call, SDL_GetAssertionReport will return</para>
        /// <para>no items. In addition, any previously-triggered assertions will be reset to</para>
        /// <para>a trigger_count of zero, and their always_ignore state will be false.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetAssertionReport</para>
        /// </remarks>
        public static void ResetAssertionReport()
        {
            __Internal.ResetAssertionReport();
        }
    }
}
