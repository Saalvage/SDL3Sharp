// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required
#pragma warning disable CS9084 // Struct member returns 'this' or other instance members by reference

namespace SDL3Sharp
{
    /// <summary>Flags used when creating a rendering context</summary>
    [Flags]
    public enum RendererFlags
    {
        /// <summary>The renderer is a software fallback</summary>
        Software = 1,
        /// <summary>
        /// <para>The renderer uses hardware</para>
        /// <para>acceleration</para>
        /// </summary>
        Accelerated = 2,
        /// <summary>
        /// <para>Present is synchronized</para>
        /// <para>with the refresh rate</para>
        /// </summary>
        Presentvsync = 4
    }

    /// <summary>The access pattern allowed for a texture.</summary>
    public enum TextureAccess
    {
        /// <summary>Changes rarely, not lockable</summary>
        Static = 0,
        /// <summary>Changes frequently, lockable</summary>
        Streaming = 1,
        /// <summary>Texture can be used as a render target</summary>
        Target = 2
    }

    /// <summary>How the logical size is mapped to the output</summary>
    public enum RendererLogicalPresentation
    {
        /// <summary>There is no logical size in effect</summary>
        Disabled = 0,
        /// <summary>The rendered content is stretched to the output resolution</summary>
        Stretch = 1,
        /// <summary>The rendered content is fit to the largest dimension and the other dimension is letterboxed with black bars</summary>
        Letterbox = 2,
        /// <summary>The rendered content is fit to the smallest dimension and the other dimension extends beyond the output bounds</summary>
        Overscan = 3,
        /// <summary>The rendered content is scaled up by integer multiples to fit the output resolution</summary>
        IntegerScale = 4
    }

    /// <summary>Flags used when creating a rendering context</summary>
    /// <summary>Information on the capabilities of a render driver or context.</summary>
    /// <summary>Vertex structure</summary>
    /// <summary>The access pattern allowed for a texture.</summary>
    /// <summary>How the logical size is mapped to the output</summary>
    /// <summary>A structure representing rendering state</summary>
    public unsafe partial class Renderer
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.Renderer> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.Renderer>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.Renderer managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.Renderer managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Renderer __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Renderer(native.ToPointer(), skipVTables);
        }

        internal static Renderer __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Renderer)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Renderer __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Renderer(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Renderer(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Renderer(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    /// <summary>An efficient driver-specific representation of pixel data</summary>
    public unsafe partial class Texture
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.Texture> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.Texture>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.Texture managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.Texture managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Texture __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Texture(native.ToPointer(), skipVTables);
        }

        internal static Texture __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Texture)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Texture __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Texture(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Texture(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Texture(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    /// <summary>Information on the capabilities of a render driver or context.</summary>
    public unsafe partial class RendererInfo : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 88, Pack = 8)]
        public partial struct __Internal
        {
            internal __IntPtr name;
            internal uint flags;
            internal int num_texture_formats;
            internal fixed int texture_formats[16];
            internal int max_texture_width;
            internal int max_texture_height;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_RendererInfo@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.RendererInfo> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.RendererInfo>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.RendererInfo managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.RendererInfo managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        private bool __name_OwnsNativeMemory = false;
        protected bool __ownsNativeInstance;

        internal static RendererInfo __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new RendererInfo(native.ToPointer(), skipVTables);
        }

        internal static RendererInfo __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (RendererInfo)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static RendererInfo __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RendererInfo(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RendererInfo(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected RendererInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RendererInfo()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.RendererInfo.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public RendererInfo(global::SDL3Sharp.RendererInfo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.RendererInfo.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.RendererInfo.__Internal*) __Instance) = *((global::SDL3Sharp.RendererInfo.__Internal*) _0.__Instance);
            if (_0.__name_OwnsNativeMemory)
                this.Name = _0.Name;
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__name_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->name);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>The name of the renderer</summary>
        public string Name
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->name);
            }

            set
            {
                if (__name_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->name);
                __name_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->name = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->name = (__IntPtr) __bytePtr0;
            }
        }

        /// <summary>Supported ::SDL_RendererFlags</summary>
        public uint Flags
        {
            get
            {
                return ((__Internal*)__Instance)->flags;
            }

            set
            {
                ((__Internal*)__Instance)->flags = value;
            }
        }

        /// <summary>The number of available texture formats</summary>
        public int NumTextureFormats
        {
            get
            {
                return ((__Internal*)__Instance)->num_texture_formats;
            }

            set
            {
                ((__Internal*)__Instance)->num_texture_formats = value;
            }
        }

        /// <summary>The maximum texture width</summary>
        public int MaxTextureWidth
        {
            get
            {
                return ((__Internal*)__Instance)->max_texture_width;
            }

            set
            {
                ((__Internal*)__Instance)->max_texture_width = value;
            }
        }

        /// <summary>The maximum texture height</summary>
        public int MaxTextureHeight
        {
            get
            {
                return ((__Internal*)__Instance)->max_texture_height;
            }

            set
            {
                ((__Internal*)__Instance)->max_texture_height = value;
            }
        }
    }

    /// <summary>Vertex structure</summary>
    public unsafe partial class Vertex : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32, Pack = 8)]
        public partial struct __Internal
        {
            internal global::SDL3Sharp.FPoint.__Internal position;
            internal global::SDL3Sharp.FColor.__Internal color;
            internal global::SDL3Sharp.FPoint.__Internal tex_coord;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_Vertex@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.Vertex> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.Vertex>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.Vertex managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.Vertex managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Vertex __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Vertex(native.ToPointer(), skipVTables);
        }

        internal static Vertex __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Vertex)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Vertex __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Vertex(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Vertex(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Vertex(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public Vertex()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.Vertex.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public Vertex(global::SDL3Sharp.Vertex _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.Vertex.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.Vertex.__Internal*) __Instance) = *((global::SDL3Sharp.Vertex.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Vertex position, in SDL_Renderer coordinates</summary>
        public global::SDL3Sharp.FPoint Position
        {
            get
            {
                return global::SDL3Sharp.FPoint.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->position));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->position = *(global::SDL3Sharp.FPoint.__Internal*) value.__Instance;
            }
        }

        /// <summary>Vertex color</summary>
        public global::SDL3Sharp.FColor Color
        {
            get
            {
                return global::SDL3Sharp.FColor.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->color));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->color = *(global::SDL3Sharp.FColor.__Internal*) value.__Instance;
            }
        }

        /// <summary>Normalized texture coordinates, if needed</summary>
        public global::SDL3Sharp.FPoint TexCoord
        {
            get
            {
                return global::SDL3Sharp.FPoint.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->tex_coord));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->tex_coord = *(global::SDL3Sharp.FPoint.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class SDL
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetNumRenderDrivers", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetNumRenderDrivers();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetRenderDriver", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetRenderDriver(int index);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_CreateWindowAndRenderer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int CreateWindowAndRenderer(int width, int height, global::SDL3Sharp.WindowFlags window_flags, __IntPtr window, __IntPtr renderer);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_CreateRenderer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CreateRenderer(__IntPtr window, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, uint flags);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_CreateRendererWithProperties", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CreateRendererWithProperties(uint props);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_CreateSoftwareRenderer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CreateSoftwareRenderer(__IntPtr surface);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetRenderer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetRenderer(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetRenderWindow", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetRenderWindow(__IntPtr renderer);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetRendererInfo", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetRendererInfo(__IntPtr renderer, __IntPtr info);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetRendererProperties", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint GetRendererProperties(__IntPtr renderer);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetRenderOutputSize", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetRenderOutputSize(__IntPtr renderer, int* w, int* h);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetCurrentRenderOutputSize", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetCurrentRenderOutputSize(__IntPtr renderer, int* w, int* h);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_CreateTexture", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CreateTexture(__IntPtr renderer, uint format, int access, int w, int h);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_CreateTextureFromSurface", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CreateTextureFromSurface(__IntPtr renderer, __IntPtr surface);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_CreateTextureWithProperties", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CreateTextureWithProperties(__IntPtr renderer, uint props);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetTextureProperties", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint GetTextureProperties(__IntPtr texture);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetRendererFromTexture", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetRendererFromTexture(__IntPtr texture);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_QueryTexture", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int QueryTexture(__IntPtr texture, uint* format, int* access, int* w, int* h);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetTextureColorMod", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetTextureColorMod(__IntPtr texture, byte r, byte g, byte b);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetTextureColorModFloat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetTextureColorModFloat(__IntPtr texture, float r, float g, float b);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetTextureColorMod", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetTextureColorMod(__IntPtr texture, byte* r, byte* g, byte* b);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetTextureColorModFloat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetTextureColorModFloat(__IntPtr texture, float* r, float* g, float* b);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetTextureAlphaMod", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetTextureAlphaMod(__IntPtr texture, byte alpha);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetTextureAlphaModFloat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetTextureAlphaModFloat(__IntPtr texture, float alpha);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetTextureAlphaMod", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetTextureAlphaMod(__IntPtr texture, byte* alpha);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetTextureAlphaModFloat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetTextureAlphaModFloat(__IntPtr texture, float* alpha);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetTextureBlendMode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetTextureBlendMode(__IntPtr texture, global::SDL3Sharp.BlendMode blendMode);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetTextureBlendMode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetTextureBlendMode(__IntPtr texture, global::SDL3Sharp.BlendMode* blendMode);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetTextureScaleMode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetTextureScaleMode(__IntPtr texture, global::SDL3Sharp.ScaleMode scaleMode);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetTextureScaleMode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetTextureScaleMode(__IntPtr texture, global::SDL3Sharp.ScaleMode* scaleMode);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_UpdateTexture", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int UpdateTexture(__IntPtr texture, __IntPtr rect, __IntPtr pixels, int pitch);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_UpdateYUVTexture", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int UpdateYUVTexture(__IntPtr texture, __IntPtr rect, byte* Yplane, int Ypitch, byte* Uplane, int Upitch, byte* Vplane, int Vpitch);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_UpdateNVTexture", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int UpdateNVTexture(__IntPtr texture, __IntPtr rect, byte* Yplane, int Ypitch, byte* UVplane, int UVpitch);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_LockTexture", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LockTexture(__IntPtr texture, __IntPtr rect, __IntPtr* pixels, int* pitch);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_LockTextureToSurface", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int LockTextureToSurface(__IntPtr texture, __IntPtr rect, __IntPtr surface);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_UnlockTexture", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UnlockTexture(__IntPtr texture);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetRenderTarget", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetRenderTarget(__IntPtr renderer, __IntPtr texture);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetRenderTarget", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetRenderTarget(__IntPtr renderer);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetRenderLogicalPresentation", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetRenderLogicalPresentation(__IntPtr renderer, int w, int h, global::SDL3Sharp.RendererLogicalPresentation mode, global::SDL3Sharp.ScaleMode scale_mode);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetRenderLogicalPresentation", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetRenderLogicalPresentation(__IntPtr renderer, int* w, int* h, global::SDL3Sharp.RendererLogicalPresentation* mode, global::SDL3Sharp.ScaleMode* scale_mode);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_RenderCoordinatesFromWindow", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int RenderCoordinatesFromWindow(__IntPtr renderer, float window_x, float window_y, float* x, float* y);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_RenderCoordinatesToWindow", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int RenderCoordinatesToWindow(__IntPtr renderer, float x, float y, float* window_x, float* window_y);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_ConvertEventToRenderCoordinates", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int ConvertEventToRenderCoordinates(__IntPtr renderer, __IntPtr @event);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetRenderViewport", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetRenderViewport(__IntPtr renderer, __IntPtr rect);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetRenderViewport", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetRenderViewport(__IntPtr renderer, __IntPtr rect);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_RenderViewportSet", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool RenderViewportSet(__IntPtr renderer);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetRenderClipRect", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetRenderClipRect(__IntPtr renderer, __IntPtr rect);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetRenderClipRect", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetRenderClipRect(__IntPtr renderer, __IntPtr rect);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_RenderClipEnabled", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool RenderClipEnabled(__IntPtr renderer);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetRenderScale", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetRenderScale(__IntPtr renderer, float scaleX, float scaleY);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetRenderScale", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetRenderScale(__IntPtr renderer, float* scaleX, float* scaleY);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetRenderDrawColor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetRenderDrawColor(__IntPtr renderer, byte r, byte g, byte b, byte a);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetRenderDrawColorFloat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetRenderDrawColorFloat(__IntPtr renderer, float r, float g, float b, float a);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetRenderDrawColor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetRenderDrawColor(__IntPtr renderer, byte* r, byte* g, byte* b, byte* a);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetRenderDrawColorFloat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetRenderDrawColorFloat(__IntPtr renderer, float* r, float* g, float* b, float* a);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetRenderColorScale", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetRenderColorScale(__IntPtr renderer, float scale);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetRenderColorScale", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetRenderColorScale(__IntPtr renderer, float* scale);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetRenderDrawBlendMode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetRenderDrawBlendMode(__IntPtr renderer, global::SDL3Sharp.BlendMode blendMode);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetRenderDrawBlendMode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetRenderDrawBlendMode(__IntPtr renderer, global::SDL3Sharp.BlendMode* blendMode);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_RenderClear", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int RenderClear(__IntPtr renderer);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_RenderPoint", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int RenderPoint(__IntPtr renderer, float x, float y);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_RenderPoints", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int RenderPoints(__IntPtr renderer, __IntPtr points, int count);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_RenderLine", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int RenderLine(__IntPtr renderer, float x1, float y1, float x2, float y2);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_RenderLines", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int RenderLines(__IntPtr renderer, __IntPtr points, int count);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_RenderRect", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int RenderRect(__IntPtr renderer, __IntPtr rect);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_RenderRects", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int RenderRects(__IntPtr renderer, __IntPtr rects, int count);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_RenderFillRect", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int RenderFillRect(__IntPtr renderer, __IntPtr rect);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_RenderFillRects", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int RenderFillRects(__IntPtr renderer, __IntPtr rects, int count);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_RenderTexture", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int RenderTexture(__IntPtr renderer, __IntPtr texture, __IntPtr srcrect, __IntPtr dstrect);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_RenderTextureRotated", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int RenderTextureRotated(__IntPtr renderer, __IntPtr texture, __IntPtr srcrect, __IntPtr dstrect, double angle, __IntPtr center, global::SDL3Sharp.FlipMode flip);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_RenderGeometry", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int RenderGeometry(__IntPtr renderer, __IntPtr texture, __IntPtr vertices, int num_vertices, int* indices, int num_indices);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_RenderGeometryRaw", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int RenderGeometryRaw(__IntPtr renderer, __IntPtr texture, float* xy, int xy_stride, __IntPtr color, int color_stride, float* uv, int uv_stride, int num_vertices, __IntPtr indices, int num_indices, int size_indices);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_RenderGeometryRawFloat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int RenderGeometryRawFloat(__IntPtr renderer, __IntPtr texture, float* xy, int xy_stride, __IntPtr color, int color_stride, float* uv, int uv_stride, int num_vertices, __IntPtr indices, int num_indices, int size_indices);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_RenderReadPixels", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr RenderReadPixels(__IntPtr renderer, __IntPtr rect);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_RenderPresent", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int RenderPresent(__IntPtr renderer);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_DestroyTexture", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void DestroyTexture(__IntPtr texture);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_DestroyRenderer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void DestroyRenderer(__IntPtr renderer);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_FlushRenderer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int FlushRenderer(__IntPtr renderer);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetRenderMetalLayer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetRenderMetalLayer(__IntPtr renderer);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetRenderMetalCommandEncoder", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetRenderMetalCommandEncoder(__IntPtr renderer);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_AddVulkanRenderSemaphores", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int AddVulkanRenderSemaphores(__IntPtr renderer, uint wait_stage_mask, long wait_semaphore, long signal_semaphore);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetRenderVSync", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetRenderVSync(__IntPtr renderer, int vsync);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetRenderVSync", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetRenderVSync(__IntPtr renderer, int* vsync);
        }

        /// <summary>Get the number of 2D rendering drivers available for the current display.</summary>
        /// <remarks>
        /// <para>A render driver is a set of code that handles rendering and texture</para>
        /// <para>management on a particular display. Normally there is only one, but some</para>
        /// <para>drivers may have several available with different capabilities.</para>
        /// <para>There may be none if SDL was compiled without render support.</para>
        /// <para>a number &gt;= 0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateRenderer</para>
        /// <para>SDL_GetRenderDriver</para>
        /// </remarks>
        public static int GetNumRenderDrivers()
        {
            var ___ret = __Internal.GetNumRenderDrivers();
            return ___ret;
        }

        /// <summary>Use this function to get the name of a built in 2D rendering driver.</summary>
        /// <param name="index">
        /// <para>the index of the rendering driver; the value ranges from 0 to</para>
        /// <para>SDL_GetNumRenderDrivers() - 1</para>
        /// </param>
        /// <remarks>
        /// <para>The list of rendering drivers is given in the order that they are normally</para>
        /// <para>initialized by default; the drivers that seem more reasonable to choose</para>
        /// <para>first (as far as the SDL developers believe) are earlier in the list.</para>
        /// <para>The names of drivers are all simple, low-ASCII identifiers, like &quot;opengl&quot;,</para>
        /// <para>&quot;direct3d12&quot; or &quot;metal&quot;. These never have Unicode characters, and are not</para>
        /// <para>meant to be proper names.</para>
        /// <para>The returned value points to a static, read-only string; do not modify or</para>
        /// <para>free it!</para>
        /// <para>the name of the rendering driver at the requested index, or NULL</para>
        /// <para>if an invalid index was specified.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetNumRenderDrivers</para>
        /// </remarks>
        public static string GetRenderDriver(int index)
        {
            var ___ret = __Internal.GetRenderDriver(index);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Create a window and default renderer.</summary>
        /// <param name="width">the width of the window</param>
        /// <param name="height">the height of the window</param>
        /// <param name="window_flags">
        /// <para>the flags used to create the window (see</para>
        /// <para>SDL_CreateWindow())</para>
        /// </param>
        /// <param name="window">a pointer filled with the window, or NULL on error</param>
        /// <param name="renderer">a pointer filled with the renderer, or NULL on error</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateRenderer</para>
        /// <para>SDL_CreateWindow</para>
        /// </remarks>
        public static int CreateWindowAndRenderer(int width, int height, global::SDL3Sharp.WindowFlags window_flags, global::SDL3Sharp.Window window, global::SDL3Sharp.Renderer renderer)
        {
            var ____arg3 = window is null ? __IntPtr.Zero : window.__Instance;
            var __arg3 = new __IntPtr(&____arg3);
            var ____arg4 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            var __arg4 = new __IntPtr(&____arg4);
            var ___ret = __Internal.CreateWindowAndRenderer(width, height, window_flags, __arg3, __arg4);
            return ___ret;
        }

        /// <summary>Create a 2D rendering context for a window.</summary>
        /// <param name="window">the window where rendering is displayed</param>
        /// <param name="name">
        /// <para>the name of the rendering driver to initialize, or NULL to</para>
        /// <para>initialize the first one supporting the requested flags</para>
        /// </param>
        /// <param name="flags">0, or one or more SDL_RendererFlags OR'd together</param>
        /// <remarks>
        /// <para>If you want a specific renderer, you can specify its name here. A list of</para>
        /// <para>available renderers can be obtained by calling SDL_GetRenderDriver multiple</para>
        /// <para>times, with indices from 0 to SDL_GetNumRenderDrivers()-1. If you don't</para>
        /// <para>need a specific renderer, specify NULL and SDL will attempt to choose the</para>
        /// <para>best option for you, based on what is available on the user's system.</para>
        /// <para>If you pass SDL_RENDERER_SOFTWARE in the flags, you will get a software</para>
        /// <para>renderer, otherwise you will get a hardware accelerated renderer if</para>
        /// <para>available.</para>
        /// <para>By default the rendering size matches the window size in pixels, but you</para>
        /// <para>can call SDL_SetRenderLogicalPresentation() to change the content size and</para>
        /// <para>scaling options.</para>
        /// <para>a valid rendering context or NULL if there was an error; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateRendererWithProperties</para>
        /// <para>SDL_CreateSoftwareRenderer</para>
        /// <para>SDL_DestroyRenderer</para>
        /// <para>SDL_GetNumRenderDrivers</para>
        /// <para>SDL_GetRenderDriver</para>
        /// <para>SDL_GetRendererInfo</para>
        /// </remarks>
        public static global::SDL3Sharp.Renderer CreateRenderer(global::SDL3Sharp.Window window, string name, uint flags)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.CreateRenderer(__arg0, name, flags);
            var __result0 = global::SDL3Sharp.Renderer.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Create a 2D rendering context for a window, with the specified properties.</summary>
        /// <param name="props">the properties to use</param>
        /// <remarks>
        /// <para>These are the supported properties:</para>
        /// <para>- `SDL_PROP_RENDERER_CREATE_NAME_STRING`: the name of the rendering driver</para>
        /// <para>to use, if a specific one is desired</para>
        /// <para>- `SDL_PROP_RENDERER_CREATE_WINDOW_POINTER`: the window where rendering is</para>
        /// <para>displayed, required if this isn't a software renderer using a surface</para>
        /// <para>- `SDL_PROP_RENDERER_CREATE_SURFACE_POINTER`: the surface where rendering</para>
        /// <para>is displayed, if you want a software renderer without a window</para>
        /// <para>- `SDL_PROP_RENDERER_CREATE_OUTPUT_COLORSPACE_NUMBER`: an SDL_ColorSpace</para>
        /// <para>value describing the colorspace for output to the display, defaults to</para>
        /// <para>SDL_COLORSPACE_SRGB. The direct3d11, direct3d12, and metal renderers</para>
        /// <para>support SDL_COLORSPACE_SRGB_LINEAR, which is a linear color space and</para>
        /// <para>supports HDR output. If you select SDL_COLORSPACE_SRGB_LINEAR, drawing</para>
        /// <para>still uses the sRGB colorspace, but values can go beyond 1.0 and float</para>
        /// <para>(linear) format textures can be used for HDR content.</para>
        /// <para>- `SDL_PROP_RENDERER_CREATE_PRESENT_VSYNC_BOOLEAN`: true if you want</para>
        /// <para>present synchronized with the refresh rate</para>
        /// <para>With the vulkan renderer:</para>
        /// <para>- `SDL_PROP_RENDERER_CREATE_VULKAN_INSTANCE_POINTER`: the VkInstance to use</para>
        /// <para>with the renderer, optional.</para>
        /// <para>- `SDL_PROP_RENDERER_CREATE_VULKAN_SURFACE_NUMBER`: the VkSurfaceKHR to use</para>
        /// <para>with the renderer, optional.</para>
        /// <para>- `SDL_PROP_RENDERER_CREATE_VULKAN_PHYSICAL_DEVICE_POINTER`: the</para>
        /// <para>VkPhysicalDevice to use with the renderer, optional.</para>
        /// <para>- `SDL_PROP_RENDERER_CREATE_VULKAN_DEVICE_POINTER`: the VkDevice to use</para>
        /// <para>with the renderer, optional.</para>
        /// <para>- `SDL_PROP_RENDERER_CREATE_VULKAN_GRAPHICS_QUEUE_FAMILY_INDEX_NUMBER`: the</para>
        /// <para>queue family index used for rendering.</para>
        /// <para>- `SDL_PROP_RENDERER_CREATE_VULKAN_PRESENT_QUEUE_FAMILY_INDEX_NUMBER`: the</para>
        /// <para>queue family index used for presentation.</para>
        /// <para>a valid rendering context or NULL if there was an error; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateRenderer</para>
        /// <para>SDL_CreateSoftwareRenderer</para>
        /// <para>SDL_DestroyRenderer</para>
        /// <para>SDL_GetRendererInfo</para>
        /// </remarks>
        public static global::SDL3Sharp.Renderer CreateRendererWithProperties(uint props)
        {
            var ___ret = __Internal.CreateRendererWithProperties(props);
            var __result0 = global::SDL3Sharp.Renderer.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Create a 2D software rendering context for a surface.</summary>
        /// <param name="surface">
        /// <para>the SDL_Surface structure representing the surface where</para>
        /// <para>rendering is done</para>
        /// </param>
        /// <remarks>
        /// <para>Two other API which can be used to create SDL_Renderer:</para>
        /// <para>SDL_CreateRenderer() and SDL_CreateWindowAndRenderer(). These can _also_</para>
        /// <para>create a software renderer, but they are intended to be used with an</para>
        /// <para>SDL_Window as the final destination and not an SDL_Surface.</para>
        /// <para>a valid rendering context or NULL if there was an error; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateRenderer</para>
        /// <para>SDL_CreateWindowRenderer</para>
        /// <para>SDL_DestroyRenderer</para>
        /// </remarks>
        public static global::SDL3Sharp.Renderer CreateSoftwareRenderer(global::SDL3Sharp.Surface surface)
        {
            var __arg0 = surface is null ? __IntPtr.Zero : surface.__Instance;
            var ___ret = __Internal.CreateSoftwareRenderer(__arg0);
            var __result0 = global::SDL3Sharp.Renderer.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the renderer associated with a window.</summary>
        /// <param name="window">the window to query</param>
        /// <remarks>
        /// <para>the rendering context on success or NULL on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateRenderer</para>
        /// </remarks>
        public static global::SDL3Sharp.Renderer GetRenderer(global::SDL3Sharp.Window window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var ___ret = __Internal.GetRenderer(__arg0);
            var __result0 = global::SDL3Sharp.Renderer.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the window associated with a renderer.</summary>
        /// <param name="renderer">the renderer to query</param>
        /// <remarks>
        /// <para>the window on success or NULL on failure; call SDL_GetError() for</para>
        /// <para>more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static global::SDL3Sharp.Window GetRenderWindow(global::SDL3Sharp.Renderer renderer)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            var ___ret = __Internal.GetRenderWindow(__arg0);
            var __result0 = global::SDL3Sharp.Window.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get information about a rendering context.</summary>
        /// <param name="renderer">the rendering context</param>
        /// <param name="info">
        /// <para>an SDL_RendererInfo structure filled with information about the</para>
        /// <para>current renderer</para>
        /// </param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateRenderer</para>
        /// </remarks>
        public static int GetRendererInfo(global::SDL3Sharp.Renderer renderer, global::SDL3Sharp.RendererInfo info)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            var __arg1 = info is null ? __IntPtr.Zero : info.__Instance;
            var ___ret = __Internal.GetRendererInfo(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Get the properties associated with a renderer.</summary>
        /// <param name="renderer">the rendering context</param>
        /// <remarks>
        /// <para>The following read-only properties are provided by SDL:</para>
        /// <para>- `SDL_PROP_RENDERER_NAME_STRING`: the name of the rendering driver</para>
        /// <para>- `SDL_PROP_RENDERER_WINDOW_POINTER`: the window where rendering is</para>
        /// <para>displayed, if any</para>
        /// <para>- `SDL_PROP_RENDERER_SURFACE_POINTER`: the surface where rendering is</para>
        /// <para>displayed, if this is a software renderer without a window</para>
        /// <para>- `SDL_PROP_RENDERER_OUTPUT_COLORSPACE_NUMBER`: an SDL_ColorSpace value</para>
        /// <para>describing the colorspace for output to the display, defaults to</para>
        /// <para>SDL_COLORSPACE_SRGB.</para>
        /// <para>- `SDL_PROP_RENDERER_HDR_ENABLED_BOOLEAN`: true if the output colorspace is</para>
        /// <para>SDL_COLORSPACE_SRGB_LINEAR and the renderer is showing on a display with</para>
        /// <para>HDR enabled. This property can change dynamically when</para>
        /// <para>SDL_EVENT_DISPLAY_HDR_STATE_CHANGED is sent.</para>
        /// <para>- `SDL_PROP_RENDERER_SDR_WHITE_POINT_FLOAT`: the value of SDR white in the</para>
        /// <para>SDL_COLORSPACE_SRGB_LINEAR colorspace. When HDR is enabled, this value is</para>
        /// <para>automatically multiplied into the color scale. This property can change</para>
        /// <para>dynamically when SDL_EVENT_DISPLAY_HDR_STATE_CHANGED is sent.</para>
        /// <para>- `SDL_PROP_RENDERER_HDR_HEADROOM_FLOAT`: the additional high dynamic range</para>
        /// <para>that can be displayed, in terms of the SDR white point. When HDR is not</para>
        /// <para>enabled, this will be 1.0. This property can change dynamically when</para>
        /// <para>SDL_EVENT_DISPLAY_HDR_STATE_CHANGED is sent.</para>
        /// <para>With the direct3d renderer:</para>
        /// <para>- `SDL_PROP_RENDERER_D3D9_DEVICE_POINTER`: the IDirect3DDevice9 associated</para>
        /// <para>with the renderer</para>
        /// <para>With the direct3d11 renderer:</para>
        /// <para>- `SDL_PROP_RENDERER_D3D11_DEVICE_POINTER`: the ID3D11Device associated</para>
        /// <para>with the renderer</para>
        /// <para>With the direct3d12 renderer:</para>
        /// <para>- `SDL_PROP_RENDERER_D3D12_DEVICE_POINTER`: the ID3D12Device associated</para>
        /// <para>with the renderer</para>
        /// <para>- `SDL_PROP_RENDERER_D3D12_COMMAND_QUEUE_POINTER`: the ID3D12CommandQueue</para>
        /// <para>associated with the renderer</para>
        /// <para>With the vulkan renderer:</para>
        /// <para>- `SDL_PROP_RENDERER_VULKAN_INSTANCE_POINTER`: the VkInstance associated</para>
        /// <para>with the renderer</para>
        /// <para>- `SDL_PROP_RENDERER_VULKAN_SURFACE_NUMBER`: the VkSurfaceKHR associated</para>
        /// <para>with the renderer</para>
        /// <para>- `SDL_PROP_RENDERER_VULKAN_PHYSICAL_DEVICE_POINTER`: the VkPhysicalDevice</para>
        /// <para>associated with the renderer</para>
        /// <para>- `SDL_PROP_RENDERER_VULKAN_DEVICE_POINTER`: the VkDevice associated with</para>
        /// <para>the renderer</para>
        /// <para>- `SDL_PROP_RENDERER_VULKAN_GRAPHICS_QUEUE_FAMILY_INDEX_NUMBER`: the queue</para>
        /// <para>family index used for rendering</para>
        /// <para>- `SDL_PROP_RENDERER_VULKAN_PRESENT_QUEUE_FAMILY_INDEX_NUMBER`: the queue</para>
        /// <para>family index used for presentation</para>
        /// <para>- `SDL_PROP_RENDERER_VULKAN_SWAPCHAIN_IMAGE_COUNT_NUMBER`: the number of</para>
        /// <para>swapchain images, or potential frames in flight, used by the Vulkan</para>
        /// <para>renderer</para>
        /// <para>a valid property ID on success or 0 on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetProperty</para>
        /// <para>SDL_SetProperty</para>
        /// </remarks>
        public static uint GetRendererProperties(global::SDL3Sharp.Renderer renderer)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            var ___ret = __Internal.GetRendererProperties(__arg0);
            return ___ret;
        }

        /// <summary>Get the output size in pixels of a rendering context.</summary>
        /// <param name="renderer">the rendering context</param>
        /// <param name="w">a pointer filled in with the width in pixels</param>
        /// <param name="h">a pointer filled in with the height in pixels</param>
        /// <remarks>
        /// <para>This returns the true output size in pixels, ignoring any render targets or</para>
        /// <para>logical size and presentation.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetRenderer</para>
        /// </remarks>
        public static int GetRenderOutputSize(global::SDL3Sharp.Renderer renderer, ref int w, ref int h)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            fixed (int* __w1 = &w)
            {
                var __arg1 = __w1;
                fixed (int* __h2 = &h)
                {
                    var __arg2 = __h2;
                    var ___ret = __Internal.GetRenderOutputSize(__arg0, __arg1, __arg2);
                    return ___ret;
                }
            }
        }

        /// <summary>Get the current output size in pixels of a rendering context.</summary>
        /// <param name="renderer">the rendering context</param>
        /// <param name="w">a pointer filled in with the current width</param>
        /// <param name="h">a pointer filled in with the current height</param>
        /// <remarks>
        /// <para>If a rendering target is active, this will return the size of the rendering</para>
        /// <para>target in pixels, otherwise if a logical size is set, it will return the</para>
        /// <para>logical size, otherwise it will return the value of</para>
        /// <para>SDL_GetRenderOutputSize().</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetRenderOutputSize</para>
        /// <para>SDL_GetRenderer</para>
        /// </remarks>
        public static int GetCurrentRenderOutputSize(global::SDL3Sharp.Renderer renderer, ref int w, ref int h)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            fixed (int* __w1 = &w)
            {
                var __arg1 = __w1;
                fixed (int* __h2 = &h)
                {
                    var __arg2 = __h2;
                    var ___ret = __Internal.GetCurrentRenderOutputSize(__arg0, __arg1, __arg2);
                    return ___ret;
                }
            }
        }

        /// <summary>Create a texture for a rendering context.</summary>
        /// <param name="renderer">the rendering context</param>
        /// <param name="format">one of the enumerated values in SDL_PixelFormatEnum</param>
        /// <param name="access">one of the enumerated values in SDL_TextureAccess</param>
        /// <param name="w">the width of the texture in pixels</param>
        /// <param name="h">the height of the texture in pixels</param>
        /// <remarks>
        /// <para>You can set the texture scaling method by setting</para>
        /// <para>`SDL_HINT_RENDER_SCALE_QUALITY` before creating the texture.</para>
        /// <para>a pointer to the created texture or NULL if no rendering context</para>
        /// <para>was active, the format was unsupported, or the width or height</para>
        /// <para>were out of range; call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateTextureFromSurface</para>
        /// <para>SDL_CreateTextureWithProperties</para>
        /// <para>SDL_DestroyTexture</para>
        /// <para>SDL_QueryTexture</para>
        /// <para>SDL_UpdateTexture</para>
        /// </remarks>
        public static global::SDL3Sharp.Texture CreateTexture(global::SDL3Sharp.Renderer renderer, uint format, int access, int w, int h)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            var ___ret = __Internal.CreateTexture(__arg0, format, access, w, h);
            var __result0 = global::SDL3Sharp.Texture.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Create a texture from an existing surface.</summary>
        /// <param name="renderer">the rendering context</param>
        /// <param name="surface">
        /// <para>the SDL_Surface structure containing pixel data used to fill</para>
        /// <para>the texture</para>
        /// </param>
        /// <remarks>
        /// <para>The surface is not modified or freed by this function.</para>
        /// <para>The SDL_TextureAccess hint for the created texture is</para>
        /// <para>`SDL_TEXTUREACCESS_STATIC`.</para>
        /// <para>The pixel format of the created texture may be different from the pixel</para>
        /// <para>format of the surface. Use SDL_QueryTexture() to query the pixel format of</para>
        /// <para>the texture.</para>
        /// <para>the created texture or NULL on failure; call SDL_GetError() for</para>
        /// <para>more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateTexture</para>
        /// <para>SDL_CreateTextureWithProperties</para>
        /// <para>SDL_DestroyTexture</para>
        /// <para>SDL_QueryTexture</para>
        /// </remarks>
        public static global::SDL3Sharp.Texture CreateTextureFromSurface(global::SDL3Sharp.Renderer renderer, global::SDL3Sharp.Surface surface)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            var __arg1 = surface is null ? __IntPtr.Zero : surface.__Instance;
            var ___ret = __Internal.CreateTextureFromSurface(__arg0, __arg1);
            var __result0 = global::SDL3Sharp.Texture.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Create a texture for a rendering context with the specified properties.</summary>
        /// <param name="renderer">the rendering context</param>
        /// <param name="props">the properties to use</param>
        /// <remarks>
        /// <para>These are the supported properties:</para>
        /// <para>- `SDL_PROP_TEXTURE_CREATE_COLORSPACE_NUMBER`: an SDL_ColorSpace value</para>
        /// <para>describing the texture colorspace, defaults to SDL_COLORSPACE_SRGB_LINEAR</para>
        /// <para>for floating point textures, SDL_COLORSPACE_HDR10 for 10-bit textures,</para>
        /// <para>SDL_COLORSPACE_SRGB for other RGB textures and SDL_COLORSPACE_JPEG for</para>
        /// <para>YUV textures.</para>
        /// <para>- `SDL_PROP_TEXTURE_CREATE_FORMAT_NUMBER`: one of the enumerated values in</para>
        /// <para>SDL_PixelFormatEnum, defaults to the best RGBA format for the renderer</para>
        /// <para>- `SDL_PROP_TEXTURE_CREATE_ACCESS_NUMBER`: one of the enumerated values in</para>
        /// <para>SDL_TextureAccess, defaults to SDL_TEXTUREACCESS_STATIC</para>
        /// <para>- `SDL_PROP_TEXTURE_CREATE_WIDTH_NUMBER`: the width of the texture in</para>
        /// <para>pixels, required</para>
        /// <para>- `SDL_PROP_TEXTURE_CREATE_HEIGHT_NUMBER`: the height of the texture in</para>
        /// <para>pixels, required</para>
        /// <para>- `SDL_PROP_TEXTURE_CREATE_SDR_WHITE_POINT_FLOAT`: for HDR10 and floating</para>
        /// <para>point textures, this defines the value of 100% diffuse white, with higher</para>
        /// <para>values being displayed in the High Dynamic Range headroom. This defaults</para>
        /// <para>to 100 for HDR10 textures and 1.0 for floating point textures.</para>
        /// <para>- `SDL_PROP_TEXTURE_CREATE_HDR_HEADROOM_FLOAT`: for HDR10 and floating</para>
        /// <para>point textures, this defines the maximum dynamic range used by the</para>
        /// <para>content, in terms of the SDR white point. This would be equivalent to</para>
        /// <para>maxCLL / SDL_PROP_TEXTURE_CREATE_SDR_WHITE_POINT_FLOAT for HDR10 content.</para>
        /// <para>If this is defined, any values outside the range supported by the display</para>
        /// <para>will be scaled into the available HDR headroom, otherwise they are</para>
        /// <para>clipped.</para>
        /// <para>With the direct3d11 renderer:</para>
        /// <para>- `SDL_PROP_TEXTURE_CREATE_D3D11_TEXTURE_POINTER`: the ID3D11Texture2D</para>
        /// <para>associated with the texture, if you want to wrap an existing texture.</para>
        /// <para>- `SDL_PROP_TEXTURE_CREATE_D3D11_TEXTURE_U_POINTER`: the ID3D11Texture2D</para>
        /// <para>associated with the U plane of a YUV texture, if you want to wrap an</para>
        /// <para>existing texture.</para>
        /// <para>- `SDL_PROP_TEXTURE_CREATE_D3D11_TEXTURE_V_POINTER`: the ID3D11Texture2D</para>
        /// <para>associated with the V plane of a YUV texture, if you want to wrap an</para>
        /// <para>existing texture.</para>
        /// <para>With the direct3d12 renderer:</para>
        /// <para>- `SDL_PROP_TEXTURE_CREATE_D3D12_TEXTURE_POINTER`: the ID3D12Resource</para>
        /// <para>associated with the texture, if you want to wrap an existing texture.</para>
        /// <para>- `SDL_PROP_TEXTURE_CREATE_D3D12_TEXTURE_U_POINTER`: the ID3D12Resource</para>
        /// <para>associated with the U plane of a YUV texture, if you want to wrap an</para>
        /// <para>existing texture.</para>
        /// <para>- `SDL_PROP_TEXTURE_CREATE_D3D12_TEXTURE_V_POINTER`: the ID3D12Resource</para>
        /// <para>associated with the V plane of a YUV texture, if you want to wrap an</para>
        /// <para>existing texture.</para>
        /// <para>With the metal renderer:</para>
        /// <para>- `SDL_PROP_TEXTURE_CREATE_METAL_PIXELBUFFER_POINTER`: the CVPixelBufferRef</para>
        /// <para>associated with the texture, if you want to create a texture from an</para>
        /// <para>existing pixel buffer.</para>
        /// <para>With the opengl renderer:</para>
        /// <para>- `SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_NUMBER`: the GLuint texture</para>
        /// <para>associated with the texture, if you want to wrap an existing texture.</para>
        /// <para>- `SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_UV_NUMBER`: the GLuint texture</para>
        /// <para>associated with the UV plane of an NV12 texture, if you want to wrap an</para>
        /// <para>existing texture.</para>
        /// <para>- `SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_U_NUMBER`: the GLuint texture</para>
        /// <para>associated with the U plane of a YUV texture, if you want to wrap an</para>
        /// <para>existing texture.</para>
        /// <para>- `SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_V_NUMBER`: the GLuint texture</para>
        /// <para>associated with the V plane of a YUV texture, if you want to wrap an</para>
        /// <para>existing texture.</para>
        /// <para>With the opengles2 renderer:</para>
        /// <para>- `SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_NUMBER`: the GLuint texture</para>
        /// <para>associated with the texture, if you want to wrap an existing texture.</para>
        /// <para>- `SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_NUMBER`: the GLuint texture</para>
        /// <para>associated with the texture, if you want to wrap an existing texture.</para>
        /// <para>- `SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_UV_NUMBER`: the GLuint texture</para>
        /// <para>associated with the UV plane of an NV12 texture, if you want to wrap an</para>
        /// <para>existing texture.</para>
        /// <para>- `SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_U_NUMBER`: the GLuint texture</para>
        /// <para>associated with the U plane of a YUV texture, if you want to wrap an</para>
        /// <para>existing texture.</para>
        /// <para>- `SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_V_NUMBER`: the GLuint texture</para>
        /// <para>associated with the V plane of a YUV texture, if you want to wrap an</para>
        /// <para>existing texture.</para>
        /// <para>With the vulkan renderer:</para>
        /// <para>- `SDL_PROP_TEXTURE_CREATE_VULKAN_TEXTURE_NUMBER`: the VkImage with layout</para>
        /// <para>VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL associated with the texture, if</para>
        /// <para>you want to wrap an existing texture.</para>
        /// <para>a pointer to the created texture or NULL if no rendering context</para>
        /// <para>was active, the format was unsupported, or the width or height</para>
        /// <para>were out of range; call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateTextureFromSurface</para>
        /// <para>SDL_CreateTexture</para>
        /// <para>SDL_DestroyTexture</para>
        /// <para>SDL_QueryTexture</para>
        /// <para>SDL_UpdateTexture</para>
        /// </remarks>
        public static global::SDL3Sharp.Texture CreateTextureWithProperties(global::SDL3Sharp.Renderer renderer, uint props)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            var ___ret = __Internal.CreateTextureWithProperties(__arg0, props);
            var __result0 = global::SDL3Sharp.Texture.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the properties associated with a texture.</summary>
        /// <param name="texture">the texture to query</param>
        /// <remarks>
        /// <para>The following read-only properties are provided by SDL:</para>
        /// <para>- `SDL_PROP_TEXTURE_COLORSPACE_NUMBER`: an SDL_ColorSpace value describing</para>
        /// <para>the colorspace used by the texture</para>
        /// <para>- `SDL_PROP_TEXTURE_SDR_WHITE_POINT_FLOAT`: for HDR10 and floating point</para>
        /// <para>textures, this defines the value of 100% diffuse white, with higher</para>
        /// <para>values being displayed in the High Dynamic Range headroom. This defaults</para>
        /// <para>to 100 for HDR10 textures and 1.0 for other textures.</para>
        /// <para>- `SDL_PROP_TEXTURE_HDR_HEADROOM_FLOAT`: for HDR10 and floating point</para>
        /// <para>textures, this defines the maximum dynamic range used by the content, in</para>
        /// <para>terms of the SDR white point. If this is defined, any values outside the</para>
        /// <para>range supported by the display will be scaled into the available HDR</para>
        /// <para>headroom, otherwise they are clipped. This defaults to 1.0 for SDR</para>
        /// <para>textures, 4.0 for HDR10 textures, and no default for floating point</para>
        /// <para>textures.</para>
        /// <para>With the direct3d11 renderer:</para>
        /// <para>- `SDL_PROP_TEXTURE_D3D11_TEXTURE_POINTER`: the ID3D11Texture2D associated</para>
        /// <para>with the texture</para>
        /// <para>- `SDL_PROP_TEXTURE_D3D11_TEXTURE_U_POINTER`: the ID3D11Texture2D</para>
        /// <para>associated with the U plane of a YUV texture</para>
        /// <para>- `SDL_PROP_TEXTURE_D3D11_TEXTURE_V_POINTER`: the ID3D11Texture2D</para>
        /// <para>associated with the V plane of a YUV texture</para>
        /// <para>With the direct3d12 renderer:</para>
        /// <para>- `SDL_PROP_TEXTURE_D3D12_TEXTURE_POINTER`: the ID3D12Resource associated</para>
        /// <para>with the texture</para>
        /// <para>- `SDL_PROP_TEXTURE_D3D12_TEXTURE_U_POINTER`: the ID3D12Resource associated</para>
        /// <para>with the U plane of a YUV texture</para>
        /// <para>- `SDL_PROP_TEXTURE_D3D12_TEXTURE_V_POINTER`: the ID3D12Resource associated</para>
        /// <para>with the V plane of a YUV texture</para>
        /// <para>With the vulkan renderer:</para>
        /// <para>- `SDL_PROP_TEXTURE_VULKAN_TEXTURE_POINTER`: the VkImage associated with</para>
        /// <para>the texture</para>
        /// <para>- `SDL_PROP_TEXTURE_VULKAN_TEXTURE_U_POINTER`: the VkImage associated with</para>
        /// <para>the U plane of a YUV texture</para>
        /// <para>- `SDL_PROP_TEXTURE_VULKAN_TEXTURE_V_POINTER`: the VkImage associated with</para>
        /// <para>the V plane of a YUV texture</para>
        /// <para>- `SDL_PROP_TEXTURE_VULKAN_TEXTURE_UV_POINTER`: the VkImage associated with</para>
        /// <para>the UV plane of a NV12/NV21 texture</para>
        /// <para>With the opengl renderer:</para>
        /// <para>- `SDL_PROP_TEXTURE_OPENGL_TEXTURE_NUMBER`: the GLuint texture associated</para>
        /// <para>with the texture</para>
        /// <para>- `SDL_PROP_TEXTURE_OPENGL_TEXTURE_UV_NUMBER`: the GLuint texture</para>
        /// <para>associated with the UV plane of an NV12 texture</para>
        /// <para>- `SDL_PROP_TEXTURE_OPENGL_TEXTURE_U_NUMBER`: the GLuint texture associated</para>
        /// <para>with the U plane of a YUV texture</para>
        /// <para>- `SDL_PROP_TEXTURE_OPENGL_TEXTURE_V_NUMBER`: the GLuint texture associated</para>
        /// <para>with the V plane of a YUV texture</para>
        /// <para>- `SDL_PROP_TEXTURE_OPENGL_TEXTURE_TARGET_NUMBER`: the GLenum for the</para>
        /// <para>texture target (`GL_TEXTURE_2D`, `GL_TEXTURE_RECTANGLE_ARB`, etc)</para>
        /// <para>- `SDL_PROP_TEXTURE_OPENGL_TEX_W_FLOAT`: the texture coordinate width of</para>
        /// <para>the texture (0.0 - 1.0)</para>
        /// <para>- `SDL_PROP_TEXTURE_OPENGL_TEX_H_FLOAT`: the texture coordinate height of</para>
        /// <para>the texture (0.0 - 1.0)</para>
        /// <para>With the opengles2 renderer:</para>
        /// <para>- `SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_NUMBER`: the GLuint texture</para>
        /// <para>associated with the texture</para>
        /// <para>- `SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_UV_NUMBER`: the GLuint texture</para>
        /// <para>associated with the UV plane of an NV12 texture</para>
        /// <para>- `SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_U_NUMBER`: the GLuint texture</para>
        /// <para>associated with the U plane of a YUV texture</para>
        /// <para>- `SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_V_NUMBER`: the GLuint texture</para>
        /// <para>associated with the V plane of a YUV texture</para>
        /// <para>- `SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_TARGET_NUMBER`: the GLenum for the</para>
        /// <para>texture target (`GL_TEXTURE_2D`, `GL_TEXTURE_EXTERNAL_OES`, etc)</para>
        /// <para>With the vulkan renderer:</para>
        /// <para>- `SDL_PROP_TEXTURE_VULKAN_TEXTURE_NUMBER`: the VkImage associated with the</para>
        /// <para>texture</para>
        /// <para>a valid property ID on success or 0 on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetProperty</para>
        /// <para>SDL_SetProperty</para>
        /// </remarks>
        public static uint GetTextureProperties(global::SDL3Sharp.Texture texture)
        {
            var __arg0 = texture is null ? __IntPtr.Zero : texture.__Instance;
            var ___ret = __Internal.GetTextureProperties(__arg0);
            return ___ret;
        }

        /// <summary>Get the renderer that created an SDL_Texture.</summary>
        /// <param name="texture">the texture to query</param>
        /// <remarks>
        /// <para>a pointer to the SDL_Renderer that created the texture, or NULL on</para>
        /// <para>failure; call SDL_GetError() for more information.</para>
        /// <para>It is safe to call this function from any thread.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateTexture</para>
        /// <para>SDL_CreateTextureFromSurface</para>
        /// <para>SDL_CreateTextureWithProperties</para>
        /// </remarks>
        public static global::SDL3Sharp.Renderer GetRendererFromTexture(global::SDL3Sharp.Texture texture)
        {
            var __arg0 = texture is null ? __IntPtr.Zero : texture.__Instance;
            var ___ret = __Internal.GetRendererFromTexture(__arg0);
            var __result0 = global::SDL3Sharp.Renderer.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Query the attributes of a texture.</summary>
        /// <param name="texture">the texture to query</param>
        /// <param name="format">
        /// <para>a pointer filled in with the raw format of the texture; the</para>
        /// <para>actual format may differ, but pixel transfers will use this</para>
        /// <para>format (one of the SDL_PixelFormatEnum values). This argument</para>
        /// <para>can be NULL if you don't need this information.</para>
        /// </param>
        /// <param name="access">
        /// <para>a pointer filled in with the actual access to the texture</para>
        /// <para>(one of the SDL_TextureAccess values). This argument can be</para>
        /// <para>NULL if you don't need this information.</para>
        /// </param>
        /// <param name="w">
        /// <para>a pointer filled in with the width of the texture in pixels. This</para>
        /// <para>argument can be NULL if you don't need this information.</para>
        /// </param>
        /// <param name="h">
        /// <para>a pointer filled in with the height of the texture in pixels. This</para>
        /// <para>argument can be NULL if you don't need this information.</para>
        /// </param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateTexture</para>
        /// </remarks>
        public static int QueryTexture(global::SDL3Sharp.Texture texture, ref uint format, ref int access, ref int w, ref int h)
        {
            var __arg0 = texture is null ? __IntPtr.Zero : texture.__Instance;
            fixed (uint* __format1 = &format)
            {
                var __arg1 = __format1;
                fixed (int* __access2 = &access)
                {
                    var __arg2 = __access2;
                    fixed (int* __w3 = &w)
                    {
                        var __arg3 = __w3;
                        fixed (int* __h4 = &h)
                        {
                            var __arg4 = __h4;
                            var ___ret = __Internal.QueryTexture(__arg0, __arg1, __arg2, __arg3, __arg4);
                            return ___ret;
                        }
                    }
                }
            }
        }

        /// <summary>Set an additional color value multiplied into render copy operations.</summary>
        /// <param name="texture">the texture to update</param>
        /// <param name="r">the red color value multiplied into copy operations</param>
        /// <param name="g">the green color value multiplied into copy operations</param>
        /// <param name="b">the blue color value multiplied into copy operations</param>
        /// <remarks>
        /// <para>When this texture is rendered, during the copy operation each source color</para>
        /// <para>channel is modulated by the appropriate color value according to the</para>
        /// <para>following formula:</para>
        /// <para>`srcC = srcC * (color / 255)`</para>
        /// <para>Color modulation is not always supported by the renderer; it will return -1</para>
        /// <para>if color modulation is not supported.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetTextureColorMod</para>
        /// <para>SDL_SetTextureAlphaMod</para>
        /// <para>SDL_SetTextureColorModFloat</para>
        /// </remarks>
        public static int SetTextureColorMod(global::SDL3Sharp.Texture texture, byte r, byte g, byte b)
        {
            var __arg0 = texture is null ? __IntPtr.Zero : texture.__Instance;
            var ___ret = __Internal.SetTextureColorMod(__arg0, r, g, b);
            return ___ret;
        }

        /// <summary>Set an additional color value multiplied into render copy operations.</summary>
        /// <param name="texture">the texture to update</param>
        /// <param name="r">the red color value multiplied into copy operations</param>
        /// <param name="g">the green color value multiplied into copy operations</param>
        /// <param name="b">the blue color value multiplied into copy operations</param>
        /// <remarks>
        /// <para>When this texture is rendered, during the copy operation each source color</para>
        /// <para>channel is modulated by the appropriate color value according to the</para>
        /// <para>following formula:</para>
        /// <para>`srcC = srcC * color`</para>
        /// <para>Color modulation is not always supported by the renderer; it will return -1</para>
        /// <para>if color modulation is not supported.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetTextureColorModFloat</para>
        /// <para>SDL_SetTextureAlphaModFloat</para>
        /// <para>SDL_SetTextureColorMod</para>
        /// </remarks>
        public static int SetTextureColorModFloat(global::SDL3Sharp.Texture texture, float r, float g, float b)
        {
            var __arg0 = texture is null ? __IntPtr.Zero : texture.__Instance;
            var ___ret = __Internal.SetTextureColorModFloat(__arg0, r, g, b);
            return ___ret;
        }

        /// <summary>Get the additional color value multiplied into render copy operations.</summary>
        /// <param name="texture">the texture to query</param>
        /// <param name="r">a pointer filled in with the current red color value</param>
        /// <param name="g">a pointer filled in with the current green color value</param>
        /// <param name="b">a pointer filled in with the current blue color value</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetTextureAlphaMod</para>
        /// <para>SDL_GetTextureColorModFloat</para>
        /// <para>SDL_SetTextureColorMod</para>
        /// </remarks>
        public static int GetTextureColorMod(global::SDL3Sharp.Texture texture, byte* r, byte* g, byte* b)
        {
            var __arg0 = texture is null ? __IntPtr.Zero : texture.__Instance;
            var ___ret = __Internal.GetTextureColorMod(__arg0, r, g, b);
            return ___ret;
        }

        /// <summary>Get the additional color value multiplied into render copy operations.</summary>
        /// <param name="texture">the texture to query</param>
        /// <param name="r">a pointer filled in with the current red color value</param>
        /// <param name="g">a pointer filled in with the current green color value</param>
        /// <param name="b">a pointer filled in with the current blue color value</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetTextureAlphaModFloat</para>
        /// <para>SDL_GetTextureColorMod</para>
        /// <para>SDL_SetTextureColorModFloat</para>
        /// </remarks>
        public static int GetTextureColorModFloat(global::SDL3Sharp.Texture texture, ref float r, ref float g, ref float b)
        {
            var __arg0 = texture is null ? __IntPtr.Zero : texture.__Instance;
            fixed (float* __r1 = &r)
            {
                var __arg1 = __r1;
                fixed (float* __g2 = &g)
                {
                    var __arg2 = __g2;
                    fixed (float* __b3 = &b)
                    {
                        var __arg3 = __b3;
                        var ___ret = __Internal.GetTextureColorModFloat(__arg0, __arg1, __arg2, __arg3);
                        return ___ret;
                    }
                }
            }
        }

        /// <summary>Set an additional alpha value multiplied into render copy operations.</summary>
        /// <param name="texture">the texture to update</param>
        /// <param name="alpha">the source alpha value multiplied into copy operations</param>
        /// <remarks>
        /// <para>When this texture is rendered, during the copy operation the source alpha</para>
        /// <para>value is modulated by this alpha value according to the following formula:</para>
        /// <para>`srcA = srcA * (alpha / 255)`</para>
        /// <para>Alpha modulation is not always supported by the renderer; it will return -1</para>
        /// <para>if alpha modulation is not supported.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetTextureAlphaMod</para>
        /// <para>SDL_SetTextureAlphaModFloat</para>
        /// <para>SDL_SetTextureColorMod</para>
        /// </remarks>
        public static int SetTextureAlphaMod(global::SDL3Sharp.Texture texture, byte alpha)
        {
            var __arg0 = texture is null ? __IntPtr.Zero : texture.__Instance;
            var ___ret = __Internal.SetTextureAlphaMod(__arg0, alpha);
            return ___ret;
        }

        /// <summary>Set an additional alpha value multiplied into render copy operations.</summary>
        /// <param name="texture">the texture to update</param>
        /// <param name="alpha">the source alpha value multiplied into copy operations</param>
        /// <remarks>
        /// <para>When this texture is rendered, during the copy operation the source alpha</para>
        /// <para>value is modulated by this alpha value according to the following formula:</para>
        /// <para>`srcA = srcA * alpha`</para>
        /// <para>Alpha modulation is not always supported by the renderer; it will return -1</para>
        /// <para>if alpha modulation is not supported.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetTextureAlphaModFloat</para>
        /// <para>SDL_SetTextureAlphaMod</para>
        /// <para>SDL_SetTextureColorModFloat</para>
        /// </remarks>
        public static int SetTextureAlphaModFloat(global::SDL3Sharp.Texture texture, float alpha)
        {
            var __arg0 = texture is null ? __IntPtr.Zero : texture.__Instance;
            var ___ret = __Internal.SetTextureAlphaModFloat(__arg0, alpha);
            return ___ret;
        }

        /// <summary>Get the additional alpha value multiplied into render copy operations.</summary>
        /// <param name="texture">the texture to query</param>
        /// <param name="alpha">a pointer filled in with the current alpha value</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetTextureAlphaModFloat</para>
        /// <para>SDL_GetTextureColorMod</para>
        /// <para>SDL_SetTextureAlphaMod</para>
        /// </remarks>
        public static int GetTextureAlphaMod(global::SDL3Sharp.Texture texture, byte* alpha)
        {
            var __arg0 = texture is null ? __IntPtr.Zero : texture.__Instance;
            var ___ret = __Internal.GetTextureAlphaMod(__arg0, alpha);
            return ___ret;
        }

        /// <summary>Get the additional alpha value multiplied into render copy operations.</summary>
        /// <param name="texture">the texture to query</param>
        /// <param name="alpha">a pointer filled in with the current alpha value</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetTextureAlphaMod</para>
        /// <para>SDL_GetTextureColorModFloat</para>
        /// <para>SDL_SetTextureAlphaModFloat</para>
        /// </remarks>
        public static int GetTextureAlphaModFloat(global::SDL3Sharp.Texture texture, ref float alpha)
        {
            var __arg0 = texture is null ? __IntPtr.Zero : texture.__Instance;
            fixed (float* __alpha1 = &alpha)
            {
                var __arg1 = __alpha1;
                var ___ret = __Internal.GetTextureAlphaModFloat(__arg0, __arg1);
                return ___ret;
            }
        }

        /// <summary>Set the blend mode for a texture, used by SDL_RenderTexture().</summary>
        /// <param name="texture">the texture to update</param>
        /// <param name="blendMode">the SDL_BlendMode to use for texture blending</param>
        /// <remarks>
        /// <para>If the blend mode is not supported, the closest supported mode is chosen</para>
        /// <para>and this function returns -1.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetTextureBlendMode</para>
        /// <para>SDL_RenderTexture</para>
        /// </remarks>
        public static int SetTextureBlendMode(global::SDL3Sharp.Texture texture, global::SDL3Sharp.BlendMode blendMode)
        {
            var __arg0 = texture is null ? __IntPtr.Zero : texture.__Instance;
            var ___ret = __Internal.SetTextureBlendMode(__arg0, blendMode);
            return ___ret;
        }

        /// <summary>Get the blend mode used for texture copy operations.</summary>
        /// <param name="texture">the texture to query</param>
        /// <param name="blendMode">a pointer filled in with the current SDL_BlendMode</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_SetTextureBlendMode</para>
        /// </remarks>
        public static int GetTextureBlendMode(global::SDL3Sharp.Texture texture, ref global::SDL3Sharp.BlendMode blendMode)
        {
            var __arg0 = texture is null ? __IntPtr.Zero : texture.__Instance;
            fixed (global::SDL3Sharp.BlendMode* __blendMode1 = &blendMode)
            {
                var __arg1 = __blendMode1;
                var ___ret = __Internal.GetTextureBlendMode(__arg0, __arg1);
                return ___ret;
            }
        }

        /// <summary>Set the scale mode used for texture scale operations.</summary>
        /// <param name="texture">The texture to update.</param>
        /// <param name="scaleMode">the SDL_ScaleMode to use for texture scaling.</param>
        /// <remarks>
        /// <para>The default texture scale mode is SDL_SCALEMODE_LINEAR.</para>
        /// <para>If the scale mode is not supported, the closest supported mode is chosen.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetTextureScaleMode</para>
        /// </remarks>
        public static int SetTextureScaleMode(global::SDL3Sharp.Texture texture, global::SDL3Sharp.ScaleMode scaleMode)
        {
            var __arg0 = texture is null ? __IntPtr.Zero : texture.__Instance;
            var ___ret = __Internal.SetTextureScaleMode(__arg0, scaleMode);
            return ___ret;
        }

        /// <summary>Get the scale mode used for texture scale operations.</summary>
        /// <param name="texture">the texture to query.</param>
        /// <param name="scaleMode">a pointer filled in with the current scale mode.</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_SetTextureScaleMode</para>
        /// </remarks>
        public static int GetTextureScaleMode(global::SDL3Sharp.Texture texture, ref global::SDL3Sharp.ScaleMode scaleMode)
        {
            var __arg0 = texture is null ? __IntPtr.Zero : texture.__Instance;
            fixed (global::SDL3Sharp.ScaleMode* __scaleMode1 = &scaleMode)
            {
                var __arg1 = __scaleMode1;
                var ___ret = __Internal.GetTextureScaleMode(__arg0, __arg1);
                return ___ret;
            }
        }

        /// <summary>Update the given texture rectangle with new pixel data.</summary>
        /// <param name="texture">the texture to update</param>
        /// <param name="rect">
        /// <para>an SDL_Rect structure representing the area to update, or NULL</para>
        /// <para>to update the entire texture</para>
        /// </param>
        /// <param name="pixels">the raw pixel data in the format of the texture</param>
        /// <param name="pitch">
        /// <para>the number of bytes in a row of pixel data, including padding</para>
        /// <para>between lines</para>
        /// </param>
        /// <remarks>
        /// <para>The pixel data must be in the pixel format of the texture. Use</para>
        /// <para>SDL_QueryTexture() to query the pixel format of the texture.</para>
        /// <para>This is a fairly slow function, intended for use with static textures that</para>
        /// <para>do not change often.</para>
        /// <para>If the texture is intended to be updated often, it is preferred to create</para>
        /// <para>the texture as streaming and use the locking functions referenced below.</para>
        /// <para>While this function will work with streaming textures, for optimization</para>
        /// <para>reasons you may not get the pixels back if you lock the texture afterward.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateTexture</para>
        /// <para>SDL_LockTexture</para>
        /// <para>SDL_UnlockTexture</para>
        /// </remarks>
        public static int UpdateTexture(global::SDL3Sharp.Texture texture, global::SDL3Sharp.Rect rect, __IntPtr pixels, int pitch)
        {
            var __arg0 = texture is null ? __IntPtr.Zero : texture.__Instance;
            var __arg1 = rect is null ? __IntPtr.Zero : rect.__Instance;
            var ___ret = __Internal.UpdateTexture(__arg0, __arg1, pixels, pitch);
            return ___ret;
        }

        /// <summary>
        /// <para>Update a rectangle within a planar YV12 or IYUV texture with new pixel</para>
        /// <para>data.</para>
        /// </summary>
        /// <param name="texture">the texture to update</param>
        /// <param name="rect">
        /// <para>a pointer to the rectangle of pixels to update, or NULL to</para>
        /// <para>update the entire texture</para>
        /// </param>
        /// <param name="Yplane">the raw pixel data for the Y plane</param>
        /// <param name="Ypitch">
        /// <para>the number of bytes between rows of pixel data for the Y</para>
        /// <para>plane</para>
        /// </param>
        /// <param name="Uplane">the raw pixel data for the U plane</param>
        /// <param name="Upitch">
        /// <para>the number of bytes between rows of pixel data for the U</para>
        /// <para>plane</para>
        /// </param>
        /// <param name="Vplane">the raw pixel data for the V plane</param>
        /// <param name="Vpitch">
        /// <para>the number of bytes between rows of pixel data for the V</para>
        /// <para>plane</para>
        /// </param>
        /// <remarks>
        /// <para>You can use SDL_UpdateTexture() as long as your pixel data is a contiguous</para>
        /// <para>block of Y and U/V planes in the proper order, but this function is</para>
        /// <para>available if your pixel data is not contiguous.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_UpdateTexture</para>
        /// </remarks>
        public static int UpdateYUVTexture(global::SDL3Sharp.Texture texture, global::SDL3Sharp.Rect rect, byte* Yplane, int Ypitch, byte* Uplane, int Upitch, byte* Vplane, int Vpitch)
        {
            var __arg0 = texture is null ? __IntPtr.Zero : texture.__Instance;
            var __arg1 = rect is null ? __IntPtr.Zero : rect.__Instance;
            var ___ret = __Internal.UpdateYUVTexture(__arg0, __arg1, Yplane, Ypitch, Uplane, Upitch, Vplane, Vpitch);
            return ___ret;
        }

        /// <summary>Update a rectangle within a planar NV12 or NV21 texture with new pixels.</summary>
        /// <param name="texture">the texture to update</param>
        /// <param name="rect">
        /// <para>a pointer to the rectangle of pixels to update, or NULL to</para>
        /// <para>update the entire texture.</para>
        /// </param>
        /// <param name="Yplane">the raw pixel data for the Y plane.</param>
        /// <param name="Ypitch">
        /// <para>the number of bytes between rows of pixel data for the Y</para>
        /// <para>plane.</para>
        /// </param>
        /// <param name="UVplane">the raw pixel data for the UV plane.</param>
        /// <param name="UVpitch">
        /// <para>the number of bytes between rows of pixel data for the UV</para>
        /// <para>plane.</para>
        /// </param>
        /// <remarks>
        /// <para>You can use SDL_UpdateTexture() as long as your pixel data is a contiguous</para>
        /// <para>block of NV12/21 planes in the proper order, but this function is available</para>
        /// <para>if your pixel data is not contiguous.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int UpdateNVTexture(global::SDL3Sharp.Texture texture, global::SDL3Sharp.Rect rect, byte* Yplane, int Ypitch, byte* UVplane, int UVpitch)
        {
            var __arg0 = texture is null ? __IntPtr.Zero : texture.__Instance;
            var __arg1 = rect is null ? __IntPtr.Zero : rect.__Instance;
            var ___ret = __Internal.UpdateNVTexture(__arg0, __arg1, Yplane, Ypitch, UVplane, UVpitch);
            return ___ret;
        }

        /// <summary>Lock a portion of the texture for **write-only** pixel access.</summary>
        /// <param name="texture">
        /// <para>the texture to lock for access, which was created with</para>
        /// <para>`SDL_TEXTUREACCESS_STREAMING`</para>
        /// </param>
        /// <param name="rect">
        /// <para>an SDL_Rect structure representing the area to lock for access;</para>
        /// <para>NULL to lock the entire texture</para>
        /// </param>
        /// <param name="pixels">
        /// <para>this is filled in with a pointer to the locked pixels,</para>
        /// <para>appropriately offset by the locked area</para>
        /// </param>
        /// <param name="pitch">
        /// <para>this is filled in with the pitch of the locked pixels; the</para>
        /// <para>pitch is the length of one row in bytes</para>
        /// </param>
        /// <remarks>
        /// <para>As an optimization, the pixels made available for editing don't necessarily</para>
        /// <para>contain the old texture data. This is a write-only operation, and if you</para>
        /// <para>need to keep a copy of the texture data you should do that at the</para>
        /// <para>application level.</para>
        /// <para>You must use SDL_UnlockTexture() to unlock the pixels and apply any</para>
        /// <para>changes.</para>
        /// <para>0 on success or a negative error code if the texture is not valid</para>
        /// <para>or was not created with `SDL_TEXTUREACCESS_STREAMING`; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_UnlockTexture</para>
        /// </remarks>
        public static int LockTexture(global::SDL3Sharp.Texture texture, global::SDL3Sharp.Rect rect, __IntPtr* pixels, ref int pitch)
        {
            var __arg0 = texture is null ? __IntPtr.Zero : texture.__Instance;
            var __arg1 = rect is null ? __IntPtr.Zero : rect.__Instance;
            fixed (int* __pitch3 = &pitch)
            {
                var __arg3 = __pitch3;
                var ___ret = __Internal.LockTexture(__arg0, __arg1, pixels, __arg3);
                return ___ret;
            }
        }

        /// <summary>
        /// <para>Lock a portion of the texture for **write-only** pixel access, and expose</para>
        /// <para>it as a SDL surface.</para>
        /// </summary>
        /// <param name="texture">
        /// <para>the texture to lock for access, which must be created with</para>
        /// <para>`SDL_TEXTUREACCESS_STREAMING`</para>
        /// </param>
        /// <param name="rect">
        /// <para>a pointer to the rectangle to lock for access. If the rect is</para>
        /// <para>NULL, the entire texture will be locked</para>
        /// </param>
        /// <param name="surface">
        /// <para>this is filled in with an SDL surface representing the</para>
        /// <para>locked area</para>
        /// </param>
        /// <remarks>
        /// <para>Besides providing an SDL_Surface instead of raw pixel data, this function</para>
        /// <para>operates like SDL_LockTexture.</para>
        /// <para>As an optimization, the pixels made available for editing don't necessarily</para>
        /// <para>contain the old texture data. This is a write-only operation, and if you</para>
        /// <para>need to keep a copy of the texture data you should do that at the</para>
        /// <para>application level.</para>
        /// <para>You must use SDL_UnlockTexture() to unlock the pixels and apply any</para>
        /// <para>changes.</para>
        /// <para>The returned surface is freed internally after calling SDL_UnlockTexture()</para>
        /// <para>or SDL_DestroyTexture(). The caller should not free it.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_LockTexture</para>
        /// <para>SDL_UnlockTexture</para>
        /// </remarks>
        public static int LockTextureToSurface(global::SDL3Sharp.Texture texture, global::SDL3Sharp.Rect rect, global::SDL3Sharp.Surface surface)
        {
            var __arg0 = texture is null ? __IntPtr.Zero : texture.__Instance;
            var __arg1 = rect is null ? __IntPtr.Zero : rect.__Instance;
            var ____arg2 = surface is null ? __IntPtr.Zero : surface.__Instance;
            var __arg2 = new __IntPtr(&____arg2);
            var ___ret = __Internal.LockTextureToSurface(__arg0, __arg1, __arg2);
            return ___ret;
        }

        /// <summary>Unlock a texture, uploading the changes to video memory, if needed.</summary>
        /// <param name="texture">a texture locked by SDL_LockTexture()</param>
        /// <remarks>
        /// <para>**Warning**: Please note that SDL_LockTexture() is intended to be</para>
        /// <para>write-only; it will not guarantee the previous contents of the texture will</para>
        /// <para>be provided. You must fully initialize any area of a texture that you lock</para>
        /// <para>before unlocking it, as the pixels might otherwise be uninitialized memory.</para>
        /// <para>Which is to say: locking and immediately unlocking a texture can result in</para>
        /// <para>corrupted textures, depending on the renderer in use.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_LockTexture</para>
        /// </remarks>
        public static void UnlockTexture(global::SDL3Sharp.Texture texture)
        {
            var __arg0 = texture is null ? __IntPtr.Zero : texture.__Instance;
            __Internal.UnlockTexture(__arg0);
        }

        /// <summary>Set a texture as the current rendering target.</summary>
        /// <param name="renderer">the rendering context</param>
        /// <param name="texture">
        /// <para>the targeted texture, which must be created with the</para>
        /// <para>`SDL_TEXTUREACCESS_TARGET` flag, or NULL to render to the</para>
        /// <para>window instead of a texture.</para>
        /// </param>
        /// <remarks>
        /// <para>The default render target is the window for which the renderer was created.</para>
        /// <para>To stop rendering to a texture and render to the window again, call this</para>
        /// <para>function with a NULL `texture`.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetRenderTarget</para>
        /// </remarks>
        public static int SetRenderTarget(global::SDL3Sharp.Renderer renderer, global::SDL3Sharp.Texture texture)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            var __arg1 = texture is null ? __IntPtr.Zero : texture.__Instance;
            var ___ret = __Internal.SetRenderTarget(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Get the current render target.</summary>
        /// <param name="renderer">the rendering context</param>
        /// <remarks>
        /// <para>The default render target is the window for which the renderer was created,</para>
        /// <para>and is reported a NULL here.</para>
        /// <para>the current render target or NULL for the default render target.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_SetRenderTarget</para>
        /// </remarks>
        public static global::SDL3Sharp.Texture GetRenderTarget(global::SDL3Sharp.Renderer renderer)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            var ___ret = __Internal.GetRenderTarget(__arg0);
            var __result0 = global::SDL3Sharp.Texture.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Set a device independent resolution and presentation mode for rendering.</summary>
        /// <param name="renderer">the rendering context</param>
        /// <param name="w">the width of the logical resolution</param>
        /// <param name="h">the height of the logical resolution</param>
        /// <param name="mode">the presentation mode used</param>
        /// <param name="scale_mode">the scale mode used</param>
        /// <remarks>
        /// <para>This function sets the width and height of the logical rendering output. A</para>
        /// <para>render target is created at the specified size and used for rendering and</para>
        /// <para>then copied to the output during presentation.</para>
        /// <para>You can disable logical coordinates by setting the mode to</para>
        /// <para>SDL_LOGICAL_PRESENTATION_DISABLED, and in that case you get the full pixel</para>
        /// <para>resolution of the output window.</para>
        /// <para>You can convert coordinates in an event into rendering coordinates using</para>
        /// <para>SDL_ConvertEventToRenderCoordinates().</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_ConvertEventToRenderCoordinates</para>
        /// <para>SDL_GetRenderLogicalPresentation</para>
        /// </remarks>
        public static int SetRenderLogicalPresentation(global::SDL3Sharp.Renderer renderer, int w, int h, global::SDL3Sharp.RendererLogicalPresentation mode, global::SDL3Sharp.ScaleMode scale_mode)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            var ___ret = __Internal.SetRenderLogicalPresentation(__arg0, w, h, mode, scale_mode);
            return ___ret;
        }

        /// <summary>Get device independent resolution and presentation mode for rendering.</summary>
        /// <param name="renderer">the rendering context</param>
        /// <param name="w">an int to be filled with the width</param>
        /// <param name="h">an int to be filled with the height</param>
        /// <param name="mode">a pointer filled in with the presentation mode</param>
        /// <param name="scale_mode">a pointer filled in with the scale mode</param>
        /// <remarks>
        /// <para>This function gets the width and height of the logical rendering output, or</para>
        /// <para>the output size in pixels if a logical resolution is not enabled.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_SetRenderLogicalPresentation</para>
        /// </remarks>
        public static int GetRenderLogicalPresentation(global::SDL3Sharp.Renderer renderer, ref int w, ref int h, ref global::SDL3Sharp.RendererLogicalPresentation mode, ref global::SDL3Sharp.ScaleMode scale_mode)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            fixed (int* __w1 = &w)
            {
                var __arg1 = __w1;
                fixed (int* __h2 = &h)
                {
                    var __arg2 = __h2;
                    fixed (global::SDL3Sharp.RendererLogicalPresentation* __mode3 = &mode)
                    {
                        var __arg3 = __mode3;
                        fixed (global::SDL3Sharp.ScaleMode* __scale_mode4 = &scale_mode)
                        {
                            var __arg4 = __scale_mode4;
                            var ___ret = __Internal.GetRenderLogicalPresentation(__arg0, __arg1, __arg2, __arg3, __arg4);
                            return ___ret;
                        }
                    }
                }
            }
        }

        /// <summary>Get a point in render coordinates when given a point in window coordinates.</summary>
        /// <param name="renderer">the rendering context</param>
        /// <param name="window_x">the x coordinate in window coordinates</param>
        /// <param name="window_y">the y coordinate in window coordinates</param>
        /// <param name="x">a pointer filled with the x coordinate in render coordinates</param>
        /// <param name="y">a pointer filled with the y coordinate in render coordinates</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_SetRenderLogicalPresentation</para>
        /// <para>SDL_SetRenderScale</para>
        /// </remarks>
        public static int RenderCoordinatesFromWindow(global::SDL3Sharp.Renderer renderer, float window_x, float window_y, ref float x, ref float y)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            fixed (float* __x3 = &x)
            {
                var __arg3 = __x3;
                fixed (float* __y4 = &y)
                {
                    var __arg4 = __y4;
                    var ___ret = __Internal.RenderCoordinatesFromWindow(__arg0, window_x, window_y, __arg3, __arg4);
                    return ___ret;
                }
            }
        }

        /// <summary>Get a point in window coordinates when given a point in render coordinates.</summary>
        /// <param name="renderer">the rendering context</param>
        /// <param name="x">the x coordinate in render coordinates</param>
        /// <param name="y">the y coordinate in render coordinates</param>
        /// <param name="window_x">
        /// <para>a pointer filled with the x coordinate in window</para>
        /// <para>coordinates</para>
        /// </param>
        /// <param name="window_y">
        /// <para>a pointer filled with the y coordinate in window</para>
        /// <para>coordinates</para>
        /// </param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_SetRenderLogicalPresentation</para>
        /// <para>SDL_SetRenderScale</para>
        /// </remarks>
        public static int RenderCoordinatesToWindow(global::SDL3Sharp.Renderer renderer, float x, float y, ref float window_x, ref float window_y)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            fixed (float* __window_x3 = &window_x)
            {
                var __arg3 = __window_x3;
                fixed (float* __window_y4 = &window_y)
                {
                    var __arg4 = __window_y4;
                    var ___ret = __Internal.RenderCoordinatesToWindow(__arg0, x, y, __arg3, __arg4);
                    return ___ret;
                }
            }
        }

        /// <summary>Convert the coordinates in an event to render coordinates.</summary>
        /// <param name="renderer">the rendering context</param>
        /// <param name="event">the event to modify</param>
        /// <remarks>
        /// <para>Touch coordinates are converted from normalized coordinates in the window</para>
        /// <para>to non-normalized rendering coordinates.</para>
        /// <para>Once converted, the coordinates may be outside the rendering area.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetRenderCoordinatesFromWindowCoordinates</para>
        /// </remarks>
        public static int ConvertEventToRenderCoordinates(global::SDL3Sharp.Renderer renderer, global::SDL3Sharp.Event @event)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            var ____arg1 = @event.__Instance;
            var __arg1 = new __IntPtr(&____arg1);
            var ___ret = __Internal.ConvertEventToRenderCoordinates(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Set the drawing area for rendering on the current target.</summary>
        /// <param name="renderer">the rendering context</param>
        /// <param name="rect">
        /// <para>the SDL_Rect structure representing the drawing area, or NULL</para>
        /// <para>to set the viewport to the entire target</para>
        /// </param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetRenderViewport</para>
        /// <para>SDL_RenderViewportSet</para>
        /// </remarks>
        public static int SetRenderViewport(global::SDL3Sharp.Renderer renderer, global::SDL3Sharp.Rect rect)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            var __arg1 = rect is null ? __IntPtr.Zero : rect.__Instance;
            var ___ret = __Internal.SetRenderViewport(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Get the drawing area for the current target.</summary>
        /// <param name="renderer">the rendering context</param>
        /// <param name="rect">an SDL_Rect structure filled in with the current drawing area</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_RenderViewportSet</para>
        /// <para>SDL_SetRenderViewport</para>
        /// </remarks>
        public static int GetRenderViewport(global::SDL3Sharp.Renderer renderer, global::SDL3Sharp.Rect rect)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            var __arg1 = rect is null ? __IntPtr.Zero : rect.__Instance;
            var ___ret = __Internal.GetRenderViewport(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Return whether an explicit rectangle was set as the viewport.</summary>
        /// <param name="renderer">the rendering context</param>
        /// <remarks>
        /// <para>This is useful if you're saving and restoring the viewport and want to know</para>
        /// <para>whether you should restore a specific rectangle or NULL. Note that the</para>
        /// <para>viewport is always reset when changing rendering targets.</para>
        /// <para>SDL_TRUE if the viewport was set to a specific rectangle, or</para>
        /// <para>SDL_FALSE if it was set to NULL (the entire target)</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetRenderViewport</para>
        /// <para>SDL_SetRenderViewport</para>
        /// </remarks>
        public static bool RenderViewportSet(global::SDL3Sharp.Renderer renderer)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            var ___ret = __Internal.RenderViewportSet(__arg0);
            return ___ret;
        }

        /// <summary>Set the clip rectangle for rendering on the specified target.</summary>
        /// <param name="renderer">the rendering context</param>
        /// <param name="rect">
        /// <para>an SDL_Rect structure representing the clip area, relative to</para>
        /// <para>the viewport, or NULL to disable clipping</para>
        /// </param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetRenderClipRect</para>
        /// <para>SDL_RenderClipEnabled</para>
        /// </remarks>
        public static int SetRenderClipRect(global::SDL3Sharp.Renderer renderer, global::SDL3Sharp.Rect rect)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            var __arg1 = rect is null ? __IntPtr.Zero : rect.__Instance;
            var ___ret = __Internal.SetRenderClipRect(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Get the clip rectangle for the current target.</summary>
        /// <param name="renderer">the rendering context</param>
        /// <param name="rect">
        /// <para>an SDL_Rect structure filled in with the current clipping area</para>
        /// <para>or an empty rectangle if clipping is disabled</para>
        /// </param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_RenderClipEnabled</para>
        /// <para>SDL_SetRenderClipRect</para>
        /// </remarks>
        public static int GetRenderClipRect(global::SDL3Sharp.Renderer renderer, global::SDL3Sharp.Rect rect)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            var __arg1 = rect is null ? __IntPtr.Zero : rect.__Instance;
            var ___ret = __Internal.GetRenderClipRect(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Get whether clipping is enabled on the given renderer.</summary>
        /// <param name="renderer">the rendering context</param>
        /// <remarks>
        /// <para>SDL_TRUE if clipping is enabled or SDL_FALSE if not; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetRenderClipRect</para>
        /// <para>SDL_SetRenderClipRect</para>
        /// </remarks>
        public static bool RenderClipEnabled(global::SDL3Sharp.Renderer renderer)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            var ___ret = __Internal.RenderClipEnabled(__arg0);
            return ___ret;
        }

        /// <summary>Set the drawing scale for rendering on the current target.</summary>
        /// <param name="renderer">the rendering context</param>
        /// <param name="scaleX">the horizontal scaling factor</param>
        /// <param name="scaleY">the vertical scaling factor</param>
        /// <remarks>
        /// <para>The drawing coordinates are scaled by the x/y scaling factors before they</para>
        /// <para>are used by the renderer. This allows resolution independent drawing with a</para>
        /// <para>single coordinate system.</para>
        /// <para>If this results in scaling or subpixel drawing by the rendering backend, it</para>
        /// <para>will be handled using the appropriate quality hints. For best results use</para>
        /// <para>integer scaling factors.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetRenderScale</para>
        /// </remarks>
        public static int SetRenderScale(global::SDL3Sharp.Renderer renderer, float scaleX, float scaleY)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            var ___ret = __Internal.SetRenderScale(__arg0, scaleX, scaleY);
            return ___ret;
        }

        /// <summary>Get the drawing scale for the current target.</summary>
        /// <param name="renderer">the rendering context</param>
        /// <param name="scaleX">a pointer filled in with the horizontal scaling factor</param>
        /// <param name="scaleY">a pointer filled in with the vertical scaling factor</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_SetRenderScale</para>
        /// </remarks>
        public static int GetRenderScale(global::SDL3Sharp.Renderer renderer, ref float scaleX, ref float scaleY)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            fixed (float* __scaleX1 = &scaleX)
            {
                var __arg1 = __scaleX1;
                fixed (float* __scaleY2 = &scaleY)
                {
                    var __arg2 = __scaleY2;
                    var ___ret = __Internal.GetRenderScale(__arg0, __arg1, __arg2);
                    return ___ret;
                }
            }
        }

        /// <summary>Set the color used for drawing operations.</summary>
        /// <param name="renderer">the rendering context</param>
        /// <param name="r">the red value used to draw on the rendering target</param>
        /// <param name="g">the green value used to draw on the rendering target</param>
        /// <param name="b">the blue value used to draw on the rendering target</param>
        /// <param name="a">
        /// <para>the alpha value used to draw on the rendering target; usually</para>
        /// <para>`SDL_ALPHA_OPAQUE` (255). Use SDL_SetRenderDrawBlendMode to</para>
        /// <para>specify how the alpha channel is used</para>
        /// </param>
        /// <remarks>
        /// <para>SDL_RenderRect</para>
        /// <para>SDL_RenderPoints</para>
        /// <para>SDL_RenderPoint</para>
        /// <para>SDL_RenderLines</para>
        /// <para>SDL_RenderLine</para>
        /// <para>SDL_RenderFillRects</para>
        /// <para>SDL_GetRenderDrawColor</para>
        /// <para>SDL_RenderClear</para>
        /// <para>SDL_RenderRects</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>Set the color for drawing or filling rectangles, lines, and points, and for</para>
        /// <para>SDL_RenderClear().</para>
        /// <para>SDL_RenderFillRect</para>
        /// <para>SDL_SetRenderDrawColorFloat</para>
        /// </remarks>
        public static int SetRenderDrawColor(global::SDL3Sharp.Renderer renderer, byte r, byte g, byte b, byte a)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            var ___ret = __Internal.SetRenderDrawColor(__arg0, r, g, b, a);
            return ___ret;
        }

        /// <summary>Set the color used for drawing operations (Rect, Line and Clear).</summary>
        /// <param name="renderer">the rendering context</param>
        /// <param name="r">the red value used to draw on the rendering target</param>
        /// <param name="g">the green value used to draw on the rendering target</param>
        /// <param name="b">the blue value used to draw on the rendering target</param>
        /// <param name="a">
        /// <para>the alpha value used to draw on the rendering target. Use</para>
        /// <para>SDL_SetRenderDrawBlendMode to specify how the alpha channel is</para>
        /// <para>used</para>
        /// </param>
        /// <remarks>
        /// <para>SDL_RenderRect</para>
        /// <para>SDL_RenderPoints</para>
        /// <para>SDL_RenderPoint</para>
        /// <para>SDL_RenderLines</para>
        /// <para>SDL_RenderLine</para>
        /// <para>SDL_RenderFillRects</para>
        /// <para>SDL_GetRenderDrawColorFloat</para>
        /// <para>SDL_RenderClear</para>
        /// <para>SDL_RenderRects</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>Set the color for drawing or filling rectangles, lines, and points, and for</para>
        /// <para>SDL_RenderClear().</para>
        /// <para>SDL_RenderFillRect</para>
        /// <para>SDL_SetRenderDrawColor</para>
        /// </remarks>
        public static int SetRenderDrawColorFloat(global::SDL3Sharp.Renderer renderer, float r, float g, float b, float a)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            var ___ret = __Internal.SetRenderDrawColorFloat(__arg0, r, g, b, a);
            return ___ret;
        }

        /// <summary>Get the color used for drawing operations (Rect, Line and Clear).</summary>
        /// <param name="renderer">the rendering context</param>
        /// <param name="r">
        /// <para>a pointer filled in with the red value used to draw on the</para>
        /// <para>rendering target</para>
        /// </param>
        /// <param name="g">
        /// <para>a pointer filled in with the green value used to draw on the</para>
        /// <para>rendering target</para>
        /// </param>
        /// <param name="b">
        /// <para>a pointer filled in with the blue value used to draw on the</para>
        /// <para>rendering target</para>
        /// </param>
        /// <param name="a">
        /// <para>a pointer filled in with the alpha value used to draw on the</para>
        /// <para>rendering target; usually `SDL_ALPHA_OPAQUE` (255)</para>
        /// </param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetRenderDrawColorFloat</para>
        /// <para>SDL_SetRenderDrawColor</para>
        /// </remarks>
        public static int GetRenderDrawColor(global::SDL3Sharp.Renderer renderer, byte* r, byte* g, byte* b, byte* a)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            var ___ret = __Internal.GetRenderDrawColor(__arg0, r, g, b, a);
            return ___ret;
        }

        /// <summary>Get the color used for drawing operations (Rect, Line and Clear).</summary>
        /// <param name="renderer">the rendering context</param>
        /// <param name="r">
        /// <para>a pointer filled in with the red value used to draw on the</para>
        /// <para>rendering target</para>
        /// </param>
        /// <param name="g">
        /// <para>a pointer filled in with the green value used to draw on the</para>
        /// <para>rendering target</para>
        /// </param>
        /// <param name="b">
        /// <para>a pointer filled in with the blue value used to draw on the</para>
        /// <para>rendering target</para>
        /// </param>
        /// <param name="a">
        /// <para>a pointer filled in with the alpha value used to draw on the</para>
        /// <para>rendering target</para>
        /// </param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_SetRenderDrawColorFloat</para>
        /// <para>SDL_GetRenderDrawColor</para>
        /// </remarks>
        public static int GetRenderDrawColorFloat(global::SDL3Sharp.Renderer renderer, ref float r, ref float g, ref float b, ref float a)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            fixed (float* __r1 = &r)
            {
                var __arg1 = __r1;
                fixed (float* __g2 = &g)
                {
                    var __arg2 = __g2;
                    fixed (float* __b3 = &b)
                    {
                        var __arg3 = __b3;
                        fixed (float* __a4 = &a)
                        {
                            var __arg4 = __a4;
                            var ___ret = __Internal.GetRenderDrawColorFloat(__arg0, __arg1, __arg2, __arg3, __arg4);
                            return ___ret;
                        }
                    }
                }
            }
        }

        /// <summary>Set the color scale used for render operations.</summary>
        /// <param name="renderer">the rendering context</param>
        /// <param name="scale">the color scale value</param>
        /// <remarks>
        /// <para>The color scale is an additional scale multiplied into the pixel color</para>
        /// <para>value while rendering. This can be used to adjust the brightness of colors</para>
        /// <para>during HDR rendering, or changing HDR video brightness when playing on an</para>
        /// <para>SDR display.</para>
        /// <para>The color scale does not affect the alpha channel, only the color</para>
        /// <para>brightness.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetRenderColorScale</para>
        /// </remarks>
        public static int SetRenderColorScale(global::SDL3Sharp.Renderer renderer, float scale)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            var ___ret = __Internal.SetRenderColorScale(__arg0, scale);
            return ___ret;
        }

        /// <summary>Get the color scale used for render operations.</summary>
        /// <param name="renderer">the rendering context</param>
        /// <param name="scale">a pointer filled in with the current color scale value</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_SetRenderColorScale</para>
        /// </remarks>
        public static int GetRenderColorScale(global::SDL3Sharp.Renderer renderer, ref float scale)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            fixed (float* __scale1 = &scale)
            {
                var __arg1 = __scale1;
                var ___ret = __Internal.GetRenderColorScale(__arg0, __arg1);
                return ___ret;
            }
        }

        /// <summary>Set the blend mode used for drawing operations (Fill and Line).</summary>
        /// <param name="renderer">the rendering context</param>
        /// <param name="blendMode">the SDL_BlendMode to use for blending</param>
        /// <remarks>
        /// <para>If the blend mode is not supported, the closest supported mode is chosen.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetRenderDrawBlendMode</para>
        /// <para>SDL_RenderLine</para>
        /// <para>SDL_RenderLines</para>
        /// <para>SDL_RenderPoint</para>
        /// <para>SDL_RenderPoints</para>
        /// <para>SDL_RenderRect</para>
        /// <para>SDL_RenderRects</para>
        /// <para>SDL_RenderFillRect</para>
        /// <para>SDL_RenderFillRects</para>
        /// </remarks>
        public static int SetRenderDrawBlendMode(global::SDL3Sharp.Renderer renderer, global::SDL3Sharp.BlendMode blendMode)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            var ___ret = __Internal.SetRenderDrawBlendMode(__arg0, blendMode);
            return ___ret;
        }

        /// <summary>Get the blend mode used for drawing operations.</summary>
        /// <param name="renderer">the rendering context</param>
        /// <param name="blendMode">a pointer filled in with the current SDL_BlendMode</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_SetRenderDrawBlendMode</para>
        /// </remarks>
        public static int GetRenderDrawBlendMode(global::SDL3Sharp.Renderer renderer, ref global::SDL3Sharp.BlendMode blendMode)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            fixed (global::SDL3Sharp.BlendMode* __blendMode1 = &blendMode)
            {
                var __arg1 = __blendMode1;
                var ___ret = __Internal.GetRenderDrawBlendMode(__arg0, __arg1);
                return ___ret;
            }
        }

        /// <summary>Clear the current rendering target with the drawing color.</summary>
        /// <param name="renderer">the rendering context</param>
        /// <remarks>
        /// <para>This function clears the entire rendering target, ignoring the viewport and</para>
        /// <para>the clip rectangle.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_SetRenderDrawColor</para>
        /// </remarks>
        public static int RenderClear(global::SDL3Sharp.Renderer renderer)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            var ___ret = __Internal.RenderClear(__arg0);
            return ___ret;
        }

        /// <summary>Draw a point on the current rendering target at subpixel precision.</summary>
        /// <param name="renderer">The renderer which should draw a point.</param>
        /// <param name="x">The x coordinate of the point.</param>
        /// <param name="y">The y coordinate of the point.</param>
        /// <remarks>
        /// <para>0 on success, or -1 on error</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int RenderPoint(global::SDL3Sharp.Renderer renderer, float x, float y)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            var ___ret = __Internal.RenderPoint(__arg0, x, y);
            return ___ret;
        }

        /// <summary>Draw multiple points on the current rendering target at subpixel precision.</summary>
        /// <param name="renderer">The renderer which should draw multiple points.</param>
        /// <param name="points">The points to draw</param>
        /// <param name="count">The number of points to draw</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int RenderPoints(global::SDL3Sharp.Renderer renderer, global::SDL3Sharp.FPoint points, int count)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            var __arg1 = points is null ? __IntPtr.Zero : points.__Instance;
            var ___ret = __Internal.RenderPoints(__arg0, __arg1, count);
            return ___ret;
        }

        /// <summary>Draw a line on the current rendering target at subpixel precision.</summary>
        /// <param name="renderer">The renderer which should draw a line.</param>
        /// <param name="x1">The x coordinate of the start point.</param>
        /// <param name="y1">The y coordinate of the start point.</param>
        /// <param name="x2">The x coordinate of the end point.</param>
        /// <param name="y2">The y coordinate of the end point.</param>
        /// <remarks>
        /// <para>0 on success, or -1 on error</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int RenderLine(global::SDL3Sharp.Renderer renderer, float x1, float y1, float x2, float y2)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            var ___ret = __Internal.RenderLine(__arg0, x1, y1, x2, y2);
            return ___ret;
        }

        /// <summary>
        /// <para>Draw a series of connected lines on the current rendering target at</para>
        /// <para>subpixel precision.</para>
        /// </summary>
        /// <param name="renderer">The renderer which should draw multiple lines.</param>
        /// <param name="points">The points along the lines</param>
        /// <param name="count">The number of points, drawing count-1 lines</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int RenderLines(global::SDL3Sharp.Renderer renderer, global::SDL3Sharp.FPoint points, int count)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            var __arg1 = points is null ? __IntPtr.Zero : points.__Instance;
            var ___ret = __Internal.RenderLines(__arg0, __arg1, count);
            return ___ret;
        }

        /// <summary>Draw a rectangle on the current rendering target at subpixel precision.</summary>
        /// <param name="renderer">The renderer which should draw a rectangle.</param>
        /// <param name="rect">
        /// <para>A pointer to the destination rectangle, or NULL to outline the</para>
        /// <para>entire rendering target.</para>
        /// </param>
        /// <remarks>
        /// <para>0 on success, or -1 on error</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int RenderRect(global::SDL3Sharp.Renderer renderer, global::SDL3Sharp.FRect rect)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            var __arg1 = rect is null ? __IntPtr.Zero : rect.__Instance;
            var ___ret = __Internal.RenderRect(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>
        /// <para>Draw some number of rectangles on the current rendering target at subpixel</para>
        /// <para>precision.</para>
        /// </summary>
        /// <param name="renderer">The renderer which should draw multiple rectangles.</param>
        /// <param name="rects">A pointer to an array of destination rectangles.</param>
        /// <param name="count">The number of rectangles.</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int RenderRects(global::SDL3Sharp.Renderer renderer, global::SDL3Sharp.FRect rects, int count)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            var __arg1 = rects is null ? __IntPtr.Zero : rects.__Instance;
            var ___ret = __Internal.RenderRects(__arg0, __arg1, count);
            return ___ret;
        }

        /// <summary>
        /// <para>Fill a rectangle on the current rendering target with the drawing color at</para>
        /// <para>subpixel precision.</para>
        /// </summary>
        /// <param name="renderer">The renderer which should fill a rectangle.</param>
        /// <param name="rect">
        /// <para>A pointer to the destination rectangle, or NULL for the entire</para>
        /// <para>rendering target.</para>
        /// </param>
        /// <remarks>
        /// <para>0 on success, or -1 on error</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int RenderFillRect(global::SDL3Sharp.Renderer renderer, global::SDL3Sharp.FRect rect)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            var __arg1 = rect is null ? __IntPtr.Zero : rect.__Instance;
            var ___ret = __Internal.RenderFillRect(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>
        /// <para>Fill some number of rectangles on the current rendering target with the</para>
        /// <para>drawing color at subpixel precision.</para>
        /// </summary>
        /// <param name="renderer">The renderer which should fill multiple rectangles.</param>
        /// <param name="rects">A pointer to an array of destination rectangles.</param>
        /// <param name="count">The number of rectangles.</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int RenderFillRects(global::SDL3Sharp.Renderer renderer, global::SDL3Sharp.FRect rects, int count)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            var __arg1 = rects is null ? __IntPtr.Zero : rects.__Instance;
            var ___ret = __Internal.RenderFillRects(__arg0, __arg1, count);
            return ___ret;
        }

        /// <summary>
        /// <para>Copy a portion of the texture to the current rendering target at subpixel</para>
        /// <para>precision.</para>
        /// </summary>
        /// <param name="renderer">The renderer which should copy parts of a texture.</param>
        /// <param name="texture">The source texture.</param>
        /// <param name="srcrect">
        /// <para>A pointer to the source rectangle, or NULL for the entire</para>
        /// <para>texture.</para>
        /// </param>
        /// <param name="dstrect">
        /// <para>A pointer to the destination rectangle, or NULL for the</para>
        /// <para>entire rendering target.</para>
        /// </param>
        /// <remarks>
        /// <para>0 on success, or -1 on error</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int RenderTexture(global::SDL3Sharp.Renderer renderer, global::SDL3Sharp.Texture texture, global::SDL3Sharp.FRect srcrect, global::SDL3Sharp.FRect dstrect)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            var __arg1 = texture is null ? __IntPtr.Zero : texture.__Instance;
            var __arg2 = srcrect is null ? __IntPtr.Zero : srcrect.__Instance;
            var __arg3 = dstrect is null ? __IntPtr.Zero : dstrect.__Instance;
            var ___ret = __Internal.RenderTexture(__arg0, __arg1, __arg2, __arg3);
            return ___ret;
        }

        /// <summary>
        /// <para>Copy a portion of the source texture to the current rendering target, with</para>
        /// <para>rotation and flipping, at subpixel precision.</para>
        /// </summary>
        /// <param name="renderer">The renderer which should copy parts of a texture.</param>
        /// <param name="texture">The source texture.</param>
        /// <param name="srcrect">
        /// <para>A pointer to the source rectangle, or NULL for the entire</para>
        /// <para>texture.</para>
        /// </param>
        /// <param name="dstrect">
        /// <para>A pointer to the destination rectangle, or NULL for the</para>
        /// <para>entire rendering target.</para>
        /// </param>
        /// <param name="angle">
        /// <para>An angle in degrees that indicates the rotation that will be</para>
        /// <para>applied to dstrect, rotating it in a clockwise direction</para>
        /// </param>
        /// <param name="center">
        /// <para>A pointer to a point indicating the point around which</para>
        /// <para>dstrect will be rotated (if NULL, rotation will be done</para>
        /// <para>around dstrect.w/2, dstrect.h/2).</para>
        /// </param>
        /// <param name="flip">
        /// <para>An SDL_FlipMode value stating which flipping actions should be</para>
        /// <para>performed on the texture</para>
        /// </param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int RenderTextureRotated(global::SDL3Sharp.Renderer renderer, global::SDL3Sharp.Texture texture, global::SDL3Sharp.FRect srcrect, global::SDL3Sharp.FRect dstrect, double angle, global::SDL3Sharp.FPoint center, global::SDL3Sharp.FlipMode flip)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            var __arg1 = texture is null ? __IntPtr.Zero : texture.__Instance;
            var __arg2 = srcrect is null ? __IntPtr.Zero : srcrect.__Instance;
            var __arg3 = dstrect is null ? __IntPtr.Zero : dstrect.__Instance;
            var __arg5 = center is null ? __IntPtr.Zero : center.__Instance;
            var ___ret = __Internal.RenderTextureRotated(__arg0, __arg1, __arg2, __arg3, angle, __arg5, flip);
            return ___ret;
        }

        /// <summary>
        /// <para>Render a list of triangles, optionally using a texture and indices into the</para>
        /// <para>vertex array Color and alpha modulation is done per vertex</para>
        /// <para>(SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).</para>
        /// </summary>
        /// <param name="renderer">The rendering context.</param>
        /// <param name="texture">(optional) The SDL texture to use.</param>
        /// <param name="vertices">Vertices.</param>
        /// <param name="num_vertices">Number of vertices.</param>
        /// <param name="indices">
        /// <para>(optional) An array of integer indices into the 'vertices'</para>
        /// <para>array, if NULL all vertices will be rendered in sequential</para>
        /// <para>order.</para>
        /// </param>
        /// <param name="num_indices">Number of indices.</param>
        /// <remarks>
        /// <para>0 on success, or -1 if the operation is not supported</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_RenderGeometryRaw</para>
        /// <para>SDL_Vertex</para>
        /// </remarks>
        public static int RenderGeometry(global::SDL3Sharp.Renderer renderer, global::SDL3Sharp.Texture texture, global::SDL3Sharp.Vertex vertices, int num_vertices, ref int indices, int num_indices)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            var __arg1 = texture is null ? __IntPtr.Zero : texture.__Instance;
            var __arg2 = vertices is null ? __IntPtr.Zero : vertices.__Instance;
            fixed (int* __indices4 = &indices)
            {
                var __arg4 = __indices4;
                var ___ret = __Internal.RenderGeometry(__arg0, __arg1, __arg2, num_vertices, __arg4, num_indices);
                return ___ret;
            }
        }

        /// <summary>
        /// <para>Render a list of triangles, optionally using a texture and indices into the</para>
        /// <para>vertex arrays Color and alpha modulation is done per vertex</para>
        /// <para>(SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).</para>
        /// </summary>
        /// <param name="size_indices">Index size: 1 (byte), 2 (short), 4 (int)</param>
        /// <param name="num_indices">Number of indices.</param>
        /// <param name="indices">
        /// <para>(optional) An array of indices into the 'vertices' arrays,</para>
        /// <para>if NULL all vertices will be rendered in sequential order.</para>
        /// </param>
        /// <param name="num_vertices">Number of vertices.</param>
        /// <param name="uv_stride">Byte size to move from one element to the next element</param>
        /// <param name="color_stride">Byte size to move from one element to the next element</param>
        /// <param name="uv">Vertex normalized texture coordinates</param>
        /// <param name="xy_stride">Byte size to move from one element to the next element</param>
        /// <param name="xy">Vertex positions</param>
        /// <param name="texture">(optional) The SDL texture to use.</param>
        /// <param name="renderer">The rendering context.</param>
        /// <param name="color">Vertex colors (as SDL_Color)</param>
        /// <remarks>
        /// <para>SDL_RenderGeometry</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_Vertex</para>
        /// </remarks>
        public static int RenderGeometryRaw(global::SDL3Sharp.Renderer renderer, global::SDL3Sharp.Texture texture, ref float xy, int xy_stride, global::SDL3Sharp.Color color, int color_stride, ref float uv, int uv_stride, int num_vertices, __IntPtr indices, int num_indices, int size_indices)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            var __arg1 = texture is null ? __IntPtr.Zero : texture.__Instance;
            fixed (float* __xy2 = &xy)
            {
                var __arg2 = __xy2;
                var __arg4 = color is null ? __IntPtr.Zero : color.__Instance;
                fixed (float* __uv6 = &uv)
                {
                    var __arg6 = __uv6;
                    var ___ret = __Internal.RenderGeometryRaw(__arg0, __arg1, __arg2, xy_stride, __arg4, color_stride, __arg6, uv_stride, num_vertices, indices, num_indices, size_indices);
                    return ___ret;
                }
            }
        }

        /// <summary>
        /// <para>Render a list of triangles, optionally using a texture and indices into the</para>
        /// <para>vertex arrays Color and alpha modulation is done per vertex</para>
        /// <para>(SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).</para>
        /// </summary>
        /// <param name="size_indices">Index size: 1 (byte), 2 (short), 4 (int)</param>
        /// <param name="num_indices">Number of indices.</param>
        /// <param name="indices">
        /// <para>(optional) An array of indices into the 'vertices' arrays,</para>
        /// <para>if NULL all vertices will be rendered in sequential order.</para>
        /// </param>
        /// <param name="num_vertices">Number of vertices.</param>
        /// <param name="uv_stride">Byte size to move from one element to the next element</param>
        /// <param name="color_stride">Byte size to move from one element to the next element</param>
        /// <param name="uv">Vertex normalized texture coordinates</param>
        /// <param name="xy_stride">Byte size to move from one element to the next element</param>
        /// <param name="xy">Vertex positions</param>
        /// <param name="texture">(optional) The SDL texture to use.</param>
        /// <param name="renderer">The rendering context.</param>
        /// <param name="color">Vertex colors (as SDL_FColor)</param>
        /// <remarks>
        /// <para>SDL_RenderGeometry</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_Vertex</para>
        /// </remarks>
        public static int RenderGeometryRawFloat(global::SDL3Sharp.Renderer renderer, global::SDL3Sharp.Texture texture, ref float xy, int xy_stride, global::SDL3Sharp.FColor color, int color_stride, ref float uv, int uv_stride, int num_vertices, __IntPtr indices, int num_indices, int size_indices)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            var __arg1 = texture is null ? __IntPtr.Zero : texture.__Instance;
            fixed (float* __xy2 = &xy)
            {
                var __arg2 = __xy2;
                var __arg4 = color is null ? __IntPtr.Zero : color.__Instance;
                fixed (float* __uv6 = &uv)
                {
                    var __arg6 = __uv6;
                    var ___ret = __Internal.RenderGeometryRawFloat(__arg0, __arg1, __arg2, xy_stride, __arg4, color_stride, __arg6, uv_stride, num_vertices, indices, num_indices, size_indices);
                    return ___ret;
                }
            }
        }

        /// <summary>Read pixels from the current rendering target.</summary>
        /// <param name="renderer">the rendering context</param>
        /// <param name="rect">
        /// <para>an SDL_Rect structure representing the area in pixels relative</para>
        /// <para>to the to current viewport, or NULL for the entire viewport</para>
        /// </param>
        /// <remarks>
        /// <para>The returned surface should be freed with SDL_DestroySurface()</para>
        /// <para>**WARNING**: This is a very slow operation, and should not be used</para>
        /// <para>frequently. If you're using this on the main rendering target, it should be</para>
        /// <para>called after rendering and before SDL_RenderPresent().</para>
        /// <para>a new SDL_Surface on success or NULL on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static global::SDL3Sharp.Surface RenderReadPixels(global::SDL3Sharp.Renderer renderer, global::SDL3Sharp.Rect rect)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            var __arg1 = rect is null ? __IntPtr.Zero : rect.__Instance;
            var ___ret = __Internal.RenderReadPixels(__arg0, __arg1);
            var __result0 = global::SDL3Sharp.Surface.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Update the screen with any rendering performed since the previous call.</summary>
        /// <param name="renderer">the rendering context</param>
        /// <remarks>
        /// <para>SDL's rendering functions operate on a backbuffer; that is, calling a</para>
        /// <para>rendering function such as SDL_RenderLine() does not directly put a line on</para>
        /// <para>the screen, but rather updates the backbuffer. As such, you compose your</para>
        /// <para>entire scene and *present* the composed backbuffer to the screen as a</para>
        /// <para>complete picture.</para>
        /// <para>Therefore, when using SDL's rendering API, one does all drawing intended</para>
        /// <para>for the frame, and then calls this function once per frame to present the</para>
        /// <para>final drawing to the user.</para>
        /// <para>The backbuffer should be considered invalidated after each present; do not</para>
        /// <para>assume that previous contents will exist between frames. You are strongly</para>
        /// <para>encouraged to call SDL_RenderClear() to initialize the backbuffer before</para>
        /// <para>starting each new frame's drawing, even if you plan to overwrite every</para>
        /// <para>pixel.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>You may only call this function on the main thread.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_RenderClear</para>
        /// <para>SDL_RenderLine</para>
        /// <para>SDL_RenderLines</para>
        /// <para>SDL_RenderPoint</para>
        /// <para>SDL_RenderPoints</para>
        /// <para>SDL_RenderRect</para>
        /// <para>SDL_RenderRects</para>
        /// <para>SDL_RenderFillRect</para>
        /// <para>SDL_RenderFillRects</para>
        /// <para>SDL_SetRenderDrawBlendMode</para>
        /// <para>SDL_SetRenderDrawColor</para>
        /// </remarks>
        public static int RenderPresent(global::SDL3Sharp.Renderer renderer)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            var ___ret = __Internal.RenderPresent(__arg0);
            return ___ret;
        }

        /// <summary>Destroy the specified texture.</summary>
        /// <param name="texture">the texture to destroy</param>
        /// <remarks>
        /// <para>Passing NULL or an otherwise invalid texture will set the SDL error message</para>
        /// <para>to &quot;Invalid texture&quot;.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateTexture</para>
        /// <para>SDL_CreateTextureFromSurface</para>
        /// </remarks>
        public static void DestroyTexture(global::SDL3Sharp.Texture texture)
        {
            var __arg0 = texture is null ? __IntPtr.Zero : texture.__Instance;
            __Internal.DestroyTexture(__arg0);
        }

        /// <summary>Destroy the rendering context for a window and free associated textures.</summary>
        /// <param name="renderer">the rendering context</param>
        /// <remarks>
        /// <para>If `renderer` is NULL, this function will return immediately after setting</para>
        /// <para>the SDL error message to &quot;Invalid renderer&quot;. See SDL_GetError().</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateRenderer</para>
        /// </remarks>
        public static void DestroyRenderer(global::SDL3Sharp.Renderer renderer)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            __Internal.DestroyRenderer(__arg0);
        }

        /// <summary>Force the rendering context to flush any pending commands and state.</summary>
        /// <param name="renderer">the rendering context</param>
        /// <remarks>
        /// <para>You do not need to (and in fact, shouldn't) call this function unless you</para>
        /// <para>are planning to call into OpenGL/Direct3D/Metal/whatever directly, in</para>
        /// <para>addition to using an SDL_Renderer.</para>
        /// <para>This is for a very-specific case: if you are using SDL's render API, and</para>
        /// <para>you plan to make OpenGL/D3D/whatever calls in addition to SDL render API</para>
        /// <para>calls. If this applies, you should call this function between calls to</para>
        /// <para>SDL's render API and the low-level API you're using in cooperation.</para>
        /// <para>In all other cases, you can ignore this function.</para>
        /// <para>This call makes SDL flush any pending rendering work it was queueing up to</para>
        /// <para>do later in a single batch, and marks any internal cached state as invalid,</para>
        /// <para>so it'll prepare all its state again later, from scratch.</para>
        /// <para>This means you do not need to save state in your rendering code to protect</para>
        /// <para>the SDL renderer. However, there lots of arbitrary pieces of Direct3D and</para>
        /// <para>OpenGL state that can confuse things; you should use your best judgement</para>
        /// <para>and be prepared to make changes if specific state needs to be protected.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int FlushRenderer(global::SDL3Sharp.Renderer renderer)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            var ___ret = __Internal.FlushRenderer(__arg0);
            return ___ret;
        }

        /// <summary>Get the CAMetalLayer associated with the given Metal renderer.</summary>
        /// <param name="renderer">The renderer to query</param>
        /// <remarks>
        /// <para>This function returns `void *`, so SDL doesn't have to include Metal's</para>
        /// <para>headers, but it can be safely cast to a `CAMetalLayer *`.</para>
        /// <para>a `CAMetalLayer *` on success, or NULL if the renderer isn't a</para>
        /// <para>Metal renderer</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetRenderMetalCommandEncoder</para>
        /// </remarks>
        public static __IntPtr GetRenderMetalLayer(global::SDL3Sharp.Renderer renderer)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            var ___ret = __Internal.GetRenderMetalLayer(__arg0);
            return ___ret;
        }

        /// <summary>Get the Metal command encoder for the current frame</summary>
        /// <param name="renderer">The renderer to query</param>
        /// <remarks>
        /// <para>This function returns `void *`, so SDL doesn't have to include Metal's</para>
        /// <para>headers, but it can be safely cast to an `id`.</para>
        /// <para>Note that as of SDL 2.0.18, this will return NULL if Metal refuses to give</para>
        /// <para>SDL a drawable to render to, which might happen if the window is</para>
        /// <para>hidden/minimized/offscreen. This doesn't apply to command encoders for</para>
        /// <para>render targets, just the window's backbuffer. Check your return values!</para>
        /// <para>an `id&gt;` on success, or NULL if the</para>
        /// <para>renderer isn't a Metal renderer or there was an error.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetRenderMetalLayer</para>
        /// </remarks>
        public static __IntPtr GetRenderMetalCommandEncoder(global::SDL3Sharp.Renderer renderer)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            var ___ret = __Internal.GetRenderMetalCommandEncoder(__arg0);
            return ___ret;
        }

        /// <summary>Add a set of synchronization semaphores for the current frame.</summary>
        /// <param name="renderer">the rendering context</param>
        /// <param name="wait_stage_mask">the VkPipelineStageFlags for the wait</param>
        /// <param name="wait_semaphore">
        /// <para>a VkSempahore to wait on before rendering the current</para>
        /// <para>frame, or 0 if not needed</para>
        /// </param>
        /// <param name="signal_semaphore">
        /// <para>a VkSempahore that SDL will signal when rendering</para>
        /// <para>for the current frame is complete, or 0 if not</para>
        /// <para>needed</para>
        /// </param>
        /// <remarks>
        /// <para>The Vulkan renderer will wait for `wait_semaphore` before submitting</para>
        /// <para>rendering commands and signal `signal_semaphore` after rendering commands</para>
        /// <para>are complete for this frame.</para>
        /// <para>This should be called each frame that you want semaphore synchronization.</para>
        /// <para>The Vulkan renderer may have multiple frames in flight on the GPU, so you</para>
        /// <para>should have multiple semaphores that are used for synchronization. Querying</para>
        /// <para>SDL_PROP_RENDERER_VULKAN_SWAPCHAIN_IMAGE_COUNT_NUMBER will give you the</para>
        /// <para>maximum number of semaphores you'll need.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int AddVulkanRenderSemaphores(global::SDL3Sharp.Renderer renderer, uint wait_stage_mask, long wait_semaphore, long signal_semaphore)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            var ___ret = __Internal.AddVulkanRenderSemaphores(__arg0, wait_stage_mask, wait_semaphore, signal_semaphore);
            return ___ret;
        }

        /// <summary>Toggle VSync of the given renderer.</summary>
        /// <param name="renderer">The renderer to toggle</param>
        /// <param name="vsync">1 for on, 0 for off. All other values are reserved</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int SetRenderVSync(global::SDL3Sharp.Renderer renderer, int vsync)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            var ___ret = __Internal.SetRenderVSync(__arg0, vsync);
            return ___ret;
        }

        /// <summary>Get VSync of the given renderer.</summary>
        /// <param name="renderer">The renderer to toggle</param>
        /// <param name="vsync">
        /// <para>an int filled with 1 for on, 0 for off. All other values are</para>
        /// <para>reserved</para>
        /// </param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int GetRenderVSync(global::SDL3Sharp.Renderer renderer, ref int vsync)
        {
            var __arg0 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            fixed (int* __vsync1 = &vsync)
            {
                var __arg1 = __vsync1;
                var ___ret = __Internal.GetRenderVSync(__arg0, __arg1);
                return ___ret;
            }
        }
    }
}
