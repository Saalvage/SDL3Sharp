// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required
#pragma warning disable CS9084 // Struct member returns 'this' or other instance members by reference

namespace SDL3Sharp
{
    public unsafe partial class Mutex
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.Mutex> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.Mutex>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.Mutex managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.Mutex managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Mutex __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Mutex(native.ToPointer(), skipVTables);
        }

        internal static Mutex __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Mutex)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Mutex __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Mutex(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Mutex(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Mutex(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class RWLock
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.RWLock> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.RWLock>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.RWLock managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.RWLock managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static RWLock __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new RWLock(native.ToPointer(), skipVTables);
        }

        internal static RWLock __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (RWLock)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static RWLock __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RWLock(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RWLock(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected RWLock(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class Semaphore
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.Semaphore> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.Semaphore>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.Semaphore managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.Semaphore managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Semaphore __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Semaphore(native.ToPointer(), skipVTables);
        }

        internal static Semaphore __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Semaphore)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Semaphore __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Semaphore(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Semaphore(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Semaphore(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class Condition
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.Condition> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.Condition>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.Condition managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.Condition managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Condition __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Condition(native.ToPointer(), skipVTables);
        }

        internal static Condition __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Condition)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Condition __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Condition(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Condition(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Condition(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class SDL
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_CreateMutex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CreateMutex();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_LockMutex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LockMutex(__IntPtr mutex);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_TryLockMutex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int TryLockMutex(__IntPtr mutex);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_UnlockMutex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UnlockMutex(__IntPtr mutex);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_DestroyMutex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void DestroyMutex(__IntPtr mutex);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_CreateRWLock", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CreateRWLock();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_LockRWLockForReading", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LockRWLockForReading(__IntPtr rwlock);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_LockRWLockForWriting", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void LockRWLockForWriting(__IntPtr rwlock);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_TryLockRWLockForReading", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int TryLockRWLockForReading(__IntPtr rwlock);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_TryLockRWLockForWriting", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int TryLockRWLockForWriting(__IntPtr rwlock);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_UnlockRWLock", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UnlockRWLock(__IntPtr rwlock);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_DestroyRWLock", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void DestroyRWLock(__IntPtr rwlock);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_CreateSemaphore", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CreateSemaphore(uint initial_value);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_DestroySemaphore", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void DestroySemaphore(__IntPtr sem);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_WaitSemaphore", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int WaitSemaphore(__IntPtr sem);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_TryWaitSemaphore", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int TryWaitSemaphore(__IntPtr sem);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_WaitSemaphoreTimeout", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int WaitSemaphoreTimeout(__IntPtr sem, int timeoutMS);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_PostSemaphore", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int PostSemaphore(__IntPtr sem);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetSemaphoreValue", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint GetSemaphoreValue(__IntPtr sem);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_CreateCondition", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CreateCondition();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_DestroyCondition", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void DestroyCondition(__IntPtr cond);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SignalCondition", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SignalCondition(__IntPtr cond);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_BroadcastCondition", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int BroadcastCondition(__IntPtr cond);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_WaitCondition", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int WaitCondition(__IntPtr cond, __IntPtr mutex);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_WaitConditionTimeout", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int WaitConditionTimeout(__IntPtr cond, __IntPtr mutex, int timeoutMS);
        }

        /// <summary>Create a new mutex.</summary>
        /// <remarks>
        /// <para>All newly-created mutexes begin in the _unlocked_ state.</para>
        /// <para>Calls to SDL_LockMutex() will not return while the mutex is locked by</para>
        /// <para>another thread. See SDL_TryLockMutex() to attempt to lock without blocking.</para>
        /// <para>SDL mutexes are reentrant.</para>
        /// <para>the initialized and unlocked mutex or NULL on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_DestroyMutex</para>
        /// <para>SDL_LockMutex</para>
        /// <para>SDL_TryLockMutex</para>
        /// <para>SDL_UnlockMutex</para>
        /// </remarks>
        public static global::SDL3Sharp.Mutex CreateMutex()
        {
            var ___ret = __Internal.CreateMutex();
            var __result0 = global::SDL3Sharp.Mutex.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Lock the mutex.</summary>
        /// <param name="mutex">the mutex to lock</param>
        /// <remarks>
        /// <para>This will block until the mutex is available, which is to say it is in the</para>
        /// <para>unlocked state and the OS has chosen the caller as the next thread to lock</para>
        /// <para>it. Of all threads waiting to lock the mutex, only one may do so at a time.</para>
        /// <para>It is legal for the owning thread to lock an already-locked mutex. It must</para>
        /// <para>unlock it the same number of times before it is actually made available for</para>
        /// <para>other threads in the system (this is known as a &quot;recursive mutex&quot;).</para>
        /// <para>This function does not fail; if mutex is NULL, it will return immediately</para>
        /// <para>having locked nothing. If the mutex is valid, this function will always</para>
        /// <para>block until it can lock the mutex, and return with it locked.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static void LockMutex(global::SDL3Sharp.Mutex mutex)
        {
            var __arg0 = mutex is null ? __IntPtr.Zero : mutex.__Instance;
            __Internal.LockMutex(__arg0);
        }

        /// <summary>Try to lock a mutex without blocking.</summary>
        /// <param name="mutex">the mutex to try to lock</param>
        /// <remarks>
        /// <para>This works just like SDL_LockMutex(), but if the mutex is not available,</para>
        /// <para>this function returns `SDL_MUTEX_TIMEDOUT` immediately.</para>
        /// <para>This technique is useful if you need exclusive access to a resource but</para>
        /// <para>don't want to wait for it, and will return to it to try again later.</para>
        /// <para>This function does not fail; if mutex is NULL, it will return 0 immediately</para>
        /// <para>having locked nothing. If the mutex is valid, this function will always</para>
        /// <para>either lock the mutex and return 0, or return SDL_MUTEX_TIMEOUT and lock</para>
        /// <para>nothing.</para>
        /// <para>0 or `SDL_MUTEX_TIMEDOUT`</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateMutex</para>
        /// <para>SDL_DestroyMutex</para>
        /// <para>SDL_LockMutex</para>
        /// <para>SDL_UnlockMutex</para>
        /// </remarks>
        public static int TryLockMutex(global::SDL3Sharp.Mutex mutex)
        {
            var __arg0 = mutex is null ? __IntPtr.Zero : mutex.__Instance;
            var ___ret = __Internal.TryLockMutex(__arg0);
            return ___ret;
        }

        /// <summary>Unlock the mutex.</summary>
        /// <param name="mutex">the mutex to unlock.</param>
        /// <remarks>
        /// <para>It is legal for the owning thread to lock an already-locked mutex. It must</para>
        /// <para>unlock it the same number of times before it is actually made available for</para>
        /// <para>other threads in the system (this is known as a &quot;recursive mutex&quot;).</para>
        /// <para>It is illegal to unlock a mutex that has not been locked by the current</para>
        /// <para>thread, and doing so results in undefined behavior.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static void UnlockMutex(global::SDL3Sharp.Mutex mutex)
        {
            var __arg0 = mutex is null ? __IntPtr.Zero : mutex.__Instance;
            __Internal.UnlockMutex(__arg0);
        }

        /// <summary>Destroy a mutex created with SDL_CreateMutex().</summary>
        /// <param name="mutex">the mutex to destroy</param>
        /// <remarks>
        /// <para>This function must be called on any mutex that is no longer needed. Failure</para>
        /// <para>to destroy a mutex will result in a system memory or resource leak. While</para>
        /// <para>it is safe to destroy a mutex that is _unlocked_, it is not safe to attempt</para>
        /// <para>to destroy a locked mutex, and may result in undefined behavior depending</para>
        /// <para>on the platform.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateMutex</para>
        /// <para>SDL_LockMutex</para>
        /// <para>SDL_TryLockMutex</para>
        /// <para>SDL_UnlockMutex</para>
        /// </remarks>
        public static void DestroyMutex(global::SDL3Sharp.Mutex mutex)
        {
            var __arg0 = mutex is null ? __IntPtr.Zero : mutex.__Instance;
            __Internal.DestroyMutex(__arg0);
        }

        /// <summary>Create a new read/write lock.</summary>
        /// <remarks>
        /// <para>A read/write lock is useful for situations where you have multiple threads</para>
        /// <para>trying to access a resource that is rarely updated. All threads requesting</para>
        /// <para>a read-only lock will be allowed to run in parallel; if a thread requests a</para>
        /// <para>write lock, it will be provided exclusive access. This makes it safe for</para>
        /// <para>multiple threads to use a resource at the same time if they promise not to</para>
        /// <para>change it, and when it has to be changed, the rwlock will serve as a</para>
        /// <para>gateway to make sure those changes can be made safely.</para>
        /// <para>In the right situation, a rwlock can be more efficient than a mutex, which</para>
        /// <para>only lets a single thread proceed at a time, even if it won't be modifying</para>
        /// <para>the data.</para>
        /// <para>All newly-created read/write locks begin in the _unlocked_ state.</para>
        /// <para>Calls to SDL_LockRWLockForReading() and SDL_LockRWLockForWriting will not</para>
        /// <para>return while the rwlock is locked _for writing_ by another thread. See</para>
        /// <para>SDL_TryLockRWLockForReading() and SDL_TryLockRWLockForWriting() to attempt</para>
        /// <para>to lock without blocking.</para>
        /// <para>SDL read/write locks are only recursive for read-only locks! They are not</para>
        /// <para>guaranteed to be fair, or provide access in a FIFO manner! They are not</para>
        /// <para>guaranteed to favor writers. You may not lock a rwlock for both read-only</para>
        /// <para>and write access at the same time from the same thread (so you can't</para>
        /// <para>promote your read-only lock to a write lock without unlocking first).</para>
        /// <para>the initialized and unlocked read/write lock or NULL on failure;</para>
        /// <para>call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_DestroyRWLock</para>
        /// <para>SDL_LockRWLockForReading</para>
        /// <para>SDL_TryLockRWLockForReading</para>
        /// <para>SDL_LockRWLockForWriting</para>
        /// <para>SDL_TryLockRWLockForWriting</para>
        /// <para>SDL_UnlockRWLock</para>
        /// </remarks>
        public static global::SDL3Sharp.RWLock CreateRWLock()
        {
            var ___ret = __Internal.CreateRWLock();
            var __result0 = global::SDL3Sharp.RWLock.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Lock the read/write lock for _read only_ operations.</summary>
        /// <param name="rwlock">the read/write lock to lock</param>
        /// <remarks>
        /// <para>This will block until the rwlock is available, which is to say it is not</para>
        /// <para>locked for writing by any other thread. Of all threads waiting to lock the</para>
        /// <para>rwlock, all may do so at the same time as long as they are requesting</para>
        /// <para>read-only access; if a thread wants to lock for writing, only one may do so</para>
        /// <para>at a time, and no other threads, read-only or not, may hold the lock at the</para>
        /// <para>same time.</para>
        /// <para>It is legal for the owning thread to lock an already-locked rwlock for</para>
        /// <para>reading. It must unlock it the same number of times before it is actually</para>
        /// <para>made available for other threads in the system (this is known as a</para>
        /// <para>&quot;recursive rwlock&quot;).</para>
        /// <para>Note that locking for writing is not recursive (this is only available to</para>
        /// <para>read-only locks).</para>
        /// <para>It is illegal to request a read-only lock from a thread that already holds</para>
        /// <para>the write lock. Doing so results in undefined behavior. Unlock the write</para>
        /// <para>lock before requesting a read-only lock. (But, of course, if you have the</para>
        /// <para>write lock, you don't need further locks to read in any case.)</para>
        /// <para>This function does not fail; if rwlock is NULL, it will return immediately</para>
        /// <para>having locked nothing. If the rwlock is valid, this function will always</para>
        /// <para>block until it can lock the mutex, and return with it locked.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_UnlockRWLock</para>
        /// </remarks>
        public static void LockRWLockForReading(global::SDL3Sharp.RWLock rwlock)
        {
            var __arg0 = rwlock is null ? __IntPtr.Zero : rwlock.__Instance;
            __Internal.LockRWLockForReading(__arg0);
        }

        /// <summary>Lock the read/write lock for _write_ operations.</summary>
        /// <param name="rwlock">the read/write lock to lock</param>
        /// <remarks>
        /// <para>This will block until the rwlock is available, which is to say it is not</para>
        /// <para>locked for reading or writing by any other thread. Only one thread may hold</para>
        /// <para>the lock when it requests write access; all other threads, whether they</para>
        /// <para>also want to write or only want read-only access, must wait until the</para>
        /// <para>writer thread has released the lock.</para>
        /// <para>It is illegal for the owning thread to lock an already-locked rwlock for</para>
        /// <para>writing (read-only may be locked recursively, writing can not). Doing so</para>
        /// <para>results in undefined behavior.</para>
        /// <para>It is illegal to request a write lock from a thread that already holds a</para>
        /// <para>read-only lock. Doing so results in undefined behavior. Unlock the</para>
        /// <para>read-only lock before requesting a write lock.</para>
        /// <para>This function does not fail; if rwlock is NULL, it will return immediately</para>
        /// <para>having locked nothing. If the rwlock is valid, this function will always</para>
        /// <para>block until it can lock the mutex, and return with it locked.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_UnlockRWLock</para>
        /// </remarks>
        public static void LockRWLockForWriting(global::SDL3Sharp.RWLock rwlock)
        {
            var __arg0 = rwlock is null ? __IntPtr.Zero : rwlock.__Instance;
            __Internal.LockRWLockForWriting(__arg0);
        }

        /// <summary>Try to lock a read/write lock _for reading_ without blocking.</summary>
        /// <param name="rwlock">the rwlock to try to lock</param>
        /// <remarks>
        /// <para>This works just like SDL_LockRWLockForReading(), but if the rwlock is not</para>
        /// <para>available, then this function returns `SDL_RWLOCK_TIMEDOUT` immediately.</para>
        /// <para>This technique is useful if you need access to a resource but don't want to</para>
        /// <para>wait for it, and will return to it to try again later.</para>
        /// <para>Trying to lock for read-only access can succeed if other threads are</para>
        /// <para>holding read-only locks, as this won't prevent access.</para>
        /// <para>This function does not fail; if rwlock is NULL, it will return 0</para>
        /// <para>immediately having locked nothing. If rwlock is valid, this function will</para>
        /// <para>always either lock the rwlock and return 0, or return SDL_RWLOCK_TIMEOUT</para>
        /// <para>and lock nothing.</para>
        /// <para>0 or `SDL_RWLOCK_TIMEDOUT`</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateRWLock</para>
        /// <para>SDL_DestroyRWLock</para>
        /// <para>SDL_TryLockRWLockForReading</para>
        /// <para>SDL_UnlockRWLock</para>
        /// </remarks>
        public static int TryLockRWLockForReading(global::SDL3Sharp.RWLock rwlock)
        {
            var __arg0 = rwlock is null ? __IntPtr.Zero : rwlock.__Instance;
            var ___ret = __Internal.TryLockRWLockForReading(__arg0);
            return ___ret;
        }

        /// <summary>Try to lock a read/write lock _for writing_ without blocking.</summary>
        /// <param name="rwlock">the rwlock to try to lock</param>
        /// <remarks>
        /// <para>This works just like SDL_LockRWLockForWriting(), but if the rwlock is not</para>
        /// <para>available, this function returns `SDL_RWLOCK_TIMEDOUT` immediately.</para>
        /// <para>This technique is useful if you need exclusive access to a resource but</para>
        /// <para>don't want to wait for it, and will return to it to try again later.</para>
        /// <para>It is illegal for the owning thread to lock an already-locked rwlock for</para>
        /// <para>writing (read-only may be locked recursively, writing can not). Doing so</para>
        /// <para>results in undefined behavior.</para>
        /// <para>It is illegal to request a write lock from a thread that already holds a</para>
        /// <para>read-only lock. Doing so results in undefined behavior. Unlock the</para>
        /// <para>read-only lock before requesting a write lock.</para>
        /// <para>This function does not fail; if rwlock is NULL, it will return 0</para>
        /// <para>immediately having locked nothing. If rwlock is valid, this function will</para>
        /// <para>always either lock the rwlock and return 0, or return SDL_RWLOCK_TIMEOUT</para>
        /// <para>and lock nothing.</para>
        /// <para>0 or `SDL_RWLOCK_TIMEDOUT`</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateRWLock</para>
        /// <para>SDL_DestroyRWLock</para>
        /// <para>SDL_TryLockRWLockForWriting</para>
        /// <para>SDL_UnlockRWLock</para>
        /// </remarks>
        public static int TryLockRWLockForWriting(global::SDL3Sharp.RWLock rwlock)
        {
            var __arg0 = rwlock is null ? __IntPtr.Zero : rwlock.__Instance;
            var ___ret = __Internal.TryLockRWLockForWriting(__arg0);
            return ___ret;
        }

        /// <summary>Unlock the read/write lock.</summary>
        /// <param name="rwlock">the rwlock to unlock.</param>
        /// <remarks>
        /// <para>Use this function to unlock the rwlock, whether it was locked for read-only</para>
        /// <para>or write operations.</para>
        /// <para>It is legal for the owning thread to lock an already-locked read-only lock.</para>
        /// <para>It must unlock it the same number of times before it is actually made</para>
        /// <para>available for other threads in the system (this is known as a &quot;recursive</para>
        /// <para>rwlock&quot;).</para>
        /// <para>It is illegal to unlock a rwlock that has not been locked by the current</para>
        /// <para>thread, and doing so results in undefined behavior.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static void UnlockRWLock(global::SDL3Sharp.RWLock rwlock)
        {
            var __arg0 = rwlock is null ? __IntPtr.Zero : rwlock.__Instance;
            __Internal.UnlockRWLock(__arg0);
        }

        /// <summary>Destroy a read/write lock created with SDL_CreateRWLock().</summary>
        /// <param name="rwlock">the rwlock to destroy</param>
        /// <remarks>
        /// <para>This function must be called on any read/write lock that is no longer</para>
        /// <para>needed. Failure to destroy a rwlock will result in a system memory or</para>
        /// <para>resource leak. While it is safe to destroy a rwlock that is _unlocked_, it</para>
        /// <para>is not safe to attempt to destroy a locked rwlock, and may result in</para>
        /// <para>undefined behavior depending on the platform.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateRWLock</para>
        /// <para>SDL_LockRWLockForReading</para>
        /// <para>SDL_LockRWLockForWriting</para>
        /// <para>SDL_TryLockRWLockForReading</para>
        /// <para>SDL_TryLockRWLockForWriting</para>
        /// <para>SDL_UnlockRWLock</para>
        /// </remarks>
        public static void DestroyRWLock(global::SDL3Sharp.RWLock rwlock)
        {
            var __arg0 = rwlock is null ? __IntPtr.Zero : rwlock.__Instance;
            __Internal.DestroyRWLock(__arg0);
        }

        /// <summary>Create a semaphore.</summary>
        /// <param name="initial_value">the starting value of the semaphore</param>
        /// <remarks>
        /// <para>This function creates a new semaphore and initializes it with the value</para>
        /// <para>`initial_value`. Each wait operation on the semaphore will atomically</para>
        /// <para>decrement the semaphore value and potentially block if the semaphore value</para>
        /// <para>is 0. Each post operation will atomically increment the semaphore value and</para>
        /// <para>wake waiting threads and allow them to retry the wait operation.</para>
        /// <para>a new semaphore or NULL on failure; call SDL_GetError() for more</para>
        /// <para>information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_DestroySemaphore</para>
        /// <para>SDL_PostSemaphore</para>
        /// <para>SDL_TryWaitSemaphore</para>
        /// <para>SDL_GetSemaphoreValue</para>
        /// <para>SDL_WaitSemaphore</para>
        /// <para>SDL_WaitSemaphoreTimeout</para>
        /// </remarks>
        public static global::SDL3Sharp.Semaphore CreateSemaphore(uint initial_value)
        {
            var ___ret = __Internal.CreateSemaphore(initial_value);
            var __result0 = global::SDL3Sharp.Semaphore.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Destroy a semaphore.</summary>
        /// <param name="sem">the semaphore to destroy</param>
        /// <remarks>
        /// <para>It is not safe to destroy a semaphore if there are threads currently</para>
        /// <para>waiting on it.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateSemaphore</para>
        /// <para>SDL_PostSemaphore</para>
        /// <para>SDL_TryWaitSemaphore</para>
        /// <para>SDL_GetSemaphoreValue</para>
        /// <para>SDL_WaitSemaphore</para>
        /// <para>SDL_WaitSemaphoreTimeout</para>
        /// </remarks>
        public static void DestroySemaphore(global::SDL3Sharp.Semaphore sem)
        {
            var __arg0 = sem is null ? __IntPtr.Zero : sem.__Instance;
            __Internal.DestroySemaphore(__arg0);
        }

        /// <summary>Wait until a semaphore has a positive value and then decrements it.</summary>
        /// <param name="sem">the semaphore wait on</param>
        /// <remarks>
        /// <para>This function suspends the calling thread until either the semaphore</para>
        /// <para>pointed to by `sem` has a positive value or the call is interrupted by a</para>
        /// <para>signal or error. If the call is successful it will atomically decrement the</para>
        /// <para>semaphore value.</para>
        /// <para>This function is the equivalent of calling SDL_WaitSemaphoreTimeout() with</para>
        /// <para>a time length of -1.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateSemaphore</para>
        /// <para>SDL_DestroySemaphore</para>
        /// <para>SDL_PostSemaphore</para>
        /// <para>SDL_TryWaitSemaphore</para>
        /// <para>SDL_GetSemaphoreValue</para>
        /// <para>SDL_WaitSemaphore</para>
        /// <para>SDL_WaitSemaphoreTimeout</para>
        /// </remarks>
        public static int WaitSemaphore(global::SDL3Sharp.Semaphore sem)
        {
            var __arg0 = sem is null ? __IntPtr.Zero : sem.__Instance;
            var ___ret = __Internal.WaitSemaphore(__arg0);
            return ___ret;
        }

        /// <summary>See if a semaphore has a positive value and decrement it if it does.</summary>
        /// <param name="sem">the semaphore to wait on</param>
        /// <remarks>
        /// <para>This function checks to see if the semaphore pointed to by `sem` has a</para>
        /// <para>positive value and atomically decrements the semaphore value if it does. If</para>
        /// <para>the semaphore doesn't have a positive value, the function immediately</para>
        /// <para>returns SDL_MUTEX_TIMEDOUT.</para>
        /// <para>0 if the wait succeeds, `SDL_MUTEX_TIMEDOUT` if the wait would</para>
        /// <para>block, or a negative error code on failure; call SDL_GetError()</para>
        /// <para>for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateSemaphore</para>
        /// <para>SDL_DestroySemaphore</para>
        /// <para>SDL_PostSemaphore</para>
        /// <para>SDL_GetSemaphoreValue</para>
        /// <para>SDL_WaitSemaphore</para>
        /// <para>SDL_WaitSemaphoreTimeout</para>
        /// </remarks>
        public static int TryWaitSemaphore(global::SDL3Sharp.Semaphore sem)
        {
            var __arg0 = sem is null ? __IntPtr.Zero : sem.__Instance;
            var ___ret = __Internal.TryWaitSemaphore(__arg0);
            return ___ret;
        }

        /// <summary>Wait until a semaphore has a positive value and then decrements it.</summary>
        /// <param name="sem">the semaphore to wait on</param>
        /// <param name="timeoutMS">the length of the timeout, in milliseconds</param>
        /// <remarks>
        /// <para>This function suspends the calling thread until either the semaphore</para>
        /// <para>pointed to by `sem` has a positive value, the call is interrupted by a</para>
        /// <para>signal or error, or the specified time has elapsed. If the call is</para>
        /// <para>successful it will atomically decrement the semaphore value.</para>
        /// <para>0 if the wait succeeds, `SDL_MUTEX_TIMEDOUT` if the wait does not</para>
        /// <para>succeed in the allotted time, or a negative error code on failure;</para>
        /// <para>call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateSemaphore</para>
        /// <para>SDL_DestroySemaphore</para>
        /// <para>SDL_PostSemaphore</para>
        /// <para>SDL_TryWaitSemaphore</para>
        /// <para>SDL_GetSemaphoreValue</para>
        /// <para>SDL_WaitSemaphore</para>
        /// </remarks>
        public static int WaitSemaphoreTimeout(global::SDL3Sharp.Semaphore sem, int timeoutMS)
        {
            var __arg0 = sem is null ? __IntPtr.Zero : sem.__Instance;
            var ___ret = __Internal.WaitSemaphoreTimeout(__arg0, timeoutMS);
            return ___ret;
        }

        /// <summary>Atomically increment a semaphore's value and wake waiting threads.</summary>
        /// <param name="sem">the semaphore to increment</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateSemaphore</para>
        /// <para>SDL_DestroySemaphore</para>
        /// <para>SDL_TryWaitSemaphore</para>
        /// <para>SDL_GetSemaphoreValue</para>
        /// <para>SDL_WaitSemaphore</para>
        /// <para>SDL_WaitSemaphoreTimeout</para>
        /// </remarks>
        public static int PostSemaphore(global::SDL3Sharp.Semaphore sem)
        {
            var __arg0 = sem is null ? __IntPtr.Zero : sem.__Instance;
            var ___ret = __Internal.PostSemaphore(__arg0);
            return ___ret;
        }

        /// <summary>Get the current value of a semaphore.</summary>
        /// <param name="sem">the semaphore to query</param>
        /// <remarks>
        /// <para>the current value of the semaphore.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CreateSemaphore</para>
        /// </remarks>
        public static uint GetSemaphoreValue(global::SDL3Sharp.Semaphore sem)
        {
            var __arg0 = sem is null ? __IntPtr.Zero : sem.__Instance;
            var ___ret = __Internal.GetSemaphoreValue(__arg0);
            return ___ret;
        }

        /// <summary>Create a condition variable.</summary>
        /// <remarks>
        /// <para>a new condition variable or NULL on failure; call SDL_GetError()</para>
        /// <para>for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_BroadcastCondition</para>
        /// <para>SDL_SignalCondition</para>
        /// <para>SDL_WaitCondition</para>
        /// <para>SDL_WaitConditionTimeout</para>
        /// <para>SDL_DestroyCondition</para>
        /// </remarks>
        public static global::SDL3Sharp.Condition CreateCondition()
        {
            var ___ret = __Internal.CreateCondition();
            var __result0 = global::SDL3Sharp.Condition.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Destroy a condition variable.</summary>
        /// <param name="cond">the condition variable to destroy</param>
        /// <remarks>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_BroadcastCondition</para>
        /// <para>SDL_SignalCondition</para>
        /// <para>SDL_WaitCondition</para>
        /// <para>SDL_WaitConditionTimeout</para>
        /// <para>SDL_CreateCondition</para>
        /// </remarks>
        public static void DestroyCondition(global::SDL3Sharp.Condition cond)
        {
            var __arg0 = cond is null ? __IntPtr.Zero : cond.__Instance;
            __Internal.DestroyCondition(__arg0);
        }

        /// <summary>Restart one of the threads that are waiting on the condition variable.</summary>
        /// <param name="cond">the condition variable to signal</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_BroadcastCondition</para>
        /// <para>SDL_WaitCondition</para>
        /// <para>SDL_WaitConditionTimeout</para>
        /// <para>SDL_CreateCondition</para>
        /// <para>SDL_DestroyCondition</para>
        /// </remarks>
        public static int SignalCondition(global::SDL3Sharp.Condition cond)
        {
            var __arg0 = cond is null ? __IntPtr.Zero : cond.__Instance;
            var ___ret = __Internal.SignalCondition(__arg0);
            return ___ret;
        }

        /// <summary>Restart all threads that are waiting on the condition variable.</summary>
        /// <param name="cond">the condition variable to signal</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_SignalCondition</para>
        /// <para>SDL_WaitCondition</para>
        /// <para>SDL_WaitConditionTimeout</para>
        /// <para>SDL_CreateCondition</para>
        /// <para>SDL_DestroyCondition</para>
        /// </remarks>
        public static int BroadcastCondition(global::SDL3Sharp.Condition cond)
        {
            var __arg0 = cond is null ? __IntPtr.Zero : cond.__Instance;
            var ___ret = __Internal.BroadcastCondition(__arg0);
            return ___ret;
        }

        /// <summary>Wait until a condition variable is signaled.</summary>
        /// <param name="cond">the condition variable to wait on</param>
        /// <param name="mutex">the mutex used to coordinate thread access</param>
        /// <remarks>
        /// <para>This function unlocks the specified `mutex` and waits for another thread to</para>
        /// <para>call SDL_SignalCondition() or SDL_BroadcastCondition() on the condition</para>
        /// <para>variable `cond`. Once the condition variable is signaled, the mutex is</para>
        /// <para>re-locked and the function returns.</para>
        /// <para>The mutex must be locked before calling this function. Locking the mutex</para>
        /// <para>recursively (more than once) is not supported and leads to undefined</para>
        /// <para>behavior.</para>
        /// <para>This function is the equivalent of calling SDL_WaitConditionTimeout() with</para>
        /// <para>a time length of -1.</para>
        /// <para>0 when it is signaled or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_BroadcastCondition</para>
        /// <para>SDL_SignalCondition</para>
        /// <para>SDL_WaitConditionTimeout</para>
        /// <para>SDL_CreateCondition</para>
        /// <para>SDL_DestroyCondition</para>
        /// </remarks>
        public static int WaitCondition(global::SDL3Sharp.Condition cond, global::SDL3Sharp.Mutex mutex)
        {
            var __arg0 = cond is null ? __IntPtr.Zero : cond.__Instance;
            var __arg1 = mutex is null ? __IntPtr.Zero : mutex.__Instance;
            var ___ret = __Internal.WaitCondition(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Wait until a condition variable is signaled or a certain time has passed.</summary>
        /// <param name="cond">the condition variable to wait on</param>
        /// <param name="mutex">the mutex used to coordinate thread access</param>
        /// <param name="timeoutMS">
        /// <para>the maximum time to wait, in milliseconds, or -1 to wait</para>
        /// <para>indefinitely</para>
        /// </param>
        /// <remarks>
        /// <para>This function unlocks the specified `mutex` and waits for another thread to</para>
        /// <para>call SDL_SignalCondition() or SDL_BroadcastCondition() on the condition</para>
        /// <para>variable `cond`, or for the specified time to elapse. Once the condition</para>
        /// <para>variable is signaled or the time elapsed, the mutex is re-locked and the</para>
        /// <para>function returns.</para>
        /// <para>The mutex must be locked before calling this function. Locking the mutex</para>
        /// <para>recursively (more than once) is not supported and leads to undefined</para>
        /// <para>behavior.</para>
        /// <para>0 if the condition variable is signaled, `SDL_MUTEX_TIMEDOUT` if</para>
        /// <para>the condition is not signaled in the allotted time, or a negative</para>
        /// <para>error code on failure; call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_BroadcastCondition</para>
        /// <para>SDL_SignalCondition</para>
        /// <para>SDL_WaitCondition</para>
        /// <para>SDL_CreateCondition</para>
        /// <para>SDL_DestroyCondition</para>
        /// </remarks>
        public static int WaitConditionTimeout(global::SDL3Sharp.Condition cond, global::SDL3Sharp.Mutex mutex, int timeoutMS)
        {
            var __arg0 = cond is null ? __IntPtr.Zero : cond.__Instance;
            var __arg1 = mutex is null ? __IntPtr.Zero : mutex.__Instance;
            var ___ret = __Internal.WaitConditionTimeout(__arg0, __arg1, timeoutMS);
            return ___ret;
        }
    }
}
