// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required
#pragma warning disable CS9084 // Struct member returns 'this' or other instance members by reference

namespace SDL3Sharp
{
    /// <summary>HID underlying bus types.</summary>
    public enum HidBusType
    {
        /// <summary>Unknown bus type</summary>
        Unknown = 0,
        /// <summary>
        /// <para>USB bus</para>
        /// <para>Specifications:</para>
        /// <para>https://usb.org/hid</para>
        /// </summary>
        Usb = 1,
        /// <summary>
        /// <para>Bluetooth or Bluetooth LE bus</para>
        /// <para>Specifications:</para>
        /// <para>https://www.bluetooth.com/specifications/specs/human-interface-device-profile-1-1-1/</para>
        /// <para>https://www.bluetooth.com/specifications/specs/hid-service-1-0/</para>
        /// <para>https://www.bluetooth.com/specifications/specs/hid-over-gatt-profile-1-0/</para>
        /// </summary>
        Bluetooth = 2,
        /// <summary>
        /// <para>I2C bus</para>
        /// <para>Specifications:</para>
        /// <para>https://docs.microsoft.com/previous-versions/windows/hardware/design/dn642101(v=vs.85)</para>
        /// </summary>
        I2c = 3,
        /// <summary>
        /// <para>SPI bus</para>
        /// <para>Specifications:</para>
        /// <para>https://www.microsoft.com/download/details.aspx?id=103325</para>
        /// </summary>
        Spi = 4
    }

    /// <summary>HID underlying bus types.</summary>
    /// <summary>hidapi info structure</summary>
    /// <remarks>Information about a connected HID device</remarks>
    /// <summary>A handle representing an open HID device</summary>
    public unsafe partial class HidDevice
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.HidDevice> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.HidDevice>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.HidDevice managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.HidDevice managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static HidDevice __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new HidDevice(native.ToPointer(), skipVTables);
        }

        internal static HidDevice __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (HidDevice)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static HidDevice __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new HidDevice(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private HidDevice(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected HidDevice(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    /// <summary>hidapi info structure</summary>
    /// <remarks>Information about a connected HID device</remarks>
    public unsafe partial class HidDeviceInfo : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 80, Pack = 8)]
        public partial struct __Internal
        {
            internal __IntPtr path;
            internal ushort vendor_id;
            internal ushort product_id;
            internal __IntPtr serial_number;
            internal ushort release_number;
            internal __IntPtr manufacturer_string;
            internal __IntPtr product_string;
            internal ushort usage_page;
            internal ushort usage;
            internal int interface_number;
            internal int interface_class;
            internal int interface_subclass;
            internal int interface_protocol;
            internal global::SDL3Sharp.HidBusType bus_type;
            internal __IntPtr next;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_hid_device_info@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.HidDeviceInfo> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.HidDeviceInfo>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.HidDeviceInfo managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.HidDeviceInfo managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static HidDeviceInfo __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new HidDeviceInfo(native.ToPointer(), skipVTables);
        }

        internal static HidDeviceInfo __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (HidDeviceInfo)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static HidDeviceInfo __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new HidDeviceInfo(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private HidDeviceInfo(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected HidDeviceInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public HidDeviceInfo()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.HidDeviceInfo.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public HidDeviceInfo(global::SDL3Sharp.HidDeviceInfo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.HidDeviceInfo.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.HidDeviceInfo.__Internal*) __Instance) = *((global::SDL3Sharp.HidDeviceInfo.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Platform-specific device path</summary>
        public sbyte* Path
        {
            get
            {
                return (sbyte*) ((__Internal*)__Instance)->path;
            }

            set
            {
                ((__Internal*)__Instance)->path = (__IntPtr) value;
            }
        }

        /// <summary>Device Vendor ID</summary>
        public ushort VendorId
        {
            get
            {
                return ((__Internal*)__Instance)->vendor_id;
            }

            set
            {
                ((__Internal*)__Instance)->vendor_id = value;
            }
        }

        /// <summary>Device Product ID</summary>
        public ushort ProductId
        {
            get
            {
                return ((__Internal*)__Instance)->product_id;
            }

            set
            {
                ((__Internal*)__Instance)->product_id = value;
            }
        }

        /// <summary>Serial Number</summary>
        public char* SerialNumber
        {
            get
            {
                return (char*) ((__Internal*)__Instance)->serial_number;
            }

            set
            {
                ((__Internal*)__Instance)->serial_number = (__IntPtr) value;
            }
        }

        /// <summary>
        /// <para>Device Release Number in binary-coded decimal,</para>
        /// <para>also known as Device Version Number</para>
        /// </summary>
        public ushort ReleaseNumber
        {
            get
            {
                return ((__Internal*)__Instance)->release_number;
            }

            set
            {
                ((__Internal*)__Instance)->release_number = value;
            }
        }

        /// <summary>Manufacturer String</summary>
        public char* ManufacturerString
        {
            get
            {
                return (char*) ((__Internal*)__Instance)->manufacturer_string;
            }

            set
            {
                ((__Internal*)__Instance)->manufacturer_string = (__IntPtr) value;
            }
        }

        /// <summary>Product string</summary>
        public char* ProductString
        {
            get
            {
                return (char*) ((__Internal*)__Instance)->product_string;
            }

            set
            {
                ((__Internal*)__Instance)->product_string = (__IntPtr) value;
            }
        }

        /// <summary>
        /// <para>Usage Page for this Device/Interface</para>
        /// <para>(Windows/Mac/hidraw only)</para>
        /// </summary>
        public ushort UsagePage
        {
            get
            {
                return ((__Internal*)__Instance)->usage_page;
            }

            set
            {
                ((__Internal*)__Instance)->usage_page = value;
            }
        }

        /// <summary>
        /// <para>Usage for this Device/Interface</para>
        /// <para>(Windows/Mac/hidraw only)</para>
        /// </summary>
        public ushort Usage
        {
            get
            {
                return ((__Internal*)__Instance)->usage;
            }

            set
            {
                ((__Internal*)__Instance)->usage = value;
            }
        }

        /// <summary>
        /// <para>The USB interface which this logical device</para>
        /// <para>represents.</para>
        /// </summary>
        /// <remarks>
        /// <para>Valid only if the device is a USB HID device.</para>
        /// <para>Set to -1 in all other cases.</para>
        /// </remarks>
        public int InterfaceNumber
        {
            get
            {
                return ((__Internal*)__Instance)->interface_number;
            }

            set
            {
                ((__Internal*)__Instance)->interface_number = value;
            }
        }

        /// <summary>
        /// <para>Additional information about the USB interface.</para>
        /// <para>Valid on libusb and Android implementations.</para>
        /// </summary>
        public int InterfaceClass
        {
            get
            {
                return ((__Internal*)__Instance)->interface_class;
            }

            set
            {
                ((__Internal*)__Instance)->interface_class = value;
            }
        }

        public int InterfaceSubclass
        {
            get
            {
                return ((__Internal*)__Instance)->interface_subclass;
            }

            set
            {
                ((__Internal*)__Instance)->interface_subclass = value;
            }
        }

        public int InterfaceProtocol
        {
            get
            {
                return ((__Internal*)__Instance)->interface_protocol;
            }

            set
            {
                ((__Internal*)__Instance)->interface_protocol = value;
            }
        }

        /// <summary>Underlying bus type</summary>
        public global::SDL3Sharp.HidBusType BusType
        {
            get
            {
                return ((__Internal*)__Instance)->bus_type;
            }

            set
            {
                ((__Internal*)__Instance)->bus_type = value;
            }
        }

        /// <summary>Pointer to the next device</summary>
        public global::SDL3Sharp.HidDeviceInfo Next
        {
            get
            {
                var __result0 = global::SDL3Sharp.HidDeviceInfo.__GetOrCreateInstance(((__Internal*)__Instance)->next, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->next = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class SDL
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_hid_init", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int HidInit();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_hid_exit", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int HidExit();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_hid_device_change_count", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint HidDeviceChangeCount();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_hid_enumerate", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr HidEnumerate(ushort vendor_id, ushort product_id);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_hid_free_enumeration", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void HidFreeEnumeration(__IntPtr devs);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_hid_open", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr HidOpen(ushort vendor_id, ushort product_id, [MarshalAs(UnmanagedType.LPWStr)] string serial_number);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_hid_open_path", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr HidOpenPath([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string path);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_hid_write", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int HidWrite(__IntPtr dev, byte* data, ulong length);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_hid_read_timeout", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int HidReadTimeout(__IntPtr dev, byte* data, ulong length, int milliseconds);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_hid_read", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int HidRead(__IntPtr dev, byte* data, ulong length);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_hid_set_nonblocking", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int HidSetNonblocking(__IntPtr dev, int nonblock);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_hid_send_feature_report", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int HidSendFeatureReport(__IntPtr dev, byte* data, ulong length);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_hid_get_feature_report", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int HidGetFeatureReport(__IntPtr dev, byte* data, ulong length);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_hid_get_input_report", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int HidGetInputReport(__IntPtr dev, byte* data, ulong length);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_hid_close", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int HidClose(__IntPtr dev);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_hid_get_manufacturer_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int HidGetManufacturerString(__IntPtr dev, char* @string, ulong maxlen);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_hid_get_product_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int HidGetProductString(__IntPtr dev, char* @string, ulong maxlen);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_hid_get_serial_number_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int HidGetSerialNumberString(__IntPtr dev, char* @string, ulong maxlen);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_hid_get_indexed_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int HidGetIndexedString(__IntPtr dev, int string_index, char* @string, ulong maxlen);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_hid_get_device_info", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr HidGetDeviceInfo(__IntPtr dev);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_hid_get_report_descriptor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int HidGetReportDescriptor(__IntPtr dev, byte* buf, ulong buf_size);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_hid_ble_scan", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void HidBleScan(bool active);
        }

        /// <summary>Initialize the HIDAPI library.</summary>
        /// <remarks>
        /// <para>This function initializes the HIDAPI library. Calling it is not strictly</para>
        /// <para>necessary, as it will be called automatically by SDL_hid_enumerate() and</para>
        /// <para>any of the SDL_hid_open_*() functions if it is needed. This function should</para>
        /// <para>be called at the beginning of execution however, if there is a chance of</para>
        /// <para>HIDAPI handles being opened by different threads simultaneously.</para>
        /// <para>Each call to this function should have a matching call to SDL_hid_exit()</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_hid_exit</para>
        /// </remarks>
        public static int HidInit()
        {
            var ___ret = __Internal.HidInit();
            return ___ret;
        }

        /// <summary>Finalize the HIDAPI library.</summary>
        /// <remarks>
        /// <para>This function frees all of the static data associated with HIDAPI. It</para>
        /// <para>should be called at the end of execution to avoid memory leaks.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_hid_init</para>
        /// </remarks>
        public static int HidExit()
        {
            var ___ret = __Internal.HidExit();
            return ___ret;
        }

        /// <summary>Check to see if devices may have been added or removed.</summary>
        /// <remarks>
        /// <para>Enumerating the HID devices is an expensive operation, so you can call this</para>
        /// <para>to see if there have been any system device changes since the last call to</para>
        /// <para>this function. A change in the counter returned doesn't necessarily mean</para>
        /// <para>that anything has changed, but you can call SDL_hid_enumerate() to get an</para>
        /// <para>updated device list.</para>
        /// <para>Calling this function for the first time may cause a thread or other system</para>
        /// <para>resource to be allocated to track device change notifications.</para>
        /// <para>a change counter that is incremented with each potential device</para>
        /// <para>change, or 0 if device change detection isn't available.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_hid_enumerate</para>
        /// </remarks>
        public static uint HidDeviceChangeCount()
        {
            var ___ret = __Internal.HidDeviceChangeCount();
            return ___ret;
        }

        /// <summary>Enumerate the HID Devices.</summary>
        /// <param name="vendor_id">
        /// <para>The Vendor ID (VID) of the types of device to open, or 0</para>
        /// <para>to match any vendor.</para>
        /// </param>
        /// <param name="product_id">
        /// <para>The Product ID (PID) of the types of device to open, or 0</para>
        /// <para>to match any product.</para>
        /// </param>
        /// <remarks>
        /// <para>This function returns a linked list of all the HID devices attached to the</para>
        /// <para>system which match vendor_id and product_id. If `vendor_id` is set to 0</para>
        /// <para>then any vendor matches. If `product_id` is set to 0 then any product</para>
        /// <para>matches. If `vendor_id` and `product_id` are both set to 0, then all HID</para>
        /// <para>devices will be returned.</para>
        /// <para>By default SDL will only enumerate controllers, to reduce risk of hanging</para>
        /// <para>or crashing on bad drivers, but SDL_HINT_HIDAPI_ENUMERATE_ONLY_CONTROLLERS</para>
        /// <para>can be set to &quot;0&quot; to enumerate all HID devices.</para>
        /// <para>a pointer to a linked list of type SDL_hid_device_info, containing</para>
        /// <para>information about the HID devices attached to the system, or NULL</para>
        /// <para>in the case of failure. Free this linked list by calling</para>
        /// <para>SDL_hid_free_enumeration().</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_hid_device_change_count</para>
        /// </remarks>
        public static global::SDL3Sharp.HidDeviceInfo HidEnumerate(ushort vendor_id, ushort product_id)
        {
            var ___ret = __Internal.HidEnumerate(vendor_id, product_id);
            var __result0 = global::SDL3Sharp.HidDeviceInfo.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Free an enumeration Linked List</summary>
        /// <param name="devs">
        /// <para>Pointer to a list of struct_device returned from</para>
        /// <para>SDL_hid_enumerate().</para>
        /// </param>
        /// <remarks>
        /// <para>This function frees a linked list created by SDL_hid_enumerate().</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static void HidFreeEnumeration(global::SDL3Sharp.HidDeviceInfo devs)
        {
            var __arg0 = devs is null ? __IntPtr.Zero : devs.__Instance;
            __Internal.HidFreeEnumeration(__arg0);
        }

        /// <summary>
        /// <para>Open a HID device using a Vendor ID (VID), Product ID (PID) and optionally</para>
        /// <para>a serial number.</para>
        /// </summary>
        /// <param name="vendor_id">The Vendor ID (VID) of the device to open.</param>
        /// <param name="product_id">The Product ID (PID) of the device to open.</param>
        /// <param name="serial_number">
        /// <para>The Serial Number of the device to open (Optionally</para>
        /// <para>NULL).</para>
        /// </param>
        /// <remarks>
        /// <para>If `serial_number` is NULL, the first device with the specified VID and PID</para>
        /// <para>is opened.</para>
        /// <para>a pointer to a SDL_hid_device object on success or NULL on</para>
        /// <para>failure.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static global::SDL3Sharp.HidDevice HidOpen(ushort vendor_id, ushort product_id, string serial_number)
        {
            var ___ret = __Internal.HidOpen(vendor_id, product_id, serial_number);
            var __result0 = global::SDL3Sharp.HidDevice.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Open a HID device by its path name.</summary>
        /// <param name="path">The path name of the device to open</param>
        /// <remarks>
        /// <para>The path name be determined by calling SDL_hid_enumerate(), or a</para>
        /// <para>platform-specific path name can be used (eg: /dev/hidraw0 on Linux).</para>
        /// <para>a pointer to a SDL_hid_device object on success or NULL on</para>
        /// <para>failure.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static global::SDL3Sharp.HidDevice HidOpenPath(string path)
        {
            var ___ret = __Internal.HidOpenPath(path);
            var __result0 = global::SDL3Sharp.HidDevice.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Write an Output report to a HID device.</summary>
        /// <param name="dev">A device handle returned from SDL_hid_open().</param>
        /// <param name="data">
        /// <para>The data to send, including the report number as the first</para>
        /// <para>byte.</para>
        /// </param>
        /// <param name="length">The length in bytes of the data to send.</param>
        /// <remarks>
        /// <para>The first byte of `data` must contain the Report ID. For devices which only</para>
        /// <para>support a single report, this must be set to 0x0. The remaining bytes</para>
        /// <para>contain the report data. Since the Report ID is mandatory, calls to</para>
        /// <para>SDL_hid_write() will always contain one more byte than the report contains.</para>
        /// <para>For example, if a hid report is 16 bytes long, 17 bytes must be passed to</para>
        /// <para>SDL_hid_write(), the Report ID (or 0x0, for devices with a single report),</para>
        /// <para>followed by the report data (16 bytes). In this example, the length passed</para>
        /// <para>in would be 17.</para>
        /// <para>SDL_hid_write() will send the data on the first OUT endpoint, if one</para>
        /// <para>exists. If it does not, it will send the data through the Control Endpoint</para>
        /// <para>(Endpoint 0).</para>
        /// <para>the actual number of bytes written and -1 on error.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int HidWrite(global::SDL3Sharp.HidDevice dev, byte* data, ulong length)
        {
            var __arg0 = dev is null ? __IntPtr.Zero : dev.__Instance;
            var ___ret = __Internal.HidWrite(__arg0, data, length);
            return ___ret;
        }

        /// <summary>Read an Input report from a HID device with timeout.</summary>
        /// <param name="dev">A device handle returned from SDL_hid_open().</param>
        /// <param name="data">A buffer to put the read data into.</param>
        /// <param name="length">
        /// <para>The number of bytes to read. For devices with multiple</para>
        /// <para>reports, make sure to read an extra byte for the report</para>
        /// <para>number.</para>
        /// </param>
        /// <param name="milliseconds">timeout in milliseconds or -1 for blocking wait.</param>
        /// <remarks>
        /// <para>Input reports are returned to the host through the INTERRUPT IN endpoint.</para>
        /// <para>The first byte will contain the Report number if the device uses numbered</para>
        /// <para>reports.</para>
        /// <para>the actual number of bytes read and -1 on error. If no packet was</para>
        /// <para>available to be read within the timeout period, this function</para>
        /// <para>returns 0.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int HidReadTimeout(global::SDL3Sharp.HidDevice dev, byte* data, ulong length, int milliseconds)
        {
            var __arg0 = dev is null ? __IntPtr.Zero : dev.__Instance;
            var ___ret = __Internal.HidReadTimeout(__arg0, data, length, milliseconds);
            return ___ret;
        }

        /// <summary>Read an Input report from a HID device.</summary>
        /// <param name="dev">A device handle returned from SDL_hid_open().</param>
        /// <param name="data">A buffer to put the read data into.</param>
        /// <param name="length">
        /// <para>The number of bytes to read. For devices with multiple</para>
        /// <para>reports, make sure to read an extra byte for the report</para>
        /// <para>number.</para>
        /// </param>
        /// <remarks>
        /// <para>Input reports are returned to the host through the INTERRUPT IN endpoint.</para>
        /// <para>The first byte will contain the Report number if the device uses numbered</para>
        /// <para>reports.</para>
        /// <para>the actual number of bytes read and -1 on error. If no packet was</para>
        /// <para>available to be read and the handle is in non-blocking mode, this</para>
        /// <para>function returns 0.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int HidRead(global::SDL3Sharp.HidDevice dev, byte* data, ulong length)
        {
            var __arg0 = dev is null ? __IntPtr.Zero : dev.__Instance;
            var ___ret = __Internal.HidRead(__arg0, data, length);
            return ___ret;
        }

        /// <summary>Set the device handle to be non-blocking.</summary>
        /// <param name="dev">A device handle returned from SDL_hid_open().</param>
        /// <param name="nonblock">
        /// <para>enable or not the nonblocking reads - 1 to enable</para>
        /// <para>nonblocking - 0 to disable nonblocking.</para>
        /// </param>
        /// <remarks>
        /// <para>In non-blocking mode calls to SDL_hid_read() will return immediately with a</para>
        /// <para>value of 0 if there is no data to be read. In blocking mode, SDL_hid_read()</para>
        /// <para>will wait (block) until there is data to read before returning.</para>
        /// <para>Nonblocking can be turned on and off at any time.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int HidSetNonblocking(global::SDL3Sharp.HidDevice dev, int nonblock)
        {
            var __arg0 = dev is null ? __IntPtr.Zero : dev.__Instance;
            var ___ret = __Internal.HidSetNonblocking(__arg0, nonblock);
            return ___ret;
        }

        /// <summary>Send a Feature report to the device.</summary>
        /// <param name="dev">A device handle returned from SDL_hid_open().</param>
        /// <param name="data">
        /// <para>The data to send, including the report number as the first</para>
        /// <para>byte.</para>
        /// </param>
        /// <param name="length">
        /// <para>The length in bytes of the data to send, including the report</para>
        /// <para>number.</para>
        /// </param>
        /// <remarks>
        /// <para>Feature reports are sent over the Control endpoint as a Set_Report</para>
        /// <para>transfer. The first byte of `data` must contain the Report ID. For devices</para>
        /// <para>which only support a single report, this must be set to 0x0. The remaining</para>
        /// <para>bytes contain the report data. Since the Report ID is mandatory, calls to</para>
        /// <para>SDL_hid_send_feature_report() will always contain one more byte than the</para>
        /// <para>report contains. For example, if a hid report is 16 bytes long, 17 bytes</para>
        /// <para>must be passed to SDL_hid_send_feature_report(): the Report ID (or 0x0, for</para>
        /// <para>devices which do not use numbered reports), followed by the report data (16</para>
        /// <para>bytes). In this example, the length passed in would be 17.</para>
        /// <para>the actual number of bytes written and -1 on error.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int HidSendFeatureReport(global::SDL3Sharp.HidDevice dev, byte* data, ulong length)
        {
            var __arg0 = dev is null ? __IntPtr.Zero : dev.__Instance;
            var ___ret = __Internal.HidSendFeatureReport(__arg0, data, length);
            return ___ret;
        }

        /// <summary>Get a feature report from a HID device.</summary>
        /// <param name="dev">A device handle returned from SDL_hid_open().</param>
        /// <param name="data">
        /// <para>A buffer to put the read data into, including the Report ID.</para>
        /// <para>Set the first byte of `data` to the Report ID of the report to</para>
        /// <para>be read, or set it to zero if your device does not use numbered</para>
        /// <para>reports.</para>
        /// </param>
        /// <param name="length">
        /// <para>The number of bytes to read, including an extra byte for the</para>
        /// <para>report ID. The buffer can be longer than the actual report.</para>
        /// </param>
        /// <remarks>
        /// <para>Set the first byte of `data` to the Report ID of the report to be read.</para>
        /// <para>Make sure to allow space for this extra byte in `data`. Upon return, the</para>
        /// <para>first byte will still contain the Report ID, and the report data will start</para>
        /// <para>in data[1].</para>
        /// <para>the number of bytes read plus one for the report ID (which is</para>
        /// <para>still in the first byte), or -1 on error.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int HidGetFeatureReport(global::SDL3Sharp.HidDevice dev, byte* data, ulong length)
        {
            var __arg0 = dev is null ? __IntPtr.Zero : dev.__Instance;
            var ___ret = __Internal.HidGetFeatureReport(__arg0, data, length);
            return ___ret;
        }

        /// <summary>Get an input report from a HID device.</summary>
        /// <param name="dev">A device handle returned from SDL_hid_open().</param>
        /// <param name="data">
        /// <para>A buffer to put the read data into, including the Report ID.</para>
        /// <para>Set the first byte of `data` to the Report ID of the report to</para>
        /// <para>be read, or set it to zero if your device does not use numbered</para>
        /// <para>reports.</para>
        /// </param>
        /// <param name="length">
        /// <para>The number of bytes to read, including an extra byte for the</para>
        /// <para>report ID. The buffer can be longer than the actual report.</para>
        /// </param>
        /// <remarks>
        /// <para>Set the first byte of `data` to the Report ID of the report to be read.</para>
        /// <para>Make sure to allow space for this extra byte in `data`. Upon return, the</para>
        /// <para>first byte will still contain the Report ID, and the report data will start</para>
        /// <para>in data[1].</para>
        /// <para>the number of bytes read plus one for the report ID (which is</para>
        /// <para>still in the first byte), or -1 on error.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int HidGetInputReport(global::SDL3Sharp.HidDevice dev, byte* data, ulong length)
        {
            var __arg0 = dev is null ? __IntPtr.Zero : dev.__Instance;
            var ___ret = __Internal.HidGetInputReport(__arg0, data, length);
            return ___ret;
        }

        /// <summary>Close a HID device.</summary>
        /// <param name="dev">A device handle returned from SDL_hid_open().</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int HidClose(global::SDL3Sharp.HidDevice dev)
        {
            var __arg0 = dev is null ? __IntPtr.Zero : dev.__Instance;
            var ___ret = __Internal.HidClose(__arg0);
            return ___ret;
        }

        /// <summary>Get The Manufacturer String from a HID device.</summary>
        /// <param name="dev">A device handle returned from SDL_hid_open().</param>
        /// <param name="string">A wide string buffer to put the data into.</param>
        /// <param name="maxlen">The length of the buffer in multiples of wchar_t.</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int HidGetManufacturerString(global::SDL3Sharp.HidDevice dev, char* @string, ulong maxlen)
        {
            var __arg0 = dev is null ? __IntPtr.Zero : dev.__Instance;
            var ___ret = __Internal.HidGetManufacturerString(__arg0, @string, maxlen);
            return ___ret;
        }

        /// <summary>Get The Product String from a HID device.</summary>
        /// <param name="dev">A device handle returned from SDL_hid_open().</param>
        /// <param name="string">A wide string buffer to put the data into.</param>
        /// <param name="maxlen">The length of the buffer in multiples of wchar_t.</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int HidGetProductString(global::SDL3Sharp.HidDevice dev, char* @string, ulong maxlen)
        {
            var __arg0 = dev is null ? __IntPtr.Zero : dev.__Instance;
            var ___ret = __Internal.HidGetProductString(__arg0, @string, maxlen);
            return ___ret;
        }

        /// <summary>Get The Serial Number String from a HID device.</summary>
        /// <param name="dev">A device handle returned from SDL_hid_open().</param>
        /// <param name="string">A wide string buffer to put the data into.</param>
        /// <param name="maxlen">The length of the buffer in multiples of wchar_t.</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int HidGetSerialNumberString(global::SDL3Sharp.HidDevice dev, char* @string, ulong maxlen)
        {
            var __arg0 = dev is null ? __IntPtr.Zero : dev.__Instance;
            var ___ret = __Internal.HidGetSerialNumberString(__arg0, @string, maxlen);
            return ___ret;
        }

        /// <summary>Get a string from a HID device, based on its string index.</summary>
        /// <param name="dev">A device handle returned from SDL_hid_open().</param>
        /// <param name="string_index">The index of the string to get.</param>
        /// <param name="string">A wide string buffer to put the data into.</param>
        /// <param name="maxlen">The length of the buffer in multiples of wchar_t.</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int HidGetIndexedString(global::SDL3Sharp.HidDevice dev, int string_index, char* @string, ulong maxlen)
        {
            var __arg0 = dev is null ? __IntPtr.Zero : dev.__Instance;
            var ___ret = __Internal.HidGetIndexedString(__arg0, string_index, @string, maxlen);
            return ___ret;
        }

        /// <summary>Get the device info from a HID device.</summary>
        /// <param name="dev">A device handle returned from SDL_hid_open().</param>
        /// <remarks>
        /// <para>a pointer to the SDL_hid_device_info for this hid_device, or NULL</para>
        /// <para>in the case of failure; call SDL_GetError() for more information.</para>
        /// <para>This struct is valid until the device is closed with</para>
        /// <para>SDL_hid_close().</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static global::SDL3Sharp.HidDeviceInfo HidGetDeviceInfo(global::SDL3Sharp.HidDevice dev)
        {
            var __arg0 = dev is null ? __IntPtr.Zero : dev.__Instance;
            var ___ret = __Internal.HidGetDeviceInfo(__arg0);
            var __result0 = global::SDL3Sharp.HidDeviceInfo.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get a report descriptor from a HID device.</summary>
        /// <param name="dev">A device handle returned from SDL_hid_open().</param>
        /// <param name="buf">The buffer to copy descriptor into.</param>
        /// <param name="buf_size">The size of the buffer in bytes.</param>
        /// <remarks>
        /// <para>User has to provide a preallocated buffer where descriptor will be copied</para>
        /// <para>to. The recommended size for a preallocated buffer is 4096 bytes.</para>
        /// <para>the number of bytes actually copied, or -1 on error; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int HidGetReportDescriptor(global::SDL3Sharp.HidDevice dev, byte* buf, ulong buf_size)
        {
            var __arg0 = dev is null ? __IntPtr.Zero : dev.__Instance;
            var ___ret = __Internal.HidGetReportDescriptor(__arg0, buf, buf_size);
            return ___ret;
        }

        /// <summary>Start or stop a BLE scan on iOS and tvOS to pair Steam Controllers</summary>
        /// <param name="active">SDL_TRUE to start the scan, SDL_FALSE to stop the scan</param>
        /// <remarks>This function is available since SDL 3.0.0.</remarks>
        public static void HidBleScan(bool active)
        {
            __Internal.HidBleScan(active);
        }
    }
}
