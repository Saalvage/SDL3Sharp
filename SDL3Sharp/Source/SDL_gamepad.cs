// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required
#pragma warning disable CS9084 // Struct member returns 'this' or other instance members by reference

namespace SDL3Sharp
{
    public enum GamepadType
    {
        Unknown = 0,
        Standard = 1,
        Xbox360 = 2,
        Xboxone = 3,
        Ps3 = 4,
        Ps4 = 5,
        Ps5 = 6,
        NintendoSwitchPro = 7,
        NintendoSwitchJoyconLeft = 8,
        NintendoSwitchJoyconRight = 9,
        NintendoSwitchJoyconPair = 10,
        Max = 11
    }

    /// <summary>The list of buttons available on a gamepad</summary>
    /// <remarks>
    /// <para>For controllers that use a diamond pattern for the face buttons,</para>
    /// <para>the south/east/west/north buttons below correspond to the locations</para>
    /// <para>in the diamond pattern. For Xbox controllers, this would be A/B/X/Y,</para>
    /// <para>for Nintendo Switch controllers, this would be B/A/Y/X, for</para>
    /// <para>PlayStation controllers this would be Cross/Circle/Square/Triangle.</para>
    /// <para>For controllers that don't use a diamond pattern for the face buttons,</para>
    /// <para>the south/east/west/north buttons indicate the buttons labeled A, B,</para>
    /// <para>C, D, or 1, 2, 3, 4, or for controllers that aren't labeled, they are</para>
    /// <para>the primary, secondary, etc. buttons.</para>
    /// <para>The activate action is often the south button and the cancel action</para>
    /// <para>is often the east button, but in some regions this is reversed, so</para>
    /// <para>your game should allow remapping actions based on user preferences.</para>
    /// <para>You can query the labels for the face buttons using SDL_GetGamepadButtonLabel()</para>
    /// </remarks>
    public enum GamepadButton
    {
        Invalid = -1,
        South = 0,
        East = 1,
        West = 2,
        North = 3,
        Back = 4,
        Guide = 5,
        Start = 6,
        LeftStick = 7,
        RightStick = 8,
        LeftShoulder = 9,
        RightShoulder = 10,
        DpadUp = 11,
        DpadDown = 12,
        DpadLeft = 13,
        DpadRight = 14,
        Misc1 = 15,
        RightPaddle1 = 16,
        LeftPaddle1 = 17,
        RightPaddle2 = 18,
        LeftPaddle2 = 19,
        Touchpad = 20,
        Misc2 = 21,
        Misc3 = 22,
        Misc4 = 23,
        Misc5 = 24,
        Misc6 = 25,
        Max = 26
    }

    /// <summary>The set of gamepad button labels</summary>
    /// <remarks>
    /// <para>This isn't a complete set, just the face buttons to make it easy to show button prompts.</para>
    /// <para>For a complete set, you should look at the button and gamepad type and have a set of symbols that work well with your art style.</para>
    /// </remarks>
    public enum GamepadButtonLabel
    {
        Unknown = 0,
        A = 1,
        B = 2,
        X = 3,
        Y = 4,
        Cross = 5,
        Circle = 6,
        Square = 7,
        Triangle = 8
    }

    /// <summary>The list of axes available on a gamepad</summary>
    /// <remarks>
    /// <para>Thumbstick axis values range from SDL_JOYSTICK_AXIS_MIN to SDL_JOYSTICK_AXIS_MAX,</para>
    /// <para>and are centered within ~8000 of zero, though advanced UI will allow users to set</para>
    /// <para>or autodetect the dead zone, which varies between gamepads.</para>
    /// <para>Trigger axis values range from 0 (released) to SDL_JOYSTICK_AXIS_MAX</para>
    /// <para>(fully pressed) when reported by SDL_GetGamepadAxis(). Note that this is not the</para>
    /// <para>same range that will be reported by the lower-level SDL_GetJoystickAxis().</para>
    /// </remarks>
    public enum GamepadAxis
    {
        Invalid = -1,
        Leftx = 0,
        Lefty = 1,
        Rightx = 2,
        Righty = 3,
        LeftTrigger = 4,
        RightTrigger = 5,
        Max = 6
    }

    public enum GamepadBindingType
    {
        None = 0,
        Button = 1,
        Axis = 2,
        Hat = 3
    }

    /// <summary>The list of buttons available on a gamepad</summary>
    /// <remarks>
    /// <para>For controllers that use a diamond pattern for the face buttons,</para>
    /// <para>the south/east/west/north buttons below correspond to the locations</para>
    /// <para>in the diamond pattern. For Xbox controllers, this would be A/B/X/Y,</para>
    /// <para>for Nintendo Switch controllers, this would be B/A/Y/X, for</para>
    /// <para>PlayStation controllers this would be Cross/Circle/Square/Triangle.</para>
    /// <para>For controllers that don't use a diamond pattern for the face buttons,</para>
    /// <para>the south/east/west/north buttons indicate the buttons labeled A, B,</para>
    /// <para>C, D, or 1, 2, 3, 4, or for controllers that aren't labeled, they are</para>
    /// <para>the primary, secondary, etc. buttons.</para>
    /// <para>The activate action is often the south button and the cancel action</para>
    /// <para>is often the east button, but in some regions this is reversed, so</para>
    /// <para>your game should allow remapping actions based on user preferences.</para>
    /// <para>You can query the labels for the face buttons using SDL_GetGamepadButtonLabel()</para>
    /// </remarks>
    /// <summary>The set of gamepad button labels</summary>
    /// <remarks>
    /// <para>This isn't a complete set, just the face buttons to make it easy to show button prompts.</para>
    /// <para>For a complete set, you should look at the button and gamepad type and have a set of symbols that work well with your art style.</para>
    /// </remarks>
    /// <summary>The list of axes available on a gamepad</summary>
    /// <remarks>
    /// <para>Thumbstick axis values range from SDL_JOYSTICK_AXIS_MIN to SDL_JOYSTICK_AXIS_MAX,</para>
    /// <para>and are centered within ~8000 of zero, though advanced UI will allow users to set</para>
    /// <para>or autodetect the dead zone, which varies between gamepads.</para>
    /// <para>Trigger axis values range from 0 (released) to SDL_JOYSTICK_AXIS_MAX</para>
    /// <para>(fully pressed) when reported by SDL_GetGamepadAxis(). Note that this is not the</para>
    /// <para>same range that will be reported by the lower-level SDL_GetJoystickAxis().</para>
    /// </remarks>
    /// <summary>The structure used to identify an SDL gamepad</summary>
    public unsafe partial class Gamepad
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.Gamepad> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.Gamepad>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.Gamepad managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.Gamepad managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Gamepad __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Gamepad(native.ToPointer(), skipVTables);
        }

        internal static Gamepad __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Gamepad)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Gamepad __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Gamepad(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Gamepad(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Gamepad(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class GamepadBinding : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32, Pack = 8)]
        public partial struct __Internal
        {
            internal global::SDL3Sharp.GamepadBindingType input_type;
            internal global::SDL3Sharp.GamepadBinding.Input.__Internal input;
            internal global::SDL3Sharp.GamepadBindingType output_type;
            internal global::SDL3Sharp.GamepadBinding.Output.__Internal output;

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0SDL_GamepadBinding@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public unsafe partial struct Input
        {
            [StructLayout(LayoutKind.Explicit, Size = 12, Pack = 8)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal int button;

                [FieldOffset(0)]
                internal global::SDL3Sharp.GamepadBinding.Input.Axis.__Internal axis;

                [FieldOffset(0)]
                internal global::SDL3Sharp.GamepadBinding.Input.Hat.__Internal hat;

                [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0<unnamed-type-input>@SDL_GamepadBinding@@QEAA@AEBT01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            public unsafe partial class Axis : IDisposable
            {
                [StructLayout(LayoutKind.Sequential, Size = 12, Pack = 8)]
                public partial struct __Internal
                {
                    internal int axis;
                    internal int axis_min;
                    internal int axis_max;

                    [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0<unnamed-type-axis>@<unnamed-type-input>@SDL_GamepadBinding@@QEAA@AEBU012@@Z", CallingConvention = __CallingConvention.Cdecl)]
                    internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
                }

                public __IntPtr __Instance { get; protected set; }

                internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.GamepadBinding.Input.Axis> NativeToManagedMap =
                    new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.GamepadBinding.Input.Axis>();

                internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.GamepadBinding.Input.Axis managed)
                {
                    NativeToManagedMap[native] = managed;
                }

                internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.GamepadBinding.Input.Axis managed)
                {
    
                    return NativeToManagedMap.TryGetValue(native, out managed);
                }

                protected bool __ownsNativeInstance;

                internal static Axis __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    return new Axis(native.ToPointer(), skipVTables);
                }

                internal static Axis __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (__TryGetNativeToManagedMapping(native, out var managed))
                        return (Axis)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        __RecordNativeToManagedMapping(native, result);
                    return result;
                }

                internal static Axis __CreateInstance(__Internal native, bool skipVTables = false)
                {
                    return new Axis(native, skipVTables);
                }

                private static void* __CopyValue(__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                    *(__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private Axis(__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                protected Axis(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new __IntPtr(native);
                }

                public Axis()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.GamepadBinding.Input.Axis.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                public Axis(global::SDL3Sharp.GamepadBinding.Input.Axis _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.GamepadBinding.Input.Axis.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    *((global::SDL3Sharp.GamepadBinding.Input.Axis.__Internal*) __Instance) = *((global::SDL3Sharp.GamepadBinding.Input.Axis.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
                }

                partial void DisposePartial(bool disposing);

                internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    NativeToManagedMap.TryRemove(__Instance, out _);
                    DisposePartial(disposing);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public int axis
                {
                    get
                    {
                        return ((__Internal*)__Instance)->axis;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->axis = value;
                    }
                }

                public int AxisMin
                {
                    get
                    {
                        return ((__Internal*)__Instance)->axis_min;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->axis_min = value;
                    }
                }

                public int AxisMax
                {
                    get
                    {
                        return ((__Internal*)__Instance)->axis_max;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->axis_max = value;
                    }
                }
            }

            public unsafe partial class Hat : IDisposable
            {
                [StructLayout(LayoutKind.Sequential, Size = 8, Pack = 8)]
                public partial struct __Internal
                {
                    internal int hat;
                    internal int hat_mask;

                    [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0<unnamed-type-hat>@<unnamed-type-input>@SDL_GamepadBinding@@QEAA@AEBU012@@Z", CallingConvention = __CallingConvention.Cdecl)]
                    internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
                }

                public __IntPtr __Instance { get; protected set; }

                internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.GamepadBinding.Input.Hat> NativeToManagedMap =
                    new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.GamepadBinding.Input.Hat>();

                internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.GamepadBinding.Input.Hat managed)
                {
                    NativeToManagedMap[native] = managed;
                }

                internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.GamepadBinding.Input.Hat managed)
                {
    
                    return NativeToManagedMap.TryGetValue(native, out managed);
                }

                protected bool __ownsNativeInstance;

                internal static Hat __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    return new Hat(native.ToPointer(), skipVTables);
                }

                internal static Hat __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (__TryGetNativeToManagedMapping(native, out var managed))
                        return (Hat)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        __RecordNativeToManagedMapping(native, result);
                    return result;
                }

                internal static Hat __CreateInstance(__Internal native, bool skipVTables = false)
                {
                    return new Hat(native, skipVTables);
                }

                private static void* __CopyValue(__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                    *(__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private Hat(__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                protected Hat(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new __IntPtr(native);
                }

                public Hat()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.GamepadBinding.Input.Hat.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                public Hat(global::SDL3Sharp.GamepadBinding.Input.Hat _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.GamepadBinding.Input.Hat.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    *((global::SDL3Sharp.GamepadBinding.Input.Hat.__Internal*) __Instance) = *((global::SDL3Sharp.GamepadBinding.Input.Hat.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
                }

                partial void DisposePartial(bool disposing);

                internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    NativeToManagedMap.TryRemove(__Instance, out _);
                    DisposePartial(disposing);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public int hat
                {
                    get
                    {
                        return ((__Internal*)__Instance)->hat;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->hat = value;
                    }
                }

                public int HatMask
                {
                    get
                    {
                        return ((__Internal*)__Instance)->hat_mask;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->hat_mask = value;
                    }
                }
            }

            private Input.__Internal __instance;
            internal ref Input.__Internal __Instance => ref __instance;

            internal static Input __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new Input(native.ToPointer(), skipVTables);
            }

            internal static Input __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Input(native, skipVTables);
            }

            private Input(__Internal native, bool skipVTables = false)
                : this()
            {
                __instance = native;
            }

            private Input(void* native, bool skipVTables = false) : this()
            {
                __instance = *(global::SDL3Sharp.GamepadBinding.Input.__Internal*) native;
            }

            public Input(global::SDL3Sharp.GamepadBinding.Input _0)
                : this()
            {
                var ____arg0 = _0.__Instance;
                var __arg0 = new __IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
                }
            }

            public int Button
            {
                get
                {
                    return __instance.button;
                }

                set
                {
                    __instance.button = value;
                }
            }

            public global::SDL3Sharp.GamepadBinding.Input.Axis axis
            {
                get
                {
                    return global::SDL3Sharp.GamepadBinding.Input.Axis.__CreateInstance(__instance.axis);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.axis = *(global::SDL3Sharp.GamepadBinding.Input.Axis.__Internal*) value.__Instance;
                }
            }

            public global::SDL3Sharp.GamepadBinding.Input.Hat hat
            {
                get
                {
                    return global::SDL3Sharp.GamepadBinding.Input.Hat.__CreateInstance(__instance.hat);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.hat = *(global::SDL3Sharp.GamepadBinding.Input.Hat.__Internal*) value.__Instance;
                }
            }
        }

        public unsafe partial struct Output
        {
            [StructLayout(LayoutKind.Explicit, Size = 12, Pack = 8)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::SDL3Sharp.GamepadButton button;

                [FieldOffset(0)]
                internal global::SDL3Sharp.GamepadBinding.Output.Axis.__Internal axis;

                [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0<unnamed-type-output>@SDL_GamepadBinding@@QEAA@AEBT01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            public unsafe partial class Axis : IDisposable
            {
                [StructLayout(LayoutKind.Sequential, Size = 12, Pack = 8)]
                public partial struct __Internal
                {
                    internal global::SDL3Sharp.GamepadAxis axis;
                    internal int axis_min;
                    internal int axis_max;

                    [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "??0<unnamed-type-axis>@<unnamed-type-output>@SDL_GamepadBinding@@QEAA@AEBU012@@Z", CallingConvention = __CallingConvention.Cdecl)]
                    internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
                }

                public __IntPtr __Instance { get; protected set; }

                internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.GamepadBinding.Output.Axis> NativeToManagedMap =
                    new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.GamepadBinding.Output.Axis>();

                internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.GamepadBinding.Output.Axis managed)
                {
                    NativeToManagedMap[native] = managed;
                }

                internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.GamepadBinding.Output.Axis managed)
                {
    
                    return NativeToManagedMap.TryGetValue(native, out managed);
                }

                protected bool __ownsNativeInstance;

                internal static Axis __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    return new Axis(native.ToPointer(), skipVTables);
                }

                internal static Axis __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (__TryGetNativeToManagedMapping(native, out var managed))
                        return (Axis)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        __RecordNativeToManagedMapping(native, result);
                    return result;
                }

                internal static Axis __CreateInstance(__Internal native, bool skipVTables = false)
                {
                    return new Axis(native, skipVTables);
                }

                private static void* __CopyValue(__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                    *(__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private Axis(__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                protected Axis(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new __IntPtr(native);
                }

                public Axis()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.GamepadBinding.Output.Axis.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                public Axis(global::SDL3Sharp.GamepadBinding.Output.Axis _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.GamepadBinding.Output.Axis.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    *((global::SDL3Sharp.GamepadBinding.Output.Axis.__Internal*) __Instance) = *((global::SDL3Sharp.GamepadBinding.Output.Axis.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
                }

                partial void DisposePartial(bool disposing);

                internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    NativeToManagedMap.TryRemove(__Instance, out _);
                    DisposePartial(disposing);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::SDL3Sharp.GamepadAxis axis
                {
                    get
                    {
                        return ((__Internal*)__Instance)->axis;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->axis = value;
                    }
                }

                public int AxisMin
                {
                    get
                    {
                        return ((__Internal*)__Instance)->axis_min;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->axis_min = value;
                    }
                }

                public int AxisMax
                {
                    get
                    {
                        return ((__Internal*)__Instance)->axis_max;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->axis_max = value;
                    }
                }
            }

            private Output.__Internal __instance;
            internal ref Output.__Internal __Instance => ref __instance;

            internal static Output __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new Output(native.ToPointer(), skipVTables);
            }

            internal static Output __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Output(native, skipVTables);
            }

            private Output(__Internal native, bool skipVTables = false)
                : this()
            {
                __instance = native;
            }

            private Output(void* native, bool skipVTables = false) : this()
            {
                __instance = *(global::SDL3Sharp.GamepadBinding.Output.__Internal*) native;
            }

            public Output(global::SDL3Sharp.GamepadBinding.Output _0)
                : this()
            {
                var ____arg0 = _0.__Instance;
                var __arg0 = new __IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
                }
            }

            public global::SDL3Sharp.GamepadButton Button
            {
                get
                {
                    return __instance.button;
                }

                set
                {
                    __instance.button = value;
                }
            }

            public global::SDL3Sharp.GamepadBinding.Output.Axis axis
            {
                get
                {
                    return global::SDL3Sharp.GamepadBinding.Output.Axis.__CreateInstance(__instance.axis);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.axis = *(global::SDL3Sharp.GamepadBinding.Output.Axis.__Internal*) value.__Instance;
                }
            }
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.GamepadBinding> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::SDL3Sharp.GamepadBinding>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::SDL3Sharp.GamepadBinding managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::SDL3Sharp.GamepadBinding managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static GamepadBinding __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new GamepadBinding(native.ToPointer(), skipVTables);
        }

        internal static GamepadBinding __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (GamepadBinding)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static GamepadBinding __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new GamepadBinding(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private GamepadBinding(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected GamepadBinding(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public GamepadBinding()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.GamepadBinding.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public GamepadBinding(global::SDL3Sharp.GamepadBinding _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::SDL3Sharp.GamepadBinding.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::SDL3Sharp.GamepadBinding.__Internal*) __Instance) = *((global::SDL3Sharp.GamepadBinding.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: __ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::SDL3Sharp.GamepadBindingType InputType
        {
            get
            {
                return ((__Internal*)__Instance)->input_type;
            }

            set
            {
                ((__Internal*)__Instance)->input_type = value;
            }
        }

        public global::SDL3Sharp.GamepadBinding.Input input
        {
            get
            {
                return global::SDL3Sharp.GamepadBinding.Input.__CreateInstance(((__Internal*)__Instance)->input);
            }

            set
            {
                ((__Internal*)__Instance)->input = value.__Instance;
            }
        }

        public global::SDL3Sharp.GamepadBindingType OutputType
        {
            get
            {
                return ((__Internal*)__Instance)->output_type;
            }

            set
            {
                ((__Internal*)__Instance)->output_type = value;
            }
        }

        public global::SDL3Sharp.GamepadBinding.Output output
        {
            get
            {
                return global::SDL3Sharp.GamepadBinding.Output.__CreateInstance(((__Internal*)__Instance)->output);
            }

            set
            {
                ((__Internal*)__Instance)->output = value.__Instance;
            }
        }
    }

    public unsafe partial class SDL
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_AddGamepadMapping", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int AddGamepadMapping([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string mapping);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_AddGamepadMappingsFromRW", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int AddGamepadMappingsFromRW(__IntPtr src, bool freesrc);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_AddGamepadMappingsFromFile", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int AddGamepadMappingsFromFile([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string file);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_ReloadGamepadMappings", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int ReloadGamepadMappings();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetGamepadMappings", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern sbyte** GetGamepadMappings(int* count);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetGamepadMappingForGUID", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern sbyte* GetGamepadMappingForGUID(__IntPtr guid);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetGamepadMapping", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern sbyte* GetGamepadMapping(__IntPtr gamepad);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetGamepadMapping", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetGamepadMapping(uint instance_id, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string mapping);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetGamepads", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint* GetGamepads(int* count);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_IsGamepad", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool IsGamepad(uint instance_id);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetGamepadInstanceName", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetGamepadInstanceName(uint instance_id);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetGamepadInstancePath", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetGamepadInstancePath(uint instance_id);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetGamepadInstancePlayerIndex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetGamepadInstancePlayerIndex(uint instance_id);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetGamepadInstanceGUID", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GetGamepadInstanceGUID(__IntPtr @return, uint instance_id);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetGamepadInstanceVendor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ushort GetGamepadInstanceVendor(uint instance_id);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetGamepadInstanceProduct", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ushort GetGamepadInstanceProduct(uint instance_id);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetGamepadInstanceProductVersion", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ushort GetGamepadInstanceProductVersion(uint instance_id);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetGamepadInstanceType", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::SDL3Sharp.GamepadType GetGamepadInstanceType(uint instance_id);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetRealGamepadInstanceType", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::SDL3Sharp.GamepadType GetRealGamepadInstanceType(uint instance_id);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetGamepadInstanceMapping", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern sbyte* GetGamepadInstanceMapping(uint instance_id);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_OpenGamepad", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr OpenGamepad(uint instance_id);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetGamepadFromInstanceID", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetGamepadFromInstanceID(uint instance_id);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetGamepadFromPlayerIndex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetGamepadFromPlayerIndex(int player_index);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetGamepadProperties", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint GetGamepadProperties(__IntPtr gamepad);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetGamepadInstanceID", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint GetGamepadInstanceID(__IntPtr gamepad);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetGamepadName", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetGamepadName(__IntPtr gamepad);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetGamepadPath", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetGamepadPath(__IntPtr gamepad);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetGamepadType", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::SDL3Sharp.GamepadType GetGamepadType(__IntPtr gamepad);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetRealGamepadType", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::SDL3Sharp.GamepadType GetRealGamepadType(__IntPtr gamepad);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetGamepadPlayerIndex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetGamepadPlayerIndex(__IntPtr gamepad);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetGamepadPlayerIndex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetGamepadPlayerIndex(__IntPtr gamepad, int player_index);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetGamepadVendor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ushort GetGamepadVendor(__IntPtr gamepad);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetGamepadProduct", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ushort GetGamepadProduct(__IntPtr gamepad);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetGamepadProductVersion", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ushort GetGamepadProductVersion(__IntPtr gamepad);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetGamepadFirmwareVersion", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ushort GetGamepadFirmwareVersion(__IntPtr gamepad);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetGamepadSerial", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetGamepadSerial(__IntPtr gamepad);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetGamepadSteamHandle", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong GetGamepadSteamHandle(__IntPtr gamepad);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetGamepadPowerLevel", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::SDL3Sharp.JoystickPowerLevel GetGamepadPowerLevel(__IntPtr gamepad);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GamepadConnected", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool GamepadConnected(__IntPtr gamepad);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetGamepadJoystick", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetGamepadJoystick(__IntPtr gamepad);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetGamepadEventsEnabled", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetGamepadEventsEnabled(bool enabled);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GamepadEventsEnabled", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool GamepadEventsEnabled();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetGamepadBindings", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetGamepadBindings(__IntPtr gamepad, int* count);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_UpdateGamepads", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UpdateGamepads();

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetGamepadTypeFromString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::SDL3Sharp.GamepadType GetGamepadTypeFromString([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetGamepadStringForType", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetGamepadStringForType(global::SDL3Sharp.GamepadType type);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetGamepadAxisFromString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::SDL3Sharp.GamepadAxis GetGamepadAxisFromString([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetGamepadStringForAxis", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetGamepadStringForAxis(global::SDL3Sharp.GamepadAxis axis);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GamepadHasAxis", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool GamepadHasAxis(__IntPtr gamepad, global::SDL3Sharp.GamepadAxis axis);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetGamepadAxis", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern short GetGamepadAxis(__IntPtr gamepad, global::SDL3Sharp.GamepadAxis axis);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetGamepadButtonFromString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::SDL3Sharp.GamepadButton GetGamepadButtonFromString([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetGamepadStringForButton", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetGamepadStringForButton(global::SDL3Sharp.GamepadButton button);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GamepadHasButton", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool GamepadHasButton(__IntPtr gamepad, global::SDL3Sharp.GamepadButton button);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetGamepadButton", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte GetGamepadButton(__IntPtr gamepad, global::SDL3Sharp.GamepadButton button);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetGamepadButtonLabelForType", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::SDL3Sharp.GamepadButtonLabel GetGamepadButtonLabelForType(global::SDL3Sharp.GamepadType type, global::SDL3Sharp.GamepadButton button);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetGamepadButtonLabel", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::SDL3Sharp.GamepadButtonLabel GetGamepadButtonLabel(__IntPtr gamepad, global::SDL3Sharp.GamepadButton button);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetNumGamepadTouchpads", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetNumGamepadTouchpads(__IntPtr gamepad);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetNumGamepadTouchpadFingers", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetNumGamepadTouchpadFingers(__IntPtr gamepad, int touchpad);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetGamepadTouchpadFinger", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetGamepadTouchpadFinger(__IntPtr gamepad, int touchpad, int finger, byte* state, float* x, float* y, float* pressure);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GamepadHasSensor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool GamepadHasSensor(__IntPtr gamepad, global::SDL3Sharp.SensorType type);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetGamepadSensorEnabled", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetGamepadSensorEnabled(__IntPtr gamepad, global::SDL3Sharp.SensorType type, bool enabled);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GamepadSensorEnabled", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool GamepadSensorEnabled(__IntPtr gamepad, global::SDL3Sharp.SensorType type);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetGamepadSensorDataRate", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float GetGamepadSensorDataRate(__IntPtr gamepad, global::SDL3Sharp.SensorType type);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetGamepadSensorData", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetGamepadSensorData(__IntPtr gamepad, global::SDL3Sharp.SensorType type, float* data, int num_values);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_RumbleGamepad", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int RumbleGamepad(__IntPtr gamepad, ushort low_frequency_rumble, ushort high_frequency_rumble, uint duration_ms);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_RumbleGamepadTriggers", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int RumbleGamepadTriggers(__IntPtr gamepad, ushort left_rumble, ushort right_rumble, uint duration_ms);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SetGamepadLED", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SetGamepadLED(__IntPtr gamepad, byte red, byte green, byte blue);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_SendGamepadEffect", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int SendGamepadEffect(__IntPtr gamepad, __IntPtr data, int size);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_CloseGamepad", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void CloseGamepad(__IntPtr gamepad);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetGamepadAppleSFSymbolsNameForButton", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetGamepadAppleSFSymbolsNameForButton(__IntPtr gamepad, global::SDL3Sharp.GamepadButton button);

            [SuppressUnmanagedCodeSecurity, DllImport("SDL3", EntryPoint = "SDL_GetGamepadAppleSFSymbolsNameForAxis", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetGamepadAppleSFSymbolsNameForAxis(__IntPtr gamepad, global::SDL3Sharp.GamepadAxis axis);
        }

        /// <summary>
        /// <para>Add support for gamepads that SDL is unaware of or change the binding of an</para>
        /// <para>existing gamepad.</para>
        /// </summary>
        /// <param name="mapping">the mapping string</param>
        /// <remarks>
        /// <para>The mapping string has the format &quot;GUID,name,mapping&quot;, where GUID is the</para>
        /// <para>string value from SDL_GetJoystickGUIDString(), name is the human readable</para>
        /// <para>string for the device and mappings are gamepad mappings to joystick ones.</para>
        /// <para>Under Windows there is a reserved GUID of &quot;xinput&quot; that covers all XInput</para>
        /// <para>devices. The mapping format for joystick is:</para>
        /// <para>- `bX`: a joystick button, index X</para>
        /// <para>- `hX.Y`: hat X with value Y</para>
        /// <para>- `aX`: axis X of the joystick</para>
        /// <para>Buttons can be used as a gamepad axes and vice versa.</para>
        /// <para>This string shows an example of a valid mapping for a gamepad:</para>
        /// <para>```c</para>
        /// <para>&quot;341a3608000000000000504944564944,Afterglow PS3 Controller,a:b1,b:b2,y:b3,x:b0,start:b9,guide:b12,back:b8,dpup:h0.1,dpleft:h0.8,dpdown:h0.4,dpright:h0.2,leftshoulder:b4,rightshoulder:b5,leftstick:b10,rightstick:b11,leftx:a0,lefty:a1,rightx:a2,righty:a3,lefttrigger:b6,righttrigger:b7&quot;</para>
        /// <para>```</para>
        /// <para>1 if a new mapping is added, 0 if an existing mapping is updated,</para>
        /// <para>-1 on error; call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetGamepadMapping</para>
        /// <para>SDL_GetGamepadMappingForGUID</para>
        /// </remarks>
        public static int AddGamepadMapping(string mapping)
        {
            var ___ret = __Internal.AddGamepadMapping(mapping);
            return ___ret;
        }

        /// <summary>Load a set of gamepad mappings from a seekable SDL data stream.</summary>
        /// <param name="src">the data stream for the mappings to be added</param>
        /// <param name="freesrc">
        /// <para>if SDL_TRUE, calls SDL_RWclose() on `src` before returning,</para>
        /// <para>even in the case of an error</para>
        /// </param>
        /// <remarks>
        /// <para>You can call this function several times, if needed, to load different</para>
        /// <para>database files.</para>
        /// <para>If a new mapping is loaded for an already known gamepad GUID, the later</para>
        /// <para>version will overwrite the one currently loaded.</para>
        /// <para>Mappings not belonging to the current platform or with no platform field</para>
        /// <para>specified will be ignored (i.e. mappings for Linux will be ignored in</para>
        /// <para>Windows, etc).</para>
        /// <para>This function will load the text database entirely in memory before</para>
        /// <para>processing it, so take this into consideration if you are in a memory</para>
        /// <para>constrained environment.</para>
        /// <para>the number of mappings added or -1 on error; call SDL_GetError()</para>
        /// <para>for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_AddGamepadMapping</para>
        /// <para>SDL_AddGamepadMappingsFromFile</para>
        /// <para>SDL_GetGamepadMappingForGUID</para>
        /// </remarks>
        public static int AddGamepadMappingsFromRW(global::SDL3Sharp.RWops src, bool freesrc)
        {
            var __arg0 = src is null ? __IntPtr.Zero : src.__Instance;
            var ___ret = __Internal.AddGamepadMappingsFromRW(__arg0, freesrc);
            return ___ret;
        }

        /// <summary>Load a set of gamepad mappings from a file.</summary>
        /// <param name="file">the mappings file to load</param>
        /// <remarks>
        /// <para>You can call this function several times, if needed, to load different</para>
        /// <para>database files.</para>
        /// <para>If a new mapping is loaded for an already known gamepad GUID, the later</para>
        /// <para>version will overwrite the one currently loaded.</para>
        /// <para>Mappings not belonging to the current platform or with no platform field</para>
        /// <para>specified will be ignored (i.e. mappings for Linux will be ignored in</para>
        /// <para>Windows, etc).</para>
        /// <para>the number of mappings added or -1 on error; call SDL_GetError()</para>
        /// <para>for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_AddGamepadMapping</para>
        /// <para>SDL_AddGamepadMappingsFromRW</para>
        /// <para>SDL_GetGamepadMappingForGUID</para>
        /// </remarks>
        public static int AddGamepadMappingsFromFile(string file)
        {
            var ___ret = __Internal.AddGamepadMappingsFromFile(file);
            return ___ret;
        }

        /// <summary>Reinitialize the SDL mapping database to its initial state.</summary>
        /// <remarks>
        /// <para>This will generate gamepad events as needed if device mappings change.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int ReloadGamepadMappings()
        {
            var ___ret = __Internal.ReloadGamepadMappings();
            return ___ret;
        }

        /// <summary>Get the current gamepad mappings.</summary>
        /// <param name="count">
        /// <para>a pointer filled in with the number of mappings returned, can</para>
        /// <para>be NULL.</para>
        /// </param>
        /// <remarks>
        /// <para>You must free the returned pointer with SDL_free() when you are done with</para>
        /// <para>it, but you do _not_ free each string in the array.</para>
        /// <para>an array of the mapping strings, NULL-terminated. Must be freed</para>
        /// <para>with SDL_free(). Returns NULL on error.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static sbyte** GetGamepadMappings(ref int count)
        {
            fixed (int* __count0 = &count)
            {
                var __arg0 = __count0;
                var ___ret = __Internal.GetGamepadMappings(__arg0);
                return ___ret;
            }
        }

        /// <summary>Get the gamepad mapping string for a given GUID.</summary>
        /// <param name="guid">a structure containing the GUID for which a mapping is desired</param>
        /// <remarks>
        /// <para>The returned string must be freed with SDL_free().</para>
        /// <para>a mapping string or NULL on error; call SDL_GetError() for more</para>
        /// <para>information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetJoystickInstanceGUID</para>
        /// <para>SDL_GetJoystickGUID</para>
        /// </remarks>
        public static sbyte* GetGamepadMappingForGUID(global::SDL3Sharp.GUID guid)
        {
            if (ReferenceEquals(guid, null))
                throw new global::System.ArgumentNullException("guid", "Cannot be null because it is passed by value.");
            var __arg0 = guid.__Instance;
            var ___ret = __Internal.GetGamepadMappingForGUID(__arg0);
            return ___ret;
        }

        /// <summary>Get the current mapping of a gamepad.</summary>
        /// <param name="gamepad">the gamepad you want to get the current mapping for</param>
        /// <remarks>
        /// <para>The returned string must be freed with SDL_free().</para>
        /// <para>Details about mappings are discussed with SDL_AddGamepadMapping().</para>
        /// <para>a string that has the gamepad's mapping or NULL if no mapping is</para>
        /// <para>available; call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_AddGamepadMapping</para>
        /// <para>SDL_GetGamepadMappingForGUID</para>
        /// <para>SDL_SetGamepadMapping</para>
        /// </remarks>
        public static sbyte* GetGamepadMapping(global::SDL3Sharp.Gamepad gamepad)
        {
            var __arg0 = gamepad is null ? __IntPtr.Zero : gamepad.__Instance;
            var ___ret = __Internal.GetGamepadMapping(__arg0);
            return ___ret;
        }

        /// <summary>Set the current mapping of a joystick or gamepad.</summary>
        /// <param name="instance_id">the joystick instance ID</param>
        /// <param name="mapping">
        /// <para>the mapping to use for this device, or NULL to clear the</para>
        /// <para>mapping</para>
        /// </param>
        /// <remarks>
        /// <para>Details about mappings are discussed with SDL_AddGamepadMapping().</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_AddGamepadMapping</para>
        /// <para>SDL_GetGamepadMapping</para>
        /// </remarks>
        public static int SetGamepadMapping(uint instance_id, string mapping)
        {
            var ___ret = __Internal.SetGamepadMapping(instance_id, mapping);
            return ___ret;
        }

        /// <summary>Get a list of currently connected gamepads.</summary>
        /// <param name="count">a pointer filled in with the number of gamepads returned</param>
        /// <remarks>
        /// <para>a 0 terminated array of joystick instance IDs which should be</para>
        /// <para>freed with SDL_free(), or NULL on error; call SDL_GetError() for</para>
        /// <para>more details.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_OpenGamepad</para>
        /// </remarks>
        public static uint* GetGamepads(ref int count)
        {
            fixed (int* __count0 = &count)
            {
                var __arg0 = __count0;
                var ___ret = __Internal.GetGamepads(__arg0);
                return ___ret;
            }
        }

        /// <summary>Check if the given joystick is supported by the gamepad interface.</summary>
        /// <param name="instance_id">the joystick instance ID</param>
        /// <remarks>
        /// <para>SDL_TRUE if the given joystick is supported by the gamepad</para>
        /// <para>interface, SDL_FALSE if it isn't or it's an invalid index.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_OpenGamepad</para>
        /// </remarks>
        public static bool IsGamepad(uint instance_id)
        {
            var ___ret = __Internal.IsGamepad(instance_id);
            return ___ret;
        }

        /// <summary>Get the implementation dependent name of a gamepad.</summary>
        /// <param name="instance_id">the joystick instance ID</param>
        /// <remarks>
        /// <para>This can be called before any gamepads are opened.</para>
        /// <para>the name of the selected gamepad. If no name can be found, this</para>
        /// <para>function returns NULL; call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetGamepadName</para>
        /// <para>SDL_OpenGamepad</para>
        /// </remarks>
        public static string GetGamepadInstanceName(uint instance_id)
        {
            var ___ret = __Internal.GetGamepadInstanceName(instance_id);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Get the implementation dependent path of a gamepad.</summary>
        /// <param name="instance_id">the joystick instance ID</param>
        /// <remarks>
        /// <para>This can be called before any gamepads are opened.</para>
        /// <para>the path of the selected gamepad. If no path can be found, this</para>
        /// <para>function returns NULL; call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetGamepadPath</para>
        /// <para>SDL_OpenGamepad</para>
        /// </remarks>
        public static string GetGamepadInstancePath(uint instance_id)
        {
            var ___ret = __Internal.GetGamepadInstancePath(instance_id);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Get the player index of a gamepad.</summary>
        /// <param name="instance_id">the joystick instance ID</param>
        /// <remarks>
        /// <para>This can be called before any gamepads are opened.</para>
        /// <para>the player index of a gamepad, or -1 if it's not available</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetGamepadPlayerIndex</para>
        /// <para>SDL_OpenGamepad</para>
        /// </remarks>
        public static int GetGamepadInstancePlayerIndex(uint instance_id)
        {
            var ___ret = __Internal.GetGamepadInstancePlayerIndex(instance_id);
            return ___ret;
        }

        /// <summary>Get the implementation-dependent GUID of a gamepad.</summary>
        /// <param name="instance_id">the joystick instance ID</param>
        /// <remarks>
        /// <para>This can be called before any gamepads are opened.</para>
        /// <para>the GUID of the selected gamepad. If called on an invalid index,</para>
        /// <para>this function returns a zero GUID</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetGamepadGUID</para>
        /// <para>SDL_GetGamepadGUIDString</para>
        /// </remarks>
        public static global::SDL3Sharp.GUID GetGamepadInstanceGUID(uint instance_id)
        {
            var ___ret = new global::SDL3Sharp.GUID.__Internal();
            __Internal.GetGamepadInstanceGUID(new IntPtr(&___ret), instance_id);
            return global::SDL3Sharp.GUID.__CreateInstance(___ret);
        }

        /// <summary>Get the USB vendor ID of a gamepad, if available.</summary>
        /// <param name="instance_id">the joystick instance ID</param>
        /// <remarks>
        /// <para>This can be called before any gamepads are opened. If the vendor ID isn't</para>
        /// <para>available this function returns 0.</para>
        /// <para>the USB vendor ID of the selected gamepad. If called on an invalid</para>
        /// <para>index, this function returns zero</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static ushort GetGamepadInstanceVendor(uint instance_id)
        {
            var ___ret = __Internal.GetGamepadInstanceVendor(instance_id);
            return ___ret;
        }

        /// <summary>Get the USB product ID of a gamepad, if available.</summary>
        /// <param name="instance_id">the joystick instance ID</param>
        /// <remarks>
        /// <para>This can be called before any gamepads are opened. If the product ID isn't</para>
        /// <para>available this function returns 0.</para>
        /// <para>the USB product ID of the selected gamepad. If called on an</para>
        /// <para>invalid index, this function returns zero</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static ushort GetGamepadInstanceProduct(uint instance_id)
        {
            var ___ret = __Internal.GetGamepadInstanceProduct(instance_id);
            return ___ret;
        }

        /// <summary>Get the product version of a gamepad, if available.</summary>
        /// <param name="instance_id">the joystick instance ID</param>
        /// <remarks>
        /// <para>This can be called before any gamepads are opened. If the product version</para>
        /// <para>isn't available this function returns 0.</para>
        /// <para>the product version of the selected gamepad. If called on an</para>
        /// <para>invalid index, this function returns zero</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static ushort GetGamepadInstanceProductVersion(uint instance_id)
        {
            var ___ret = __Internal.GetGamepadInstanceProductVersion(instance_id);
            return ___ret;
        }

        /// <summary>Get the type of a gamepad.</summary>
        /// <param name="instance_id">the joystick instance ID</param>
        /// <remarks>
        /// <para>This can be called before any gamepads are opened.</para>
        /// <para>the gamepad type.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static global::SDL3Sharp.GamepadType GetGamepadInstanceType(uint instance_id)
        {
            var ___ret = __Internal.GetGamepadInstanceType(instance_id);
            return ___ret;
        }

        /// <summary>Get the type of a gamepad, ignoring any mapping override.</summary>
        /// <param name="instance_id">the joystick instance ID</param>
        /// <remarks>
        /// <para>This can be called before any gamepads are opened.</para>
        /// <para>the gamepad type.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static global::SDL3Sharp.GamepadType GetRealGamepadInstanceType(uint instance_id)
        {
            var ___ret = __Internal.GetRealGamepadInstanceType(instance_id);
            return ___ret;
        }

        /// <summary>Get the mapping of a gamepad.</summary>
        /// <param name="instance_id">the joystick instance ID</param>
        /// <remarks>
        /// <para>This can be called before any gamepads are opened.</para>
        /// <para>the mapping string. Must be freed with SDL_free(). Returns NULL if</para>
        /// <para>no mapping is available.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static sbyte* GetGamepadInstanceMapping(uint instance_id)
        {
            var ___ret = __Internal.GetGamepadInstanceMapping(instance_id);
            return ___ret;
        }

        /// <summary>Open a gamepad for use.</summary>
        /// <param name="instance_id">the joystick instance ID</param>
        /// <remarks>
        /// <para>a gamepad identifier or NULL if an error occurred; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CloseGamepad</para>
        /// <para>SDL_IsGamepad</para>
        /// </remarks>
        public static global::SDL3Sharp.Gamepad OpenGamepad(uint instance_id)
        {
            var ___ret = __Internal.OpenGamepad(instance_id);
            var __result0 = global::SDL3Sharp.Gamepad.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Get the SDL_Gamepad associated with a joystick instance ID, if it has been</para>
        /// <para>opened.</para>
        /// </summary>
        /// <param name="instance_id">the joystick instance ID of the gamepad</param>
        /// <remarks>
        /// <para>an SDL_Gamepad on success or NULL on failure or if it hasn't been</para>
        /// <para>opened yet; call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static global::SDL3Sharp.Gamepad GetGamepadFromInstanceID(uint instance_id)
        {
            var ___ret = __Internal.GetGamepadFromInstanceID(instance_id);
            var __result0 = global::SDL3Sharp.Gamepad.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the SDL_Gamepad associated with a player index.</summary>
        /// <param name="player_index">the player index, which different from the instance ID</param>
        /// <remarks>
        /// <para>the SDL_Gamepad associated with a player index.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetGamepadPlayerIndex</para>
        /// <para>SDL_SetGamepadPlayerIndex</para>
        /// </remarks>
        public static global::SDL3Sharp.Gamepad GetGamepadFromPlayerIndex(int player_index)
        {
            var ___ret = __Internal.GetGamepadFromPlayerIndex(player_index);
            var __result0 = global::SDL3Sharp.Gamepad.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get the properties associated with an opened gamepad.</summary>
        /// <param name="gamepad">
        /// <para>a gamepad identifier previously returned by</para>
        /// <para>SDL_OpenGamepad()</para>
        /// </param>
        /// <remarks>
        /// <para>These properties are shared with the underlying joystick object.</para>
        /// <para>The following read-only properties are provided by SDL:</para>
        /// <para>- `SDL_PROP_GAMEPAD_CAP_MONO_LED_BOOLEAN`: true if this gamepad has an LED</para>
        /// <para>that has adjustable brightness</para>
        /// <para>- `SDL_PROP_GAMEPAD_CAP_RGB_LED_BOOLEAN`: true if this gamepad has an LED</para>
        /// <para>that has adjustable color</para>
        /// <para>- `SDL_PROP_GAMEPAD_CAP_PLAYER_LED_BOOLEAN`: true if this gamepad has a</para>
        /// <para>player LED</para>
        /// <para>- `SDL_PROP_GAMEPAD_CAP_RUMBLE_BOOLEAN`: true if this gamepad has</para>
        /// <para>left/right rumble</para>
        /// <para>- `SDL_PROP_GAMEPAD_CAP_TRIGGER_RUMBLE_BOOLEAN`: true if this gamepad has</para>
        /// <para>simple trigger rumble</para>
        /// <para>a valid property ID on success or 0 on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetProperty</para>
        /// <para>SDL_SetProperty</para>
        /// </remarks>
        public static uint GetGamepadProperties(global::SDL3Sharp.Gamepad gamepad)
        {
            var __arg0 = gamepad is null ? __IntPtr.Zero : gamepad.__Instance;
            var ___ret = __Internal.GetGamepadProperties(__arg0);
            return ___ret;
        }

        /// <summary>Get the instance ID of an opened gamepad.</summary>
        /// <param name="gamepad">
        /// <para>a gamepad identifier previously returned by</para>
        /// <para>SDL_OpenGamepad()</para>
        /// </param>
        /// <remarks>
        /// <para>the instance ID of the specified gamepad on success or 0 on</para>
        /// <para>failure; call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_OpenGamepad</para>
        /// </remarks>
        public static uint GetGamepadInstanceID(global::SDL3Sharp.Gamepad gamepad)
        {
            var __arg0 = gamepad is null ? __IntPtr.Zero : gamepad.__Instance;
            var ___ret = __Internal.GetGamepadInstanceID(__arg0);
            return ___ret;
        }

        /// <summary>Get the implementation-dependent name for an opened gamepad.</summary>
        /// <param name="gamepad">
        /// <para>a gamepad identifier previously returned by</para>
        /// <para>SDL_OpenGamepad()</para>
        /// </param>
        /// <remarks>
        /// <para>the implementation dependent name for the gamepad, or NULL if</para>
        /// <para>there is no name or the identifier passed is invalid.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetGamepadInstanceName</para>
        /// <para>SDL_OpenGamepad</para>
        /// </remarks>
        public static string GetGamepadName(global::SDL3Sharp.Gamepad gamepad)
        {
            var __arg0 = gamepad is null ? __IntPtr.Zero : gamepad.__Instance;
            var ___ret = __Internal.GetGamepadName(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Get the implementation-dependent path for an opened gamepad.</summary>
        /// <param name="gamepad">
        /// <para>a gamepad identifier previously returned by</para>
        /// <para>SDL_OpenGamepad()</para>
        /// </param>
        /// <remarks>
        /// <para>the implementation dependent path for the gamepad, or NULL if</para>
        /// <para>there is no path or the identifier passed is invalid.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetGamepadInstancePath</para>
        /// </remarks>
        public static string GetGamepadPath(global::SDL3Sharp.Gamepad gamepad)
        {
            var __arg0 = gamepad is null ? __IntPtr.Zero : gamepad.__Instance;
            var ___ret = __Internal.GetGamepadPath(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Get the type of an opened gamepad.</summary>
        /// <param name="gamepad">the gamepad object to query.</param>
        /// <remarks>
        /// <para>the gamepad type, or SDL_GAMEPAD_TYPE_UNKNOWN if it's not</para>
        /// <para>available.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetGamepadInstanceType</para>
        /// </remarks>
        public static global::SDL3Sharp.GamepadType GetGamepadType(global::SDL3Sharp.Gamepad gamepad)
        {
            var __arg0 = gamepad is null ? __IntPtr.Zero : gamepad.__Instance;
            var ___ret = __Internal.GetGamepadType(__arg0);
            return ___ret;
        }

        /// <summary>Get the type of an opened gamepad, ignoring any mapping override.</summary>
        /// <param name="gamepad">the gamepad object to query.</param>
        /// <remarks>
        /// <para>the gamepad type, or SDL_GAMEPAD_TYPE_UNKNOWN if it's not</para>
        /// <para>available.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetRealGamepadInstanceType</para>
        /// </remarks>
        public static global::SDL3Sharp.GamepadType GetRealGamepadType(global::SDL3Sharp.Gamepad gamepad)
        {
            var __arg0 = gamepad is null ? __IntPtr.Zero : gamepad.__Instance;
            var ___ret = __Internal.GetRealGamepadType(__arg0);
            return ___ret;
        }

        /// <summary>Get the player index of an opened gamepad.</summary>
        /// <param name="gamepad">the gamepad object to query.</param>
        /// <remarks>
        /// <para>For XInput gamepads this returns the XInput user index.</para>
        /// <para>the player index for gamepad, or -1 if it's not available.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int GetGamepadPlayerIndex(global::SDL3Sharp.Gamepad gamepad)
        {
            var __arg0 = gamepad is null ? __IntPtr.Zero : gamepad.__Instance;
            var ___ret = __Internal.GetGamepadPlayerIndex(__arg0);
            return ___ret;
        }

        /// <summary>Set the player index of an opened gamepad.</summary>
        /// <param name="gamepad">the gamepad object to adjust.</param>
        /// <param name="player_index">
        /// <para>Player index to assign to this gamepad, or -1 to clear</para>
        /// <para>the player index and turn off player LEDs.</para>
        /// </param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int SetGamepadPlayerIndex(global::SDL3Sharp.Gamepad gamepad, int player_index)
        {
            var __arg0 = gamepad is null ? __IntPtr.Zero : gamepad.__Instance;
            var ___ret = __Internal.SetGamepadPlayerIndex(__arg0, player_index);
            return ___ret;
        }

        /// <summary>Get the USB vendor ID of an opened gamepad, if available.</summary>
        /// <param name="gamepad">the gamepad object to query.</param>
        /// <remarks>
        /// <para>If the vendor ID isn't available this function returns 0.</para>
        /// <para>the USB vendor ID, or zero if unavailable.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static ushort GetGamepadVendor(global::SDL3Sharp.Gamepad gamepad)
        {
            var __arg0 = gamepad is null ? __IntPtr.Zero : gamepad.__Instance;
            var ___ret = __Internal.GetGamepadVendor(__arg0);
            return ___ret;
        }

        /// <summary>Get the USB product ID of an opened gamepad, if available.</summary>
        /// <param name="gamepad">the gamepad object to query.</param>
        /// <remarks>
        /// <para>If the product ID isn't available this function returns 0.</para>
        /// <para>the USB product ID, or zero if unavailable.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static ushort GetGamepadProduct(global::SDL3Sharp.Gamepad gamepad)
        {
            var __arg0 = gamepad is null ? __IntPtr.Zero : gamepad.__Instance;
            var ___ret = __Internal.GetGamepadProduct(__arg0);
            return ___ret;
        }

        /// <summary>Get the product version of an opened gamepad, if available.</summary>
        /// <param name="gamepad">the gamepad object to query.</param>
        /// <remarks>
        /// <para>If the product version isn't available this function returns 0.</para>
        /// <para>the USB product version, or zero if unavailable.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static ushort GetGamepadProductVersion(global::SDL3Sharp.Gamepad gamepad)
        {
            var __arg0 = gamepad is null ? __IntPtr.Zero : gamepad.__Instance;
            var ___ret = __Internal.GetGamepadProductVersion(__arg0);
            return ___ret;
        }

        /// <summary>Get the firmware version of an opened gamepad, if available.</summary>
        /// <param name="gamepad">the gamepad object to query.</param>
        /// <remarks>
        /// <para>If the firmware version isn't available this function returns 0.</para>
        /// <para>the gamepad firmware version, or zero if unavailable.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static ushort GetGamepadFirmwareVersion(global::SDL3Sharp.Gamepad gamepad)
        {
            var __arg0 = gamepad is null ? __IntPtr.Zero : gamepad.__Instance;
            var ___ret = __Internal.GetGamepadFirmwareVersion(__arg0);
            return ___ret;
        }

        /// <summary>Get the serial number of an opened gamepad, if available.</summary>
        /// <param name="gamepad">the gamepad object to query.</param>
        /// <remarks>
        /// <para>Returns the serial number of the gamepad, or NULL if it is not available.</para>
        /// <para>the serial number, or NULL if unavailable.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static string GetGamepadSerial(global::SDL3Sharp.Gamepad gamepad)
        {
            var __arg0 = gamepad is null ? __IntPtr.Zero : gamepad.__Instance;
            var ___ret = __Internal.GetGamepadSerial(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Get the Steam Input handle of an opened gamepad, if available.</summary>
        /// <param name="gamepad">the gamepad object to query.</param>
        /// <remarks>
        /// <para>Returns an InputHandle_t for the gamepad that can be used with Steam Input</para>
        /// <para>API: https://partner.steamgames.com/doc/api/ISteamInput</para>
        /// <para>the gamepad handle, or 0 if unavailable.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static ulong GetGamepadSteamHandle(global::SDL3Sharp.Gamepad gamepad)
        {
            var __arg0 = gamepad is null ? __IntPtr.Zero : gamepad.__Instance;
            var ___ret = __Internal.GetGamepadSteamHandle(__arg0);
            return ___ret;
        }

        /// <summary>Get the battery level of a gamepad, if available.</summary>
        /// <param name="gamepad">
        /// <para>a gamepad identifier previously returned by</para>
        /// <para>SDL_OpenGamepad()</para>
        /// </param>
        /// <remarks>
        /// <para>the current battery level as SDL_JoystickPowerLevel on success or</para>
        /// <para>`SDL_JOYSTICK_POWER_UNKNOWN` if it is unknown</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static global::SDL3Sharp.JoystickPowerLevel GetGamepadPowerLevel(global::SDL3Sharp.Gamepad gamepad)
        {
            var __arg0 = gamepad is null ? __IntPtr.Zero : gamepad.__Instance;
            var ___ret = __Internal.GetGamepadPowerLevel(__arg0);
            return ___ret;
        }

        /// <summary>Check if a gamepad has been opened and is currently connected.</summary>
        /// <param name="gamepad">
        /// <para>a gamepad identifier previously returned by</para>
        /// <para>SDL_OpenGamepad()</para>
        /// </param>
        /// <remarks>
        /// <para>SDL_TRUE if the gamepad has been opened and is currently</para>
        /// <para>connected, or SDL_FALSE if not.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_CloseGamepad</para>
        /// <para>SDL_OpenGamepad</para>
        /// </remarks>
        public static bool GamepadConnected(global::SDL3Sharp.Gamepad gamepad)
        {
            var __arg0 = gamepad is null ? __IntPtr.Zero : gamepad.__Instance;
            var ___ret = __Internal.GamepadConnected(__arg0);
            return ___ret;
        }

        /// <summary>Get the underlying joystick from a gamepad</summary>
        /// <param name="gamepad">the gamepad object that you want to get a joystick from</param>
        /// <remarks>
        /// <para>This function will give you a SDL_Joystick object, which allows you to use</para>
        /// <para>the SDL_Joystick functions with a SDL_Gamepad object. This would be useful</para>
        /// <para>for getting a joystick's position at any given time, even if it hasn't</para>
        /// <para>moved (moving it would produce an event, which would have the axis' value).</para>
        /// <para>The pointer returned is owned by the SDL_Gamepad. You should not call</para>
        /// <para>SDL_CloseJoystick() on it, for example, since doing so will likely cause</para>
        /// <para>SDL to crash.</para>
        /// <para>an SDL_Joystick object; call SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static global::SDL3Sharp.Joystick GetGamepadJoystick(global::SDL3Sharp.Gamepad gamepad)
        {
            var __arg0 = gamepad is null ? __IntPtr.Zero : gamepad.__Instance;
            var ___ret = __Internal.GetGamepadJoystick(__arg0);
            var __result0 = global::SDL3Sharp.Joystick.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Set the state of gamepad event processing.</summary>
        /// <param name="enabled">whether to process gamepad events or not</param>
        /// <remarks>
        /// <para>If gamepad events are disabled, you must call SDL_UpdateGamepads() yourself</para>
        /// <para>and check the state of the gamepad when you want gamepad information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GamepadEventsEnabled</para>
        /// </remarks>
        public static void SetGamepadEventsEnabled(bool enabled)
        {
            __Internal.SetGamepadEventsEnabled(enabled);
        }

        /// <summary>Query the state of gamepad event processing.</summary>
        /// <remarks>
        /// <para>If gamepad events are disabled, you must call SDL_UpdateGamepads() yourself</para>
        /// <para>and check the state of the gamepad when you want gamepad information.</para>
        /// <para>SDL_TRUE if gamepad events are being processed, SDL_FALSE</para>
        /// <para>otherwise.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_SetGamepadEventsEnabled</para>
        /// </remarks>
        public static bool GamepadEventsEnabled()
        {
            var ___ret = __Internal.GamepadEventsEnabled();
            return ___ret;
        }

        /// <summary>Get the SDL joystick layer bindings for a gamepad</summary>
        /// <param name="gamepad">a gamepad</param>
        /// <param name="count">a pointer filled in with the number of bindings returned</param>
        /// <remarks>
        /// <para>a NULL terminated array of pointers to bindings which should be</para>
        /// <para>freed with SDL_free(), or NULL on error; call SDL_GetError() for</para>
        /// <para>more details.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static global::SDL3Sharp.GamepadBinding GetGamepadBindings(global::SDL3Sharp.Gamepad gamepad, ref int count)
        {
            var __arg0 = gamepad is null ? __IntPtr.Zero : gamepad.__Instance;
            fixed (int* __count1 = &count)
            {
                var __arg1 = __count1;
                var ___ret = __Internal.GetGamepadBindings(__arg0, __arg1);
                __IntPtr _____ret = ___ret == __IntPtr.Zero ? __IntPtr.Zero : new __IntPtr(*(void**) ___ret);
                var __result0 = global::SDL3Sharp.GamepadBinding.__GetOrCreateInstance(_____ret, false);
                return __result0;
            }
        }

        /// <summary>Manually pump gamepad updates if not using the loop.</summary>
        /// <remarks>
        /// <para>This function is called automatically by the event loop if events are</para>
        /// <para>enabled. Under such circumstances, it will not be necessary to call this</para>
        /// <para>function.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static void UpdateGamepads()
        {
            __Internal.UpdateGamepads();
        }

        /// <summary>Convert a string into SDL_GamepadType enum.</summary>
        /// <param name="str">string representing a SDL_GamepadType type</param>
        /// <remarks>
        /// <para>This function is called internally to translate SDL_Gamepad mapping strings</para>
        /// <para>for the underlying joystick device into the consistent SDL_Gamepad mapping.</para>
        /// <para>You do not normally need to call this function unless you are parsing</para>
        /// <para>SDL_Gamepad mappings in your own code.</para>
        /// <para>the SDL_GamepadType enum corresponding to the input string, or</para>
        /// <para>`SDL_GAMEPAD_TYPE_UNKNOWN` if no match was found.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetGamepadStringForType</para>
        /// </remarks>
        public static global::SDL3Sharp.GamepadType GetGamepadTypeFromString(string str)
        {
            var ___ret = __Internal.GetGamepadTypeFromString(str);
            return ___ret;
        }

        /// <summary>Convert from an SDL_GamepadType enum to a string.</summary>
        /// <param name="type">an enum value for a given SDL_GamepadType</param>
        /// <remarks>
        /// <para>The caller should not SDL_free() the returned string.</para>
        /// <para>a string for the given type, or NULL if an invalid type is</para>
        /// <para>specified. The string returned is of the format used by</para>
        /// <para>SDL_Gamepad mapping strings.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetGamepadTypeFromString</para>
        /// </remarks>
        public static string GetGamepadStringForType(global::SDL3Sharp.GamepadType type)
        {
            var ___ret = __Internal.GetGamepadStringForType(type);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Convert a string into SDL_GamepadAxis enum.</summary>
        /// <param name="str">string representing a SDL_Gamepad axis</param>
        /// <remarks>
        /// <para>This function is called internally to translate SDL_Gamepad mapping strings</para>
        /// <para>for the underlying joystick device into the consistent SDL_Gamepad mapping.</para>
        /// <para>You do not normally need to call this function unless you are parsing</para>
        /// <para>SDL_Gamepad mappings in your own code.</para>
        /// <para>Note specially that &quot;righttrigger&quot; and &quot;lefttrigger&quot; map to</para>
        /// <para>`SDL_GAMEPAD_AXIS_RIGHT_TRIGGER` and `SDL_GAMEPAD_AXIS_LEFT_TRIGGER`,</para>
        /// <para>respectively.</para>
        /// <para>the SDL_GamepadAxis enum corresponding to the input string, or</para>
        /// <para>`SDL_GAMEPAD_AXIS_INVALID` if no match was found.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetGamepadStringForAxis</para>
        /// </remarks>
        public static global::SDL3Sharp.GamepadAxis GetGamepadAxisFromString(string str)
        {
            var ___ret = __Internal.GetGamepadAxisFromString(str);
            return ___ret;
        }

        /// <summary>Convert from an SDL_GamepadAxis enum to a string.</summary>
        /// <param name="axis">an enum value for a given SDL_GamepadAxis</param>
        /// <remarks>
        /// <para>The caller should not SDL_free() the returned string.</para>
        /// <para>a string for the given axis, or NULL if an invalid axis is</para>
        /// <para>specified. The string returned is of the format used by</para>
        /// <para>SDL_Gamepad mapping strings.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetGamepadAxisFromString</para>
        /// </remarks>
        public static string GetGamepadStringForAxis(global::SDL3Sharp.GamepadAxis axis)
        {
            var ___ret = __Internal.GetGamepadStringForAxis(axis);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Query whether a gamepad has a given axis.</summary>
        /// <param name="gamepad">a gamepad</param>
        /// <param name="axis">an axis enum value (an SDL_GamepadAxis value)</param>
        /// <remarks>
        /// <para>This merely reports whether the gamepad's mapping defined this axis, as</para>
        /// <para>that is all the information SDL has about the physical device.</para>
        /// <para>SDL_TRUE if the gamepad has this axis, SDL_FALSE otherwise.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static bool GamepadHasAxis(global::SDL3Sharp.Gamepad gamepad, global::SDL3Sharp.GamepadAxis axis)
        {
            var __arg0 = gamepad is null ? __IntPtr.Zero : gamepad.__Instance;
            var ___ret = __Internal.GamepadHasAxis(__arg0, axis);
            return ___ret;
        }

        /// <summary>Get the current state of an axis control on a gamepad.</summary>
        /// <param name="gamepad">a gamepad</param>
        /// <param name="axis">an axis index (one of the SDL_GamepadAxis values)</param>
        /// <remarks>
        /// <para>The axis indices start at index 0.</para>
        /// <para>For thumbsticks, the state is a value ranging from -32768 (up/left) to</para>
        /// <para>32767 (down/right).</para>
        /// <para>Triggers range from 0 when released to 32767 when fully pressed, and never</para>
        /// <para>return a negative value. Note that this differs from the value reported by</para>
        /// <para>the lower-level SDL_GetJoystickAxis(), which normally uses the full range.</para>
        /// <para>axis state (including 0) on success or 0 (also) on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetGamepadButton</para>
        /// </remarks>
        public static short GetGamepadAxis(global::SDL3Sharp.Gamepad gamepad, global::SDL3Sharp.GamepadAxis axis)
        {
            var __arg0 = gamepad is null ? __IntPtr.Zero : gamepad.__Instance;
            var ___ret = __Internal.GetGamepadAxis(__arg0, axis);
            return ___ret;
        }

        /// <summary>Convert a string into an SDL_GamepadButton enum.</summary>
        /// <param name="str">string representing a SDL_Gamepad axis</param>
        /// <remarks>
        /// <para>This function is called internally to translate SDL_Gamepad mapping strings</para>
        /// <para>for the underlying joystick device into the consistent SDL_Gamepad mapping.</para>
        /// <para>You do not normally need to call this function unless you are parsing</para>
        /// <para>SDL_Gamepad mappings in your own code.</para>
        /// <para>the SDL_GamepadButton enum corresponding to the input string, or</para>
        /// <para>`SDL_GAMEPAD_BUTTON_INVALID` if no match was found.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static global::SDL3Sharp.GamepadButton GetGamepadButtonFromString(string str)
        {
            var ___ret = __Internal.GetGamepadButtonFromString(str);
            return ___ret;
        }

        /// <summary>Convert from an SDL_GamepadButton enum to a string.</summary>
        /// <param name="button">an enum value for a given SDL_GamepadButton</param>
        /// <remarks>
        /// <para>The caller should not SDL_free() the returned string.</para>
        /// <para>a string for the given button, or NULL if an invalid button is</para>
        /// <para>specified. The string returned is of the format used by</para>
        /// <para>SDL_Gamepad mapping strings.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetGamepadButtonFromString</para>
        /// </remarks>
        public static string GetGamepadStringForButton(global::SDL3Sharp.GamepadButton button)
        {
            var ___ret = __Internal.GetGamepadStringForButton(button);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Query whether a gamepad has a given button.</summary>
        /// <param name="gamepad">a gamepad</param>
        /// <param name="button">a button enum value (an SDL_GamepadButton value)</param>
        /// <remarks>
        /// <para>This merely reports whether the gamepad's mapping defined this button, as</para>
        /// <para>that is all the information SDL has about the physical device.</para>
        /// <para>SDL_TRUE if the gamepad has this button, SDL_FALSE otherwise.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static bool GamepadHasButton(global::SDL3Sharp.Gamepad gamepad, global::SDL3Sharp.GamepadButton button)
        {
            var __arg0 = gamepad is null ? __IntPtr.Zero : gamepad.__Instance;
            var ___ret = __Internal.GamepadHasButton(__arg0, button);
            return ___ret;
        }

        /// <summary>Get the current state of a button on a gamepad.</summary>
        /// <param name="gamepad">a gamepad</param>
        /// <param name="button">a button index (one of the SDL_GamepadButton values)</param>
        /// <remarks>
        /// <para>1 for pressed state or 0 for not pressed state or error; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetGamepadAxis</para>
        /// </remarks>
        public static byte GetGamepadButton(global::SDL3Sharp.Gamepad gamepad, global::SDL3Sharp.GamepadButton button)
        {
            var __arg0 = gamepad is null ? __IntPtr.Zero : gamepad.__Instance;
            var ___ret = __Internal.GetGamepadButton(__arg0, button);
            return ___ret;
        }

        /// <summary>Get the label of a button on a gamepad.</summary>
        /// <param name="type">the type of gamepad to check</param>
        /// <param name="button">a button index (one of the SDL_GamepadButton values)</param>
        /// <remarks>
        /// <para>the SDL_GamepadButtonLabel enum corresponding to the button label</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetGamepadButtonLabel</para>
        /// </remarks>
        public static global::SDL3Sharp.GamepadButtonLabel GetGamepadButtonLabelForType(global::SDL3Sharp.GamepadType type, global::SDL3Sharp.GamepadButton button)
        {
            var ___ret = __Internal.GetGamepadButtonLabelForType(type, button);
            return ___ret;
        }

        /// <summary>Get the label of a button on a gamepad.</summary>
        /// <param name="gamepad">a gamepad</param>
        /// <param name="button">a button index (one of the SDL_GamepadButton values)</param>
        /// <remarks>
        /// <para>the SDL_GamepadButtonLabel enum corresponding to the button label</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetGamepadButtonLabelForType</para>
        /// </remarks>
        public static global::SDL3Sharp.GamepadButtonLabel GetGamepadButtonLabel(global::SDL3Sharp.Gamepad gamepad, global::SDL3Sharp.GamepadButton button)
        {
            var __arg0 = gamepad is null ? __IntPtr.Zero : gamepad.__Instance;
            var ___ret = __Internal.GetGamepadButtonLabel(__arg0, button);
            return ___ret;
        }

        /// <summary>Get the number of touchpads on a gamepad.</summary>
        /// <param name="gamepad">a gamepad</param>
        /// <remarks>
        /// <para>number of touchpads</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int GetNumGamepadTouchpads(global::SDL3Sharp.Gamepad gamepad)
        {
            var __arg0 = gamepad is null ? __IntPtr.Zero : gamepad.__Instance;
            var ___ret = __Internal.GetNumGamepadTouchpads(__arg0);
            return ___ret;
        }

        /// <summary>
        /// <para>Get the number of supported simultaneous fingers on a touchpad on a game</para>
        /// <para>gamepad.</para>
        /// </summary>
        /// <param name="gamepad">a gamepad</param>
        /// <param name="touchpad">a touchpad</param>
        /// <remarks>
        /// <para>number of supported simultaneous fingers</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int GetNumGamepadTouchpadFingers(global::SDL3Sharp.Gamepad gamepad, int touchpad)
        {
            var __arg0 = gamepad is null ? __IntPtr.Zero : gamepad.__Instance;
            var ___ret = __Internal.GetNumGamepadTouchpadFingers(__arg0, touchpad);
            return ___ret;
        }

        /// <summary>Get the current state of a finger on a touchpad on a gamepad.</summary>
        /// <param name="gamepad">a gamepad</param>
        /// <param name="touchpad">a touchpad</param>
        /// <param name="finger">a finger</param>
        /// <param name="state">filled with state</param>
        /// <param name="x">filled with x position</param>
        /// <param name="y">filled with y position</param>
        /// <param name="pressure">filled with pressure value</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int GetGamepadTouchpadFinger(global::SDL3Sharp.Gamepad gamepad, int touchpad, int finger, byte* state, ref float x, ref float y, ref float pressure)
        {
            var __arg0 = gamepad is null ? __IntPtr.Zero : gamepad.__Instance;
            fixed (float* __x4 = &x)
            {
                var __arg4 = __x4;
                fixed (float* __y5 = &y)
                {
                    var __arg5 = __y5;
                    fixed (float* __pressure6 = &pressure)
                    {
                        var __arg6 = __pressure6;
                        var ___ret = __Internal.GetGamepadTouchpadFinger(__arg0, touchpad, finger, state, __arg4, __arg5, __arg6);
                        return ___ret;
                    }
                }
            }
        }

        /// <summary>Return whether a gamepad has a particular sensor.</summary>
        /// <param name="gamepad">The gamepad to query</param>
        /// <param name="type">The type of sensor to query</param>
        /// <remarks>
        /// <para>SDL_TRUE if the sensor exists, SDL_FALSE otherwise.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static bool GamepadHasSensor(global::SDL3Sharp.Gamepad gamepad, global::SDL3Sharp.SensorType type)
        {
            var __arg0 = gamepad is null ? __IntPtr.Zero : gamepad.__Instance;
            var ___ret = __Internal.GamepadHasSensor(__arg0, type);
            return ___ret;
        }

        /// <summary>Set whether data reporting for a gamepad sensor is enabled.</summary>
        /// <param name="gamepad">The gamepad to update</param>
        /// <param name="type">The type of sensor to enable/disable</param>
        /// <param name="enabled">Whether data reporting should be enabled</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int SetGamepadSensorEnabled(global::SDL3Sharp.Gamepad gamepad, global::SDL3Sharp.SensorType type, bool enabled)
        {
            var __arg0 = gamepad is null ? __IntPtr.Zero : gamepad.__Instance;
            var ___ret = __Internal.SetGamepadSensorEnabled(__arg0, type, enabled);
            return ___ret;
        }

        /// <summary>Query whether sensor data reporting is enabled for a gamepad.</summary>
        /// <param name="gamepad">The gamepad to query</param>
        /// <param name="type">The type of sensor to query</param>
        /// <remarks>
        /// <para>SDL_TRUE if the sensor is enabled, SDL_FALSE otherwise.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static bool GamepadSensorEnabled(global::SDL3Sharp.Gamepad gamepad, global::SDL3Sharp.SensorType type)
        {
            var __arg0 = gamepad is null ? __IntPtr.Zero : gamepad.__Instance;
            var ___ret = __Internal.GamepadSensorEnabled(__arg0, type);
            return ___ret;
        }

        /// <summary>Get the data rate (number of events per second) of a gamepad sensor.</summary>
        /// <param name="gamepad">The gamepad to query</param>
        /// <param name="type">The type of sensor to query</param>
        /// <remarks>
        /// <para>the data rate, or 0.0f if the data rate is not available.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static float GetGamepadSensorDataRate(global::SDL3Sharp.Gamepad gamepad, global::SDL3Sharp.SensorType type)
        {
            var __arg0 = gamepad is null ? __IntPtr.Zero : gamepad.__Instance;
            var ___ret = __Internal.GetGamepadSensorDataRate(__arg0, type);
            return ___ret;
        }

        /// <summary>Get the current state of a gamepad sensor.</summary>
        /// <param name="gamepad">The gamepad to query</param>
        /// <param name="type">The type of sensor to query</param>
        /// <param name="data">A pointer filled with the current sensor state</param>
        /// <param name="num_values">The number of values to write to data</param>
        /// <remarks>
        /// <para>The number of values and interpretation of the data is sensor dependent.</para>
        /// <para>See SDL_sensor.h for the details for each type of sensor.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int GetGamepadSensorData(global::SDL3Sharp.Gamepad gamepad, global::SDL3Sharp.SensorType type, ref float data, int num_values)
        {
            var __arg0 = gamepad is null ? __IntPtr.Zero : gamepad.__Instance;
            fixed (float* __data2 = &data)
            {
                var __arg2 = __data2;
                var ___ret = __Internal.GetGamepadSensorData(__arg0, type, __arg2, num_values);
                return ___ret;
            }
        }

        /// <summary>Start a rumble effect on a gamepad.</summary>
        /// <param name="gamepad">The gamepad to vibrate</param>
        /// <param name="low_frequency_rumble">
        /// <para>The intensity of the low frequency (left)</para>
        /// <para>rumble motor, from 0 to 0xFFFF</para>
        /// </param>
        /// <param name="high_frequency_rumble">
        /// <para>The intensity of the high frequency (right)</para>
        /// <para>rumble motor, from 0 to 0xFFFF</para>
        /// </param>
        /// <param name="duration_ms">The duration of the rumble effect, in milliseconds</param>
        /// <remarks>
        /// <para>Each call to this function cancels any previous rumble effect, and calling</para>
        /// <para>it with 0 intensity stops any rumbling.</para>
        /// <para>This function requires you to process SDL events or call</para>
        /// <para>SDL_UpdateJoysticks() to update rumble state.</para>
        /// <para>0, or -1 if rumble isn't supported on this gamepad</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int RumbleGamepad(global::SDL3Sharp.Gamepad gamepad, ushort low_frequency_rumble, ushort high_frequency_rumble, uint duration_ms)
        {
            var __arg0 = gamepad is null ? __IntPtr.Zero : gamepad.__Instance;
            var ___ret = __Internal.RumbleGamepad(__arg0, low_frequency_rumble, high_frequency_rumble, duration_ms);
            return ___ret;
        }

        /// <summary>Start a rumble effect in the gamepad's triggers.</summary>
        /// <param name="gamepad">The gamepad to vibrate</param>
        /// <param name="left_rumble">
        /// <para>The intensity of the left trigger rumble motor, from 0</para>
        /// <para>to 0xFFFF</para>
        /// </param>
        /// <param name="right_rumble">
        /// <para>The intensity of the right trigger rumble motor, from 0</para>
        /// <para>to 0xFFFF</para>
        /// </param>
        /// <param name="duration_ms">The duration of the rumble effect, in milliseconds</param>
        /// <remarks>
        /// <para>Each call to this function cancels any previous trigger rumble effect, and</para>
        /// <para>calling it with 0 intensity stops any rumbling.</para>
        /// <para>Note that this is rumbling of the _triggers_ and not the gamepad as a</para>
        /// <para>whole. This is currently only supported on Xbox One gamepads. If you want</para>
        /// <para>the (more common) whole-gamepad rumble, use SDL_RumbleGamepad() instead.</para>
        /// <para>This function requires you to process SDL events or call</para>
        /// <para>SDL_UpdateJoysticks() to update rumble state.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int RumbleGamepadTriggers(global::SDL3Sharp.Gamepad gamepad, ushort left_rumble, ushort right_rumble, uint duration_ms)
        {
            var __arg0 = gamepad is null ? __IntPtr.Zero : gamepad.__Instance;
            var ___ret = __Internal.RumbleGamepadTriggers(__arg0, left_rumble, right_rumble, duration_ms);
            return ___ret;
        }

        /// <summary>Update a gamepad's LED color.</summary>
        /// <param name="gamepad">The gamepad to update</param>
        /// <param name="red">The intensity of the red LED</param>
        /// <param name="green">The intensity of the green LED</param>
        /// <param name="blue">The intensity of the blue LED</param>
        /// <remarks>
        /// <para>An example of a joystick LED is the light on the back of a PlayStation 4's</para>
        /// <para>DualShock 4 controller.</para>
        /// <para>For gamepads with a single color LED, the maximum of the RGB values will be</para>
        /// <para>used as the LED brightness.</para>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int SetGamepadLED(global::SDL3Sharp.Gamepad gamepad, byte red, byte green, byte blue)
        {
            var __arg0 = gamepad is null ? __IntPtr.Zero : gamepad.__Instance;
            var ___ret = __Internal.SetGamepadLED(__arg0, red, green, blue);
            return ___ret;
        }

        /// <summary>Send a gamepad specific effect packet</summary>
        /// <param name="gamepad">The gamepad to affect</param>
        /// <param name="data">The data to send to the gamepad</param>
        /// <param name="size">The size of the data to send to the gamepad</param>
        /// <remarks>
        /// <para>0 on success or a negative error code on failure; call</para>
        /// <para>SDL_GetError() for more information.</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// </remarks>
        public static int SendGamepadEffect(global::SDL3Sharp.Gamepad gamepad, __IntPtr data, int size)
        {
            var __arg0 = gamepad is null ? __IntPtr.Zero : gamepad.__Instance;
            var ___ret = __Internal.SendGamepadEffect(__arg0, data, size);
            return ___ret;
        }

        /// <summary>Close a gamepad previously opened with SDL_OpenGamepad().</summary>
        /// <param name="gamepad">
        /// <para>a gamepad identifier previously returned by</para>
        /// <para>SDL_OpenGamepad()</para>
        /// </param>
        /// <remarks>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_OpenGamepad</para>
        /// </remarks>
        public static void CloseGamepad(global::SDL3Sharp.Gamepad gamepad)
        {
            var __arg0 = gamepad is null ? __IntPtr.Zero : gamepad.__Instance;
            __Internal.CloseGamepad(__arg0);
        }

        /// <summary>
        /// <para>Return the sfSymbolsName for a given button on a gamepad on Apple</para>
        /// <para>platforms.</para>
        /// </summary>
        /// <param name="gamepad">the gamepad to query</param>
        /// <param name="button">a button on the gamepad</param>
        /// <remarks>
        /// <para>the sfSymbolsName or NULL if the name can't be found</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetGamepadAppleSFSymbolsNameForAxis</para>
        /// </remarks>
        public static string GetGamepadAppleSFSymbolsNameForButton(global::SDL3Sharp.Gamepad gamepad, global::SDL3Sharp.GamepadButton button)
        {
            var __arg0 = gamepad is null ? __IntPtr.Zero : gamepad.__Instance;
            var ___ret = __Internal.GetGamepadAppleSFSymbolsNameForButton(__arg0, button);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Return the sfSymbolsName for a given axis on a gamepad on Apple platforms.</summary>
        /// <param name="gamepad">the gamepad to query</param>
        /// <param name="axis">an axis on the gamepad</param>
        /// <remarks>
        /// <para>the sfSymbolsName or NULL if the name can't be found</para>
        /// <para>This function is available since SDL 3.0.0.</para>
        /// <para>SDL_GetGamepadAppleSFSymbolsNameForButton</para>
        /// </remarks>
        public static string GetGamepadAppleSFSymbolsNameForAxis(global::SDL3Sharp.Gamepad gamepad, global::SDL3Sharp.GamepadAxis axis)
        {
            var __arg0 = gamepad is null ? __IntPtr.Zero : gamepad.__Instance;
            var ___ret = __Internal.GetGamepadAppleSFSymbolsNameForAxis(__arg0, axis);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }
    }
}
